[{"filePath":"D:\\node\\tauri\\fps-game\\src\\App.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'settingsStore'. Either include it or remove the dependency array.","line":127,"column":6,"nodeType":"ArrayExpression","endLine":127,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [settingsStore]","fix":{"range":[4618,4620],"text":"[settingsStore]"}}]},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'react-hooks/exhaustive-deps').","line":172,"column":5,"severity":1,"nodeType":null,"fix":{"range":[5987,6042],"text":" "}}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'settingsStore'. Either include it or remove the dependency array.","line":134,"column":6,"nodeType":"ArrayExpression","endLine":134,"endColumn":23,"suggestions":[{"desc":"Update the dependencies array to be: [runtimeSettings, settingsStore]","fix":{"range":[4859,4876],"text":"[runtimeSettings, settingsStore]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'settingsStore'. Either include it or remove the dependency array.","line":139,"column":6,"nodeType":"ArrayExpression","endLine":139,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [settingsStore]","fix":{"range":[5036,5038],"text":"[settingsStore]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { useEffect, useRef, useState } from 'react';\r\nimport './App.css';\r\nimport { Game } from './game/core/Game';\r\nimport { GameStateService, GameState } from './game/core/GameState';\r\nimport { LoadingScreen } from './ui/components/LoadingScreen';\r\nimport { HUD } from './ui/hud/HUD';\r\nimport { GameOverScreen } from './ui/components/GameOverScreen';\r\nimport { SettingsOverlay } from './ui/components/SettingsOverlay';\r\nimport type { RuntimeSettings } from './game/core/settings/RuntimeSettings';\r\nimport { RuntimeSettingsStore, createDefaultRuntimeSettings } from './game/core/settings/RuntimeSettingsStore';\r\nimport { LanguageToggle } from './ui/components/LanguageToggle';\r\n\r\nfunction App() {\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n  const gameRef = useRef<Game | null>(null);\r\n  const settingsStoreRef = useRef<RuntimeSettingsStore | null>(null);\r\n  if (!settingsStoreRef.current) {\r\n    settingsStoreRef.current = RuntimeSettingsStore.loadFromLocalStorage();\r\n  }\r\n  const settingsStore = settingsStoreRef.current;\r\n  const [settingsOpen, setSettingsOpen] = useState(false);\r\n  const [runtimeSettings, setRuntimeSettings] = useState<RuntimeSettings>(() => settingsStore.get());\r\n  const [gameState, setGameState] = useState<GameState>({\r\n    health: 100,\r\n    ammo: 300000,\r\n    grenades: 1000,\r\n    currentWeapon: 'rifle',\r\n    chargeProgress: 0,\r\n    stance: 'stand',\r\n    score: 0,\r\n    isGameOver: false,\r\n    pickupHint: null\r\n  });\r\n  \r\n  // 加载状态\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [loadingProgress, setLoadingProgress] = useState(0);\r\n  const [loadingDesc, setLoadingDesc] = useState(\"i18n:loading.stage.init\");\r\n  \r\n  // FPS 和延迟状态\r\n  const [fps, setFps] = useState(0);\r\n  const [ping, setPing] = useState(0);\r\n  const frameTimesRef = useRef<number[]>([]);\r\n  const lastFrameTimeRef = useRef(performance.now());\r\n\r\n  const isPointerLocked = () => {\r\n    const root = containerRef.current;\r\n    const lockedEl = document.pointerLockElement;\r\n    if (!root || !lockedEl) return false;\r\n    return root === lockedEl || root.contains(lockedEl);\r\n  };\r\n\r\n  const resetRuntimeSettings = () => {\r\n    settingsStore.set(createDefaultRuntimeSettings());\r\n  };\r\n\r\n  const requestResume = () => {\r\n    // Close settings immediately and best-effort lock pointer.\r\n    // If lock fails (gesture requirement), user can click the game to lock.\r\n    setSettingsOpen(false);\r\n    gameRef.current?.lockPointer();\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (containerRef.current && !gameRef.current) {\r\n        // 延迟初始化游戏，确保 React 先渲染出 Loading 界面\r\n        setTimeout(() => {\r\n            if (containerRef.current && !gameRef.current) {\r\n                gameRef.current = new Game(\r\n                    containerRef.current, \r\n                    () => {\r\n                        // 当游戏第一帧渲染完成后，关闭 Loading\r\n                        console.log(\"Game Loaded\");\r\n                        setLoadingProgress(100);\r\n                      setLoadingDesc(\"i18n:loading.ready\");\r\n                        setTimeout(() => setIsLoading(false), 500); // 稍微延迟一点消失，展示100%\r\n                    },\r\n                    (progress, desc) => {\r\n                        setLoadingProgress(progress);\r\n                        setLoadingDesc(desc);\r\n                    },\r\n                    { runtimeSettings: settingsStore.get() }\r\n                );\r\n            }\r\n        }, 50);\r\n    }\r\n\r\n    // Subscribe to game state\r\n    const unsubscribe = GameStateService.getInstance().subscribe((state) => {\r\n      setGameState(state);\r\n    });\r\n    \r\n    // FPS 计算\r\n    let animationId: number;\r\n    const updateFps = () => {\r\n      const now = performance.now();\r\n      const delta = now - lastFrameTimeRef.current;\r\n      lastFrameTimeRef.current = now;\r\n      \r\n      frameTimesRef.current.push(delta);\r\n      // 保留最近 60 帧的数据\r\n      if (frameTimesRef.current.length > 60) {\r\n        frameTimesRef.current.shift();\r\n      }\r\n      \r\n      // 每 10 帧更新一次显示\r\n      if (frameTimesRef.current.length % 10 === 0) {\r\n        const avgFrameTime = frameTimesRef.current.reduce((a, b) => a + b, 0) / frameTimesRef.current.length;\r\n        setFps(Math.round(1000 / avgFrameTime));\r\n        \r\n        // 模拟延迟 (本地游戏没有真实网络延迟，显示帧时间作为参考)\r\n        setPing(Math.round(avgFrameTime));\r\n      }\r\n      \r\n      animationId = requestAnimationFrame(updateFps);\r\n    };\r\n    animationId = requestAnimationFrame(updateFps);\r\n\r\n    return () => {\r\n      unsubscribe();\r\n      cancelAnimationFrame(animationId);\r\n      if (gameRef.current) {\r\n        gameRef.current.dispose();\r\n        gameRef.current = null;\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    // Persist + push into the game runtime.\r\n    settingsStore.saveToLocalStorage();\r\n    gameRef.current?.setRuntimeSettings(runtimeSettings);\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [runtimeSettings]);\r\n\r\n  useEffect(() => {\r\n    return settingsStore.subscribe((s) => setRuntimeSettings(s));\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    // Prevent the game's click-to-lock handler from firing while UI overlays are active.\r\n    if (isLoading || settingsOpen) {\r\n      document.body.dataset.uiModalOpen = '1';\r\n    } else {\r\n      delete document.body.dataset.uiModalOpen;\r\n    }\r\n  }, [isLoading, settingsOpen]);\r\n\r\n  useEffect(() => {\r\n    const onPointerLockChange = () => {\r\n      if (isLoading) return;\r\n      if (gameState.isGameOver) return;\r\n\r\n      if (isPointerLocked()) {\r\n        setSettingsOpen(false);\r\n      }\r\n    };\r\n\r\n    document.addEventListener('pointerlockchange', onPointerLockChange);\r\n    return () => document.removeEventListener('pointerlockchange', onPointerLockChange);\r\n  }, [isLoading, gameState.isGameOver]);\r\n\r\n  useEffect(() => {\r\n    if (isLoading) return;\r\n    if (!gameRef.current) return;\r\n\r\n    // Best-effort auto pointer lock on load.\r\n    setTimeout(() => {\r\n      gameRef.current?.lockPointer();\r\n    }, 0);\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [isLoading]);\r\n\r\n  useEffect(() => {\r\n    const onKeyDown = (e: KeyboardEvent) => {\r\n      if (e.key !== 'Escape') return;\r\n      if (isLoading) return;\r\n      if (gameState.isGameOver) return;\r\n\r\n      // If settings is open, Esc resumes (attempts to lock pointer).\r\n      if (settingsOpen) {\r\n        e.preventDefault();\r\n        requestResume();\r\n        return;\r\n      }\r\n\r\n      // If pointer is locked, Esc should unlock and open settings.\r\n      if (isPointerLocked()) {\r\n        e.preventDefault();\r\n        gameRef.current?.unlockPointer();\r\n        setSettingsOpen(true);\r\n        return;\r\n      }\r\n\r\n      // If pointer isn't locked, Esc opens settings.\r\n      e.preventDefault();\r\n      setSettingsOpen(true);\r\n    };\r\n\r\n    // Use capture so inputs (range/number) inside Settings can't swallow Esc.\r\n    window.addEventListener('keydown', onKeyDown, { capture: true });\r\n    return () => window.removeEventListener('keydown', onKeyDown, { capture: true } as any);\r\n  }, [isLoading, gameState.isGameOver, settingsOpen]);\r\n\r\n  return (\r\n    <div ref={containerRef} className=\"w-full h-full relative\">\r\n      {isLoading && (\r\n        <div className=\"fixed top-3 right-3 z-[130] pointer-events-auto\">\r\n          <LanguageToggle />\r\n        </div>\r\n      )}\r\n      <LoadingScreen \r\n        isLoading={isLoading} \r\n        progress={loadingProgress} \r\n        description={loadingDesc} \r\n      />\r\n\r\n      <SettingsOverlay\r\n        open={settingsOpen}\r\n        settings={runtimeSettings}\r\n        onChange={(next) => settingsStore.set(next)}\r\n        onReset={resetRuntimeSettings}\r\n        onClose={requestResume}\r\n      />\r\n\r\n      <HUD \r\n        isLoading={isLoading} \r\n        gameState={gameState} \r\n        fps={fps} \r\n        ping={ping} \r\n      />\r\n\r\n      <GameOverScreen \r\n        isGameOver={gameState.isGameOver} \r\n        score={gameState.score} \r\n        onRestart={() => gameRef.current?.reset()}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\BVH.ts","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-explicit-any').","line":11,"column":5,"severity":1,"nodeType":null,"fix":{"range":[266,328],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-explicit-any').","line":13,"column":5,"severity":1,"nodeType":null,"fix":{"range":[418,480],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-explicit-any').","line":15,"column":5,"severity":1,"nodeType":null,"fix":{"range":[570,632],"text":" "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"import * as THREE from 'three';\r\nimport { acceleratedRaycast, computeBoundsTree, disposeBoundsTree } from 'three-mesh-bvh';\r\n\r\nlet enabled = false;\r\n\r\nexport function enableBVH() {\r\n    if (enabled) return;\r\n    enabled = true;\r\n\r\n    // Patch prototypes once.\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    (THREE.BufferGeometry.prototype as any).computeBoundsTree = computeBoundsTree;\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    (THREE.BufferGeometry.prototype as any).disposeBoundsTree = disposeBoundsTree;\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    (THREE.Mesh.prototype as any).raycast = acceleratedRaycast;\r\n}\r\n\r\nexport function buildBVHForObject(root: THREE.Object3D) {\r\n    root.traverse((obj) => {\r\n        // Skip instanced meshes; BVH doesn't apply the same way and can be expensive.\r\n        if ((obj as any).isInstancedMesh) return;\r\n        if (!(obj as any).isMesh) return;\r\n\r\n        const mesh = obj as THREE.Mesh;\r\n        const geometry = mesh.geometry as THREE.BufferGeometry | undefined;\r\n        if (!geometry) return;\r\n\r\n        // Already built\r\n        if ((geometry as any).boundsTree) return;\r\n\r\n        // Some geometries might be non-indexed or tiny; still fine.\r\n        // Build bounds tree for faster raycast.\r\n        try {\r\n            // three-mesh-bvh adds computeBoundsTree/disposeBoundsTree at runtime via prototype patch.\r\n            (geometry as any).computeBoundsTree?.();\r\n        } catch {\r\n            // If BVH build fails (rare), fall back to default raycast.\r\n        }\r\n    });\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\Game.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'WebGPURenderer' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PostProcessing' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PlayerController' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExplosionManager' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SoundManager' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'GPUComputeSystem' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'LevelConfig' is defined but never used. Allowed unused vars must match /^_/u.","line":19,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'WeatherSystem' is defined but never used. Allowed unused vars must match /^_/u.","line":23,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FrameContext' is defined but never used. Allowed unused vars must match /^_/u.","line":24,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":24,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NumberUniform' is defined but never used. Allowed unused vars must match /^_/u.","line":35,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":35,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EnemyTrailSystem' is defined but never used. Allowed unused vars must match /^_/u.","line":56,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":56,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EnemySystem' is defined but never used. Allowed unused vars must match /^_/u.","line":57,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":57,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PickupSystem' is defined but never used. Allowed unused vars must match /^_/u.","line":58,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":58,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'GrenadeSystem' is defined but never used. Allowed unused vars must match /^_/u.","line":59,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":59,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SpawnSystem' is defined but never used. Allowed unused vars must match /^_/u.","line":60,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":60,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AudioSystem' is defined but never used. Allowed unused vars must match /^_/u.","line":61,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":61,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ShadowSystem' is defined but never used. Allowed unused vars must match /^_/u.","line":62,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":62,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'RenderSystem' is defined but never used. Allowed unused vars must match /^_/u.","line":63,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":63,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Game - 使用 TSL 和 GPU Compute 优化的游戏主类\r\n * 集成所有 shader 系统，最大化 GPU 性能\r\n */\r\nimport * as THREE from \"three\";\r\n// @ts-ignore - WebGPU types not fully available\r\nimport { WebGPURenderer, PostProcessing } from \"three/webgpu\";\r\n\r\nimport { PlayerController } from \"../player/PlayerController\";\r\nimport { ExplosionManager } from \"../entities/ExplosionEffect\";\r\nimport { SoundManager } from \"./SoundManager\";\r\nimport { Level } from \"../level/Level\";\r\nimport { Pathfinding } from \"./Pathfinding\";\r\nimport { PhysicsSystem } from \"./PhysicsSystem\";\r\nimport { enableBVH } from './BVH';\r\nimport { UniformManager } from \"../shaders/TSLMaterials\";\r\nimport type { GPUComputeSystem } from \"../shaders/GPUCompute\";\r\nimport {\r\n    LevelConfig,\r\n    EnemyConfig,\r\n    EffectConfig,\r\n} from \"./GameConfig\";\r\nimport { WeatherSystem } from \"../level/WeatherSystem\";\r\nimport type { FrameContext } from './engine/System';\r\nimport { SystemManager } from './engine/SystemManager';\r\nimport { fillFrameContext } from './engine/FrameContextBuilder';\r\nimport { runShaderWarmup } from './warmup/ShaderWarmupService';\r\nimport { resolveWarmupOptions } from './warmup/WarmupConfig';\r\nimport { runInitPipeline } from './init/InitPipeline';\r\nimport { resolveInitConfig } from './init/InitConfig';\r\nimport { createGameInitSteps } from './init/GameInitSteps';\r\nimport { LoadedGate } from './init/LoadedGate';\r\nimport { HitchProfiler, resolveHitchProfilerSettings } from './perf/HitchProfiler';\r\nimport { FpsCounter } from './perf/FpsCounter';\r\nimport type { NumberUniform } from './render/PostFXPipeline';\r\nimport { createWebGPURenderer } from './render/RendererFactory';\r\nimport { createSceneAndCamera } from './render/SceneFactory';\r\nimport { resizeCameraAndRenderer } from './render/Resize';\r\nimport { createGameplayComposition } from './composition/GameplayComposition';\r\nimport { createPlayerController } from './composition/PlayerFactory';\r\nimport { createGpuSystems } from './composition/GpuSystemsFactory';\r\nimport { createAndRegisterSystemGraph } from './composition/SystemGraphFactory';\r\nimport { createRenderComposition } from './composition/RenderCompositionFactory';\r\nimport { createWebGpuSimulationFacade } from './gpu/GpuSimulationFacade';\r\n\r\nimport type { RuntimeSettings } from './settings/RuntimeSettings';\r\nimport type { RuntimeSettingsSource } from './settings/RuntimeSettings';\r\nimport { createDefaultRuntimeSettings } from './settings/RuntimeSettingsStore';\r\n\r\nimport { getDefaultGameServices } from './services/GameServices';\r\nimport type { GameServices } from './services/GameServices';\r\n\r\nimport { GameEventBus } from './events/GameEventBus';\r\nimport { attachDefaultGameEventHandlers } from './events/DefaultGameEventHandlers';\r\n\r\nimport { EnemyTrailSystem } from '../systems/EnemyTrailSystem';\r\nimport { EnemySystem } from '../systems/EnemySystem';\r\nimport { PickupSystem } from '../systems/PickupSystem';\r\nimport { GrenadeSystem } from '../systems/GrenadeSystem';\r\nimport { SpawnSystem } from '../systems/SpawnSystem';\r\nimport { AudioSystem } from '../systems/AudioSystem';\r\nimport type { ShadowSystem } from '../systems/ShadowSystem';\r\nimport type { RenderSystem } from '../systems/RenderSystem';\r\nimport type { GameRuntime } from './runtime/GameRuntime';\r\nimport type { GpuSimulationFacade, ParticleSimulation } from './gpu/GpuSimulationFacade';\r\n\r\nexport class Game {\r\n    private container: HTMLElement;\r\n    private clock: THREE.Clock;\r\n\r\n    // Runtime graph: renderer/scene/camera/systems are grouped here to keep Game as a composition root.\r\n    private runtime: GameRuntime | null = null;\r\n\r\n    private initConfig = resolveInitConfig();\r\n\r\n    // Keep a stable function reference so removeEventListener works.\r\n    private readonly onResizeBound = this.onWindowResize.bind(this);\r\n\r\n    // 游戏对象\r\n    private objects: THREE.Object3D[] = [];\r\n\r\n    private readonly fpsCounter = new FpsCounter();\r\n\r\n    private hitchProfiler: HitchProfiler;\r\n\r\n    // 加载回调\r\n    private onProgressCallback?: (progress: number, desc: string) => void;\r\n    private onLoadedCallback?: () => void;\r\n    private readonly loadedGate: LoadedGate;\r\n\r\n    private runtimeSettings: RuntimeSettings = createDefaultRuntimeSettings();\r\n    private readonly runtimeSettingsSource: RuntimeSettingsSource = {\r\n        getRuntimeSettings: () => this.runtimeSettings,\r\n    };\r\n\r\n    private readonly services: GameServices;\r\n\r\n    private readonly events = new GameEventBus();\r\n    private disposeDefaultEventHandlers: (() => void) | null = null;\r\n\r\n    constructor(\r\n        container: HTMLElement,\r\n        onLoaded?: () => void,\r\n        onProgress?: (progress: number, desc: string) => void,\r\n        opts?: { runtimeSettings?: RuntimeSettings; services?: GameServices }\r\n    ) {\r\n        this.container = container;\r\n        this.onLoadedCallback = onLoaded;\r\n        this.onProgressCallback = onProgress;\r\n        this.clock = new THREE.Clock();\r\n\r\n        this.services = opts?.services ?? getDefaultGameServices();\r\n\r\n        if (opts?.runtimeSettings) {\r\n            this.runtimeSettings = opts.runtimeSettings;\r\n        }\r\n\r\n        this.hitchProfiler = new HitchProfiler(resolveHitchProfilerSettings());\r\n\r\n        this.loadedGate = new LoadedGate(() => {\r\n            this.updateProgress(100, \"Game Loaded\");\r\n            this.onLoadedCallback?.();\r\n        });\r\n\r\n        // 异步初始化流程，以支持进度更新\r\n        this.initGame();\r\n    }\r\n\r\n    /** Best-effort pointer lock (may require a user gesture in browsers). */\r\n    public lockPointer() {\r\n        try {\r\n            this.runtime?.player.controller?.lock();\r\n        } catch {\r\n            // ignore\r\n        }\r\n    }\r\n\r\n    public unlockPointer() {\r\n        try {\r\n            this.runtime?.player.controller?.unlock();\r\n        } catch {\r\n            // ignore\r\n        }\r\n    }\r\n\r\n    private readonly updateProgress = (progress: number, desc: string) => {\r\n        if (this.onProgressCallback) {\r\n            this.onProgressCallback(progress, desc);\r\n        }\r\n        // 简单的延迟，让 UI 有机会渲染 (在同步代码中这其实并不真正让出主线程，但对于步骤间的逻辑分隔有用)\r\n        // 在 React 的 useEffect 中使用 setTimeout 才是真正让出主线程的关键\r\n    };\r\n\r\n    private async initGame() {\r\n        const actions = {\r\n            initRendererAndUniforms: () => this.initRendererAndUniforms(),\r\n            initSceneAndCamera: () => this.initSceneAndCamera(),\r\n            initPhysicsAndLevel: () => this.initPhysicsAndLevel(),\r\n            initPathfinding: () => this.initPathfinding(),\r\n            initComputeAndParticles: () => this.initComputeAndParticles(),\r\n            initEffectsWeatherSoundAndGameplay: () => this.initEffectsWeatherSoundAndGameplay(),\r\n            initPlayer: () => this.initPlayer(),\r\n            initPostFxAndRenderSystems: () => this.initPostFxAndRenderSystems(),\r\n            initCoreUpdateSystems: () => this.initCoreUpdateSystems(),\r\n            runWarmup: () => this.runWarmup(),\r\n            startMainLoop: () => this.startMainLoop(),\r\n        };\r\n\r\n        await runInitPipeline(\r\n            createGameInitSteps(actions),\r\n            { yieldBetweenSteps: this.initConfig.yieldBetweenSteps, yieldMs: this.initConfig.yieldMs }\r\n        );\r\n    }\r\n\r\n    private initRendererAndUniforms(): void {\r\n        this.updateProgress(10, \"i18n:loading.stage.webgpu\");\r\n\r\n        const uniforms = UniformManager.getInstance();\r\n\r\n        // Default event wiring: systems emit events; this adapter updates state, plays audio, and triggers common FX.\r\n        this.disposeDefaultEventHandlers?.();\r\n        this.disposeDefaultEventHandlers = attachDefaultGameEventHandlers(this.events, {\r\n            services: this.services,\r\n            setDamageFlashIntensity: (v) => {\r\n                uniforms.damageFlash.value = v;\r\n            },\r\n        });\r\n\r\n        const renderer = createWebGPURenderer(this.container);\r\n\r\n        this.runtime = {\r\n            container: this.container,\r\n            renderer,\r\n            // placeholders; filled in subsequent init steps\r\n            scene: null as any,\r\n            camera: null as any,\r\n            objects: this.objects,\r\n            uniforms,\r\n            services: this.services,\r\n            events: this.events,\r\n            clock: this.clock,\r\n            fpsCounter: this.fpsCounter,\r\n            hitchProfiler: this.hitchProfiler,\r\n            systemManager: new SystemManager(),\r\n            frameContext: {\r\n                delta: 0,\r\n                playerPos: { x: 0, y: 0, z: 0 },\r\n                health: 0,\r\n                aimProgress: 0,\r\n            },\r\n            systemTimings: Object.create(null),\r\n            loadedGate: this.loadedGate,\r\n            world: null as any,\r\n            gpu: null as any,\r\n            render: null as any,\r\n            gameplay: null as any,\r\n            player: null as any,\r\n            disposeDefaultEventHandlers: this.disposeDefaultEventHandlers,\r\n        };\r\n    }\r\n\r\n    private initSceneAndCamera(): void {\r\n        this.updateProgress(20, \"i18n:loading.stage.scene\");\r\n\r\n        if (!this.runtime) return;\r\n\r\n        const created = createSceneAndCamera();\r\n        this.runtime.scene = created.scene;\r\n        this.runtime.camera = created.camera;\r\n\r\n        // render module is filled later; store lights there for discoverability\r\n        this.runtime.render = {\r\n            postProcessing: null as any,\r\n            scopeAimProgress: null as any,\r\n            shadowSystem: null as any,\r\n            renderSystem: null as any,\r\n            ambientLight: created.ambientLight,\r\n            sunLight: created.sunLight,\r\n        };\r\n    }\r\n\r\n    private initPhysicsAndLevel(): void {\r\n        this.updateProgress(30, \"i18n:loading.stage.physics\");\r\n        enableBVH();\r\n\r\n        if (!this.runtime) return;\r\n\r\n        const physicsSystem = new PhysicsSystem();\r\n        const level = new Level(this.runtime.scene, this.objects, physicsSystem);\r\n        this.runtime.world = {\r\n            physicsSystem,\r\n            level,\r\n            pathfinding: null as any,\r\n        };\r\n    }\r\n\r\n    private initPathfinding(): void {\r\n        this.updateProgress(45, \"i18n:loading.stage.pathfinding\");\r\n        if (!this.runtime) return;\r\n        const pathfinding = new Pathfinding(this.objects);\r\n        this.runtime.world.pathfinding = pathfinding;\r\n    }\r\n\r\n    private initComputeAndParticles(): void {\r\n        this.updateProgress(55, \"i18n:loading.stage.compute\");\r\n        if (!this.runtime) return;\r\n\r\n        const gpu = createGpuSystems({\r\n            renderer: this.runtime.renderer,\r\n            scene: this.runtime.scene,\r\n            gpuCompute: this.initConfig.gpuCompute,\r\n            particles: this.initConfig.particles,\r\n        });\r\n\r\n        this.runtime.gpu = {\r\n            gpuCompute: gpu.gpuCompute,\r\n            particleSystem: gpu.particleSystem,\r\n            simulation: createWebGpuSimulationFacade({\r\n                gpuCompute: gpu.gpuCompute,\r\n                particleSystem: gpu.particleSystem,\r\n            }),\r\n        };\r\n    }\r\n\r\n    private initEffectsWeatherSoundAndGameplay(): void {\r\n        this.updateProgress(65, \"i18n:loading.stage.effects\");\r\n\r\n        if (!this.runtime) return;\r\n\r\n        const gameplay = createGameplayComposition({\r\n            events: this.events,\r\n            services: this.services,\r\n            scene: this.runtime.scene,\r\n            camera: this.runtime.camera,\r\n            renderer: this.runtime.renderer,\r\n            objects: this.objects,\r\n            level: this.runtime.world.level,\r\n            physicsSystem: this.runtime.world.physicsSystem,\r\n            pathfinding: this.runtime.world.pathfinding,\r\n            simulation: this.runtime.gpu.simulation,\r\n            uniforms: this.runtime.uniforms,\r\n            ambientLight: this.runtime.render.ambientLight,\r\n            sunLight: this.runtime.render.sunLight,\r\n            maxGpuEnemies: 100,\r\n        });\r\n\r\n        this.runtime.gameplay = {\r\n            explosionManager: gameplay.explosionManager,\r\n            weatherSystem: gameplay.weatherSystem,\r\n            soundManager: gameplay.soundManager,\r\n            enemyTrailSystem: gameplay.enemyTrailSystem,\r\n            enemySystem: gameplay.enemySystem,\r\n            pickupSystem: gameplay.pickupSystem,\r\n            grenadeSystem: gameplay.grenadeSystem,\r\n            spawnSystem: gameplay.spawnSystem,\r\n            audioSystem: gameplay.audioSystem,\r\n        };\r\n    }\r\n\r\n    private initPlayer(): void {\r\n        this.updateProgress(75, \"i18n:loading.stage.player\");\r\n\r\n        if (!this.runtime) return;\r\n\r\n        const controller = createPlayerController({\r\n            settings: this.runtimeSettingsSource,\r\n            services: this.services,\r\n            events: this.events,\r\n            camera: this.runtime.camera,\r\n            container: this.container,\r\n            scene: this.runtime.scene,\r\n            objects: this.objects,\r\n            physicsSystem: this.runtime.world.physicsSystem,\r\n            level: this.runtime.world.level,\r\n            particleSystem: this.runtime.gpu.simulation.particles,\r\n            enemies: this.runtime.gameplay.enemySystem.all,\r\n            pickups: this.runtime.gameplay.pickupSystem,\r\n            grenades: this.runtime.gameplay.grenadeSystem,\r\n            weather: this.runtime.gameplay.weatherSystem,\r\n            spawn: { x: 0, z: 0 },\r\n        });\r\n\r\n        this.runtime.player = { controller };\r\n    }\r\n\r\n    public setRuntimeSettings(settings: RuntimeSettings): void {\r\n        this.runtimeSettings = settings;\r\n    }\r\n\r\n    /** Reset the current session without reloading the page. */\r\n    public reset(): void {\r\n        try {\r\n            this.services.state.reset();\r\n\r\n            const runtime = this.runtime;\r\n            if (!runtime) return;\r\n\r\n            // Best-effort: clear active enemies so a new run starts clean.\r\n            (runtime.gameplay.enemySystem as any)?.clearAll?.();\r\n\r\n            // Reset player physics + position.\r\n            const spawnX = 0;\r\n            const spawnZ = 0;\r\n            const spawnHeight = runtime.world.level?.getTerrainHeight(spawnX, spawnZ) ?? 0;\r\n            runtime.camera.position.set(spawnX, spawnHeight + 2.0, spawnZ);\r\n            runtime.player.controller?.resetPhysics?.();\r\n        } catch {\r\n            // ignore\r\n        }\r\n    }\r\n\r\n    private initPostFxAndRenderSystems(): void {\r\n        this.updateProgress(85, \"i18n:loading.stage.postfx\");\r\n        if (!this.runtime) return;\r\n        const render = createRenderComposition({\r\n            renderer: this.runtime.renderer,\r\n            scene: this.runtime.scene,\r\n            camera: this.runtime.camera,\r\n            uniforms: this.runtime.uniforms,\r\n            sunLight: this.runtime.render.sunLight,\r\n        });\r\n        this.runtime.render = {\r\n            ...this.runtime.render,\r\n            postProcessing: render.postProcessing,\r\n            scopeAimProgress: render.scopeAimProgress,\r\n            shadowSystem: render.shadowSystem,\r\n            renderSystem: render.renderSystem,\r\n        };\r\n    }\r\n\r\n    private initCoreUpdateSystems(): void {\r\n        if (!this.runtime) return;\r\n        const core = createAndRegisterSystemGraph({\r\n            systemManager: this.runtime.systemManager,\r\n            player: this.runtime.player.controller,\r\n            camera: this.runtime.camera,\r\n            scopeAimProgress: this.runtime.render.scopeAimProgress,\r\n            uniforms: this.runtime.uniforms,\r\n            simulation: this.runtime.gpu.simulation,\r\n            level: this.runtime.world.level,\r\n            enemyConfig: EnemyConfig,\r\n            weatherSystem: this.runtime.gameplay.weatherSystem,\r\n            enemySystem: this.runtime.gameplay.enemySystem,\r\n            enemyTrailSystem: this.runtime.gameplay.enemyTrailSystem,\r\n            grenadeSystem: this.runtime.gameplay.grenadeSystem,\r\n            pickupSystem: this.runtime.gameplay.pickupSystem,\r\n            spawnSystem: this.runtime.gameplay.spawnSystem,\r\n            audioSystem: this.runtime.gameplay.audioSystem,\r\n            shadowSystem: this.runtime.render.shadowSystem,\r\n            renderSystem: this.runtime.render.renderSystem,\r\n        });\r\n\r\n        void core;\r\n\r\n        this.updateProgress(90, \"i18n:loading.stage.spawn\");\r\n        window.addEventListener(\"resize\", this.onResizeBound);\r\n    }\r\n\r\n    private async runWarmup(): Promise<void> {\r\n        if (!this.runtime) return;\r\n        await runShaderWarmup({\r\n            renderer: this.runtime.renderer,\r\n            scene: this.runtime.scene,\r\n            camera: this.runtime.camera,\r\n            playerController: this.runtime.player.controller,\r\n            level: this.runtime.world.level,\r\n            physicsSystem: this.runtime.world.physicsSystem,\r\n            enemySystem: this.runtime.gameplay.enemySystem,\r\n            uniformManager: this.runtime.uniforms,\r\n            simulation: this.runtime.gpu.simulation,\r\n            postProcessing: this.runtime.render.postProcessing,\r\n            updateProgress: this.updateProgress,\r\n            options: resolveWarmupOptions(),\r\n        });\r\n    }\r\n\r\n    private startMainLoop(): void {\r\n        this.updateProgress(98, \"i18n:loading.stage.startLoop\");\r\n        this.runtime?.renderer.setAnimationLoop(this.animate);\r\n\r\n        this.updateProgress(99, \"i18n:loading.stage.finalize\");\r\n        this.loadedGate.start(this.initConfig.loading.onLoadedDelayFrames);\r\n    }\r\n\r\n    /**\r\n     * 设置光照\r\n     */\r\n    /**\r\n     * 窗口大小变化\r\n     */\r\n    private onWindowResize() {\r\n        if (!this.runtime) return;\r\n        resizeCameraAndRenderer({\r\n            camera: this.runtime.camera,\r\n            renderer: this.runtime.renderer,\r\n            width: window.innerWidth,\r\n            height: window.innerHeight,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 主循环\r\n     */\r\n    private readonly animate = () => {\r\n        const runtime = this.runtime;\r\n        if (!runtime) return;\r\n\r\n        const frameStartMs = runtime.hitchProfiler.beginFrame();\r\n        const rawDelta = runtime.clock.getDelta();\r\n        const delta = Math.min(rawDelta, 0.1);\r\n\r\n        runtime.fpsCounter.update(delta);\r\n\r\n        const gameState = this.services.state.getState();\r\n\r\n        if (gameState.isGameOver) {\r\n            runtime.player.controller.unlock();\r\n            return;\r\n        }\r\n\r\n        // Update core systems (uniforms/compute/particles/weather/level) via SystemManager.\r\n        // Keeps the main loop slimmer and makes it easier to add/remove systems.\r\n        fillFrameContext({\r\n            frame: runtime.frameContext,\r\n            delta,\r\n            cameraPosition: runtime.camera.position,\r\n            health: gameState.health,\r\n        });\r\n\r\n        if (runtime.hitchProfiler.isEnabled()) {\r\n            // Keep per-system timings for hitch logs.\r\n            let t0 = performance.now();\r\n            runtime.systemManager.update(runtime.frameContext, runtime.systemTimings, () => performance.now());\r\n            const _tCoreSystemsMs = performance.now() - t0;\r\n            void _tCoreSystemsMs;\r\n        } else {\r\n            runtime.systemManager.update(runtime.frameContext);\r\n        }\r\n\r\n        // Hitch profiler logging (heavy work only runs on slow frames).\r\n        if (runtime.hitchProfiler.isEnabled()) {\r\n            runtime.hitchProfiler.recordFrame({\r\n                frameStartMs,\r\n                rawDeltaSeconds: rawDelta,\r\n                camera: runtime.camera,\r\n                renderer: runtime.renderer,\r\n                systemTimings: runtime.systemTimings,\r\n                enemies: runtime.gameplay.enemySystem,\r\n                pickups: runtime.gameplay.pickupSystem,\r\n                grenades: runtime.gameplay.grenadeSystem,\r\n            });\r\n        }\r\n\r\n        // Defer \"loaded\" callback until a few frames have been presented.\r\n        runtime.loadedGate.update();\r\n\r\n    };\r\n\r\n    /**\r\n     * 获取当前 FPS\r\n     */\r\n    public getFPS(): number {\r\n        return this.fpsCounter.getFPS();\r\n    }\r\n\r\n    /**\r\n     * 获取粒子系统 (用于外部触发效果)\r\n     */\r\n    public getSimulation(): GpuSimulationFacade {\r\n        if (!this.runtime) {\r\n            throw new Error('Game runtime not initialized yet');\r\n        }\r\n        return this.runtime.gpu.simulation;\r\n    }\r\n\r\n    public getParticles(): ParticleSimulation {\r\n        return this.getSimulation().particles;\r\n    }\r\n\r\n    /**\r\n     * 触发伤害效果\r\n     */\r\n    public triggerDamageEffect() {\r\n        const runtime = this.runtime;\r\n        if (!runtime) return;\r\n        runtime.uniforms.damageFlash.value = EffectConfig.damageFlash.intensity;\r\n    }\r\n\r\n    /**\r\n     * 销毁\r\n     */\r\n    public dispose() {\r\n        this.disposeDefaultEventHandlers?.();\r\n        this.disposeDefaultEventHandlers = null;\r\n\r\n        const runtime = this.runtime;\r\n        if (!runtime) return;\r\n\r\n        runtime.disposeDefaultEventHandlers = null;\r\n\r\n        // Stop the render loop first so nothing schedules more GPU work.\r\n        try {\r\n            runtime.renderer.setAnimationLoop(null);\r\n        } catch {\r\n            // ignore\r\n        }\r\n\r\n        runtime.player.controller.dispose();\r\n        runtime.systemManager.dispose();\r\n        runtime.gameplay.explosionManager.dispose();\r\n\r\n        // GPU resources (explicit)\r\n        try {\r\n            runtime.gpu.gpuCompute.dispose();\r\n        } catch {\r\n            // ignore\r\n        }\r\n        try {\r\n            runtime.gpu.particleSystem.dispose();\r\n        } catch {\r\n            // ignore\r\n        }\r\n\r\n        // Postprocessing resources (best-effort; API surface differs across three versions)\r\n        try {\r\n            (runtime.render.postProcessing as any)?.dispose?.();\r\n        } catch {\r\n            // ignore\r\n        }\r\n\r\n        runtime.renderer.dispose();\r\n\r\n        window.removeEventListener(\"resize\", this.onResizeBound);\r\n        this.container.removeChild(runtime.renderer.domElement);\r\n\r\n        this.runtime = null;\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\GameConfig.ts","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-explicit-any').","line":10,"column":5,"severity":1,"nodeType":null,"fix":{"range":[181,243],"text":" "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"/**\r\n * GameConfig - 游戏配置中心\r\n * 集中管理所有游戏参数，便于调整和维护\r\n */\r\n\r\nfunction deepFreeze<T>(obj: T): T {\r\n    if (!obj || typeof obj !== 'object') return obj;\r\n    Object.freeze(obj);\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    const anyObj = obj as any;\r\n    for (const key of Object.getOwnPropertyNames(anyObj)) {\r\n        const value = anyObj[key];\r\n        if (value && typeof value === 'object' && !Object.isFrozen(value)) {\r\n            deepFreeze(value);\r\n        }\r\n    }\r\n\r\n    return obj;\r\n}\r\n\r\n// ==================== 玩家配置 ====================\r\nexport const PlayerConfig = {\r\n    // 移动速度\r\n    movement: {\r\n        walkSpeed: 60.0,           // 行走速度\r\n        runSpeed: 120.0,           // 奔跑速度\r\n        friction: 10.0,            // 摩擦力/减速系数\r\n        jumpHeight: 10.0,          // 跳跃高度\r\n        gravity: 30.0,             // 重力\r\n    },\r\n    \r\n    // 姿态配置\r\n    stance: {\r\n        stand: {\r\n            height: 1.6,           // 站立时相机高度\r\n            speedMultiplier: 1.0,  // 速度倍率\r\n            collisionHeight: 1.8,  // 碰撞盒高度\r\n        },\r\n        crouch: {\r\n            height: 0.9,           // 蹲下时相机高度\r\n            speedMultiplier: 0.5,  // 速度倍率 (50%)\r\n            collisionHeight: 1.0,  // 碰撞盒高度\r\n        },\r\n        prone: {\r\n            height: 0.4,           // 趴下时相机高度\r\n            speedMultiplier: 0.25, // 速度倍率 (25%)\r\n            collisionHeight: 0.5,  // 碰撞盒高度\r\n        },\r\n    },\r\n    \r\n    // 碰撞配置\r\n    collision: {\r\n        radius: 0.3,               // 玩家碰撞半径\r\n        skinWidth: 0.1,            // 皮肤宽度 (用于水平碰撞检测)\r\n        maxStepHeight: 0.6,        // 最大可跨越台阶高度\r\n    },\r\n    \r\n    // 视角配置\r\n    camera: {\r\n        sensitivity: 0.002,        // 鼠标灵敏度\r\n        smoothFactor: 0.15,        // 平滑因子 (越低越平滑)\r\n        defaultFov: 75,            // 默认视野角度\r\n        aimFov: 25,                // 瞄准时视野角度\r\n        aimSensitivityMultiplier: 0.35,  // 瞄准时灵敏度倍率\r\n        fovLerpSpeed: 10.0,        // FOV 变化速度\r\n    },\r\n};\r\n\r\n// ==================== 武器配置 ====================\r\nexport const WeaponConfig = {\r\n    // 枪械\r\n    gun: {\r\n        fireRate: 10,              // 每秒射击次数\r\n        damage: 34,                // 腰射伤害\r\n        sniperDamage: 150,         // 狙击伤害 (开镜)\r\n        range: 100,                // 射程\r\n        recoil: {\r\n            vertical: 0.02,        // 垂直后座力\r\n            horizontal: 0.01,      // 水平后座力\r\n            recovery: 5.0,         // 后座力恢复速度\r\n            amount: 0.05,          // 后座力位移量\r\n        },\r\n        muzzleFlash: {\r\n            duration: 0.05,        // 枪口火焰持续时间\r\n            intensity: 2.0,        // 光照强度\r\n        },\r\n        bulletTrail: {\r\n            fadeTime: 100,         // 弹道轨迹淡出时间 (ms)\r\n            coreRadius: 0.015,     // 核心半径\r\n            glowRadius: 0.04,      // 发光半径\r\n        },\r\n    },\r\n    \r\n    // 瞄准配置\r\n    aim: {\r\n        speed: 8.0,                // 瞄准过渡速度\r\n        hipPosition: { x: 0.3, y: -0.25, z: -0.6 },   // 腰射位置\r\n        adsPosition: { x: 0, y: -0.18, z: -0.4 },     // 瞄准位置 (居中)\r\n    },\r\n    \r\n    // 手榴弹\r\n    grenade: {\r\n        fuseTime: 3.0,             // 引信时间 (秒)\r\n        throwStrength: 20,         // 投掷力度\r\n        explosionRadius: 8.0,      // 爆炸半径\r\n        explosionDamage: 100,      // 爆炸伤害\r\n        radius: 0.06,              // 手榴弹碰撞半径\r\n        physics: {\r\n            gravity: -25,          // 重力\r\n            bounceFactor: 0.4,     // 弹跳系数\r\n            friction: 0.98,        // 摩擦力\r\n            groundFriction: 0.7,   // 地面摩擦\r\n            bounceAngularDamping: 0.6, // 弹跳角速度衰减\r\n        },\r\n    },\r\n\r\n    // 近战 / 蓄力投掷（knife/scythe）\r\n    melee: {\r\n        // 近战动作时序（秒）\r\n        swing: {\r\n            knife: { duration: 0.24, hitTime: 0.42 },\r\n            scythe: { duration: 0.36, hitTime: 0.5 },\r\n            axe: { duration: 0.42, hitTime: 0.5 },\r\n        },\r\n\r\n        // 蓄力投掷/回旋（秒/米）\r\n        chargeThrow: {\r\n            chargeMinSeconds: 0.28,\r\n            chargeMaxSeconds: 0.9,\r\n            throwStartForward: 0.6,\r\n            returnForward: 0.35,\r\n            returnLerpBoost: 1.25,\r\n\r\n            knife: {\r\n                outDistBase: 8,\r\n                outDistBonus: 10,\r\n                totalTime: 0.95,\r\n                outTime: 0.56,\r\n                baseDamage: 40,\r\n                bonusDamage: 35,\r\n                hitRadius: 1.0,\r\n                sideCurve: 0.9,\r\n                spinX: 10,\r\n                spinZ: 16,\r\n            },\r\n            scythe: {\r\n                outDistBase: 10,\r\n                outDistBonus: 14,\r\n                totalTime: 1.15,\r\n                outTime: 0.62,\r\n                baseDamage: 55,\r\n                bonusDamage: 45,\r\n                hitRadius: 1.3,\r\n                sideCurve: 1.2,\r\n                spinX: 10,\r\n                spinZ: 16,\r\n                // performance: cut grass using cached instance positions (no raycast)\r\n                grassCheckInterval: 0.05,\r\n                grassCutRadius: 1.4,\r\n                grassMaxCandidateMeshes: 3,\r\n            },\r\n        },\r\n\r\n        // 环境交互（用于避免 InstancedMesh 极端坐标导致的 culling 异常）\r\n        environment: {\r\n            choppedTreeSink: 50,\r\n            cutGrassSink: 20,\r\n        },\r\n    },\r\n    \r\n    // 武器切换\r\n    switching: {\r\n        cooldown: 200,             // 切换冷却时间 (ms)\r\n    },\r\n};\r\n\r\n// ==================== 敌人配置 ====================\r\nexport type EnemyType = 'scout' | 'soldier' | 'heavy' | 'elite';\r\n\r\nexport const EnemyTypesConfig = {\r\n    scout: {\r\n        name: 'Scout',\r\n        health: 50,\r\n        speed: 4.5,\r\n        scale: 0.9,\r\n        color: 0xE67E22, // 焦橙色 (高可视度)\r\n        weapon: 'smg',\r\n        attack: {\r\n            damage: 5,\r\n            range: 35,\r\n            fireRate: 3.0,\r\n            accuracy: 0.6,\r\n            engageRange: 30,\r\n        },\r\n        ai: {\r\n            chaseSpeed: 5.5,\r\n            aimSpeed: 10.0,\r\n        }\r\n    },\r\n    soldier: {\r\n        name: 'Soldier',\r\n        health: 100,\r\n        speed: 3.0,\r\n        scale: 1.0,\r\n        color: 0x2E8B57, // 海洋绿 (军用迷彩感)\r\n        weapon: 'rifle',\r\n        attack: {\r\n            damage: 10,\r\n            range: 50,\r\n            fireRate: 1.5,\r\n            accuracy: 0.8,\r\n            engageRange: 40,\r\n        },\r\n        ai: {\r\n            chaseSpeed: 4.0,\r\n            aimSpeed: 8.0,\r\n        }\r\n    },\r\n    heavy: {\r\n        name: 'Heavy',\r\n        health: 250,\r\n        speed: 1.5,\r\n        scale: 1.25,\r\n        color: 0x1A5276, // 深海蓝 (防暴警察感，区别于黑)\r\n        weapon: 'shotgun',\r\n        attack: {\r\n            damage: 20, // 这是一个弹丸或者一次射击的基准\r\n            range: 25,\r\n            fireRate: 0.6,\r\n            accuracy: 0.5,\r\n            engageRange: 15,\r\n        },\r\n        ai: {\r\n            chaseSpeed: 2.5,\r\n            aimSpeed: 5.0,\r\n        }\r\n    },\r\n    elite: {\r\n        name: 'Elite',\r\n        health: 150,\r\n        speed: 3.5,\r\n        scale: 1.1,\r\n        color: 0xC0392B, // 鲜红色 (高威胁)\r\n        weapon: 'sniper',\r\n        attack: {\r\n            damage: 40,\r\n            range: 80,\r\n            fireRate: 0.5,\r\n            accuracy: 0.95,\r\n            engageRange: 70,\r\n        },\r\n        ai: {\r\n            chaseSpeed: 4.5,\r\n            aimSpeed: 12.0,\r\n        }\r\n    }\r\n};\r\n\r\nexport const EnemyConfig = {\r\n    // 基础属性 (默认值，实际使用 TypesConfig)\r\n    health: 100,                   \r\n    speed: 3.0,                    \r\n    turnSpeed: 5.0,                \r\n    rotationSpeed: 8.0,            \r\n    \r\n    // 攻击配置 (默认值)\r\n    attack: {\r\n        damage: 8,                 \r\n        range: 50,                 \r\n        fireRate: 1.5,             \r\n        accuracy: 0.85,            \r\n        engageRange: 40,           \r\n        muzzleFlashDuration: 0.05, \r\n    },\r\n    \r\n    // AI 配置\r\n    ai: {\r\n        detectionRange: 50,        // 探测范围\r\n        loseTargetTime: 5.0,       // 失去目标时间\r\n        patrolSpeed: 1.5,          // 巡逻速度\r\n        chaseSpeed: 4.0,           // 追击速度 (默认)\r\n        pathUpdateInterval: 0.5,   // 路径更新间隔\r\n        aimSpeed: 8.0,             // 抬枪速度\r\n        aimHoldDuration: 0.8,      // 射击后保持瞄准时间\r\n\r\n        // 性能/渲染 LOD\r\n        farUpdateDistance: 55,     // 超过此距离后，AI/碰撞等降频更新\r\n        farUpdateInterval: 0.33,   // 远距离敌人的更新间隔 (秒)\r\n        limbLodDistance: 45,       // 超过此距离后隐藏四肢/武器等细节\r\n        shadowDisableDistance: 65, // 超过此距离后禁用投射阴影以减少阴影开销\r\n        // Keep this above the longest player weapon range (sniper=250) so far targets remain shootable/visible.\r\n        renderCullDistance: 350,   // 超过此距离后直接隐藏敌人 (避免远处大量 drawcalls)\r\n    },\r\n\r\n    // GPU Compute (敌人) 配置：当前逻辑主要走 CPU，GPU 路径可关闭以避免额外开销\r\n    gpuCompute: {\r\n        enabled: false,\r\n        targetUpdateDistance: 120,\r\n    },\r\n\r\n    // 运动能力（让敌人更接近玩家的移动表现）\r\n    movement: {\r\n        gravity: 24.0,             // 重力加速度 (m/s^2)\r\n        jumpHeight: 1.4,           // 跳跃高度（用于翻越/跳上低障碍）\r\n        jumpCooldown: 1.0,         // 跳跃冷却（秒）\r\n        // 允许尝试“跳上去”的障碍高度上限（超过则需要楼梯/绕路）\r\n        maxJumpObstacleHeight: 1.6,\r\n        // 起跳时给一点前冲，帮助跳过窄障碍\r\n        jumpForwardBoost: 0.9,\r\n    },\r\n    \r\n    // 碰撞配置\r\n    collision: {\r\n        radius: 0.5,               // 碰撞半径\r\n        height: 1.0,               // 碰撞高度 (从中心)\r\n        skinWidth: 0.1,            // 皮肤宽度\r\n        maxStepHeight: 0.6,        // 最大可跨越高度\r\n        targetHeightOffset: 0.8,   // 目标高度偏移 (躯干)\r\n    },\r\n    \r\n    // 弹道配置\r\n    bulletTrail: {\r\n        fadeTime: 80,              // 淡出时间 (ms)\r\n        coreRadius: 0.008,         // 核心半径\r\n        innerGlowRadius: 0.025,    // 内发光半径\r\n        outerGlowRadius: 0.05,     // 外发光半径\r\n        color: {\r\n            core: 0xff6600,        // 核心颜色\r\n            innerGlow: 0xff3300,   // 内发光颜色\r\n            outerGlow: 0xff2200,   // 外发光颜色\r\n        },\r\n    },\r\n    \r\n    // 击杀奖励\r\n    rewards: {\r\n        score: 100,                // 击杀得分\r\n    },\r\n};\r\n\r\n// ==================== 拾取物配置 ====================\r\nexport const PickupConfig = {\r\n    // 弹药箱\r\n    ammo: {\r\n        amount: 15,                // 弹药数量\r\n        respawnTime: 30,           // 重生时间 (秒)\r\n    },\r\n    \r\n    // 血包\r\n    health: {\r\n        amount: 25,                // 恢复生命值\r\n        respawnTime: 45,           // 重生时间 (秒)\r\n    },\r\n    \r\n    // 手榴弹\r\n    grenade: {\r\n        amount: 2,                 // 手榴弹数量\r\n        respawnTime: 60,           // 重生时间 (秒)\r\n    },\r\n    \r\n    // 交互配置\r\n    interaction: {\r\n        range: 2.0,                // 拾取范围\r\n    },\r\n    \r\n    // 视觉配置\r\n    visual: {\r\n        floatHeight: 0.8,          // 漂浮高度\r\n        bobSpeed: 1.5,             // 浮动速度\r\n        bobHeight: 0.1,            // 浮动高度\r\n        rotateSpeed: 0.8,          // 旋转速度\r\n    },\r\n};\r\n\r\n// ==================== 特效配置 ====================\r\nexport const EffectConfig = {\r\n    // 爆炸特效\r\n    explosion: {\r\n        duration: 400,             // 持续时间 (ms)\r\n        maxScale: 3.0,             // 最大缩放\r\n        initialScale: 0.5,         // 初始缩放\r\n        floatUp: 0.3,              // 上飘距离\r\n        flashIntensity: 30,        // 闪光强度\r\n        flashDecay: 3,             // 闪光衰减速度\r\n        poolSize: 8,               // 对象池大小\r\n    },\r\n    \r\n    // 血液特效\r\n    blood: {\r\n        particleCount: 25,         // 主要粒子数量\r\n        sideParticleCount: 8,      // 侧面粒子数量\r\n        lifetime: { min: 0.3, max: 0.6 },\r\n        speed: { min: 3, max: 8 },\r\n    },\r\n    \r\n    // 火花特效\r\n    spark: {\r\n        particleCount: 20,\r\n        lifetime: { min: 0.2, max: 0.5 },\r\n        speed: { min: 2, max: 6 },\r\n    },\r\n    \r\n    // 伤害反馈\r\n    damageFlash: {\r\n        intensity: 0.7,            // 初始强度\r\n        decaySpeed: 3.0,           // 衰减速度\r\n    },\r\n};\r\n\r\n// ==================== UI 配置 ====================\r\nexport const UIConfig = {\r\n    // 准星\r\n    crosshair: {\r\n        size: 16,                  // 大小 (像素)\r\n        thickness: 2,              // 线条粗细\r\n        gap: 4,                    // 中心间隙\r\n        color: '#ffffff',          // 颜色\r\n    },\r\n    \r\n    // HUD\r\n    hud: {\r\n        healthWarning: 30,         // 生命值警告阈值\r\n        ammoWarning: 10,           // 弹药警告阈值\r\n    },\r\n};\r\n\r\n// ==================== 游戏初始状态 ====================\r\nexport const InitialState = {\r\n    health: 1000000,\r\n    ammo: 3000000,\r\n    grenades: 50000,\r\n    score: 0,\r\n};\r\n\r\n// ==================== 关卡配置 ====================\r\nexport const LevelConfig = {\r\n    // 玩家安全生成区 (半径)\r\n    safeZoneRadius: 15.0,\r\n    \r\n    // 敌人生成\r\n    enemySpawn: {\r\n        maxEnemies: 2,            // 最大敌人数量\r\n        spawnInterval: 5000,       // 生成间隔 (ms)\r\n        spawnRadius: { min: 20, max: 40 },  // 生成距离范围\r\n        initialDelay: 10000,          // 首次生成延迟 (ms)\r\n        disabled: false,         // 是否禁用敌人生成\r\n    },\r\n    \r\n    // 拾取物生成\r\n    pickupSpawn: {\r\n        maxPickups: 8,             // 最大拾取物数量\r\n        initialDelay: 2000,        // 首次生成延迟 (ms)\r\n        spawnInterval: 10000,      // 后续生成间隔 (ms)\r\n    },\r\n};\r\n\r\n// ==================== 天气配置 ====================\r\nexport type WeatherType = 'sunny' | 'rainy' | 'windy' | 'sandstorm';\r\n\r\nexport const WeatherConfig = {\r\n    // 天气切换\r\n    transitionDuration: 3.0,       // 天气切换过渡时间 (秒)\r\n    autoChange: {\r\n        enabled: true,             // 是否自动切换天气\r\n        minDuration: 500,           // 最短持续时间 (秒)\r\n        maxDuration: 5000,          // 最长持续时间 (秒)\r\n    },\r\n    \r\n    // 晴天配置\r\n    sunny: {\r\n        skyColor: 0x87ceeb,        // 天空颜色\r\n        fogColor: 0x87ceeb,        // 雾气颜色\r\n        fogNear: 100,              // 雾气起始距离\r\n        fogFar: 800,               // 雾气结束距离 (匹配可视距离)\r\n        ambientIntensity: 0.6,     // 环境光强度\r\n        sunIntensity: 1.2,         // 太阳光强度\r\n        sunColor: 0xffffff,        // 太阳光颜色\r\n        windStrength: 0.0,         // 风力强度\r\n        particleDensity: 0,        // 粒子密度\r\n    },\r\n    \r\n    // 暴雨配置\r\n    rainy: {\r\n        skyColor: 0x2d3748,        // 更暗的天空\r\n        fogColor: 0x4a5568,        // 深灰色雾气\r\n        fogNear: 50,               // 雾气起始距离\r\n        fogFar: 600,               // 能见度较低\r\n        ambientIntensity: 0.15,    // 非常暗的环境光\r\n        sunIntensity: 0.1,         // 太阳几乎不可见\r\n        sunColor: 0x6b7280,        // 深灰色光\r\n        windStrength: 1.0,         // 强风伴随暴雨\r\n        particleDensity: 20000,    // 大量雨滴 (增加数量以适应大范围)\r\n        rain: {\r\n            speed: { min: 25, max: 40 },\r\n            size: { width: 0.03, height: 0.5 },\r\n            color: 0x8899bb,\r\n            opacity: 0.7,\r\n            area: { x: 200, y: 50, z: 200 },  // 降雨区域跟随相机，不需要覆盖全图\r\n        },\r\n    },\r\n    \r\n    // 大风配置\r\n    windy: {\r\n        skyColor: 0x9ca3af,        // 多云天空\r\n        fogColor: 0xa0aec0,        // 雾气颜色\r\n        fogNear: 50,               // 雾气起始\r\n        fogFar: 300,               // 能见度\r\n        ambientIntensity: 0.5,     // 环境光\r\n        sunIntensity: 0.7,         // 太阳光\r\n        sunColor: 0xe5e7eb,        // 偏白光\r\n        windStrength: 1.5,         // 强风\r\n        particleDensity: 1000,     // 树叶/灰尘数量\r\n        wind: {\r\n            direction: { x: 1, y: 0.1, z: 0.3 },  // 风向\r\n            gustFrequency: 2.0,     // 阵风频率\r\n            gustStrength: 0.5,      // 阵风强度变化\r\n        },\r\n        debris: {\r\n            size: { min: 0.05, max: 0.15 },  // 碎片大小\r\n            color: 0x8b7355,         // 碎片颜色 (树叶/灰尘)\r\n            rotationSpeed: 5.0,      // 旋转速度\r\n        },\r\n    },\r\n    \r\n    // 沙尘暴配置\r\n    sandstorm: {\r\n        skyColor: 0xc9a86c,        // 沙黄色天空\r\n        fogColor: 0xd4a84b,        // 黄色雾气\r\n        fogNear: 10,               // 极近的雾\r\n        fogFar: 100,               // 能见度极低\r\n        ambientIntensity: 0.4,     // 昏暗环境\r\n        sunIntensity: 0.2,         // 太阳几乎不可见\r\n        sunColor: 0xd4a84b,        // 黄色光\r\n        windStrength: 2.5,         // 极强风力\r\n        particleDensity: 15000,    // 大量沙粒\r\n        sand: {\r\n            speed: { min: 8, max: 15 },     // 沙粒速度\r\n            size: { min: 0.02, max: 0.08 }, // 沙粒大小\r\n            color: 0xd4a84b,         // 沙粒颜色\r\n            opacity: 0.7,            // 透明度\r\n            area: { x: 150, y: 30, z: 150 },  // 沙尘区域跟随相机\r\n        },\r\n        visibility: {\r\n            damagePerSecond: 0,      // 沙尘伤害 (可选)\r\n            movementPenalty: 0.8,    // 移动速度惩罚\r\n        },\r\n    },\r\n};\r\n\r\n// ==================== 环境植被配置 ====================\r\nexport enum TreeType {\r\n    Pine = 0,\r\n    Oak = 1,\r\n    Birch = 2\r\n}\r\n\r\nexport const EnvironmentConfig = {\r\n    trees: {\r\n        // Density is interpreted as trees per square meter.\r\n        // The previous value (0.06) produced extreme counts on 500x500 chunks (15k+ trees per chunk),\r\n        // exploding triangles even with instancing.\r\n        density: 0.0035,\r\n        noise: { \r\n            scale: 0.005,    \r\n            threshold: 0.45, \r\n        },\r\n        // Distribution tuning (controls how \"forest patches\" form).\r\n        // These values are intentionally exposed so we don't hardcode density behavior in systems.\r\n        distribution: {\r\n            // Chunk-level weight: controls how much of the total tree budget goes to dense chunks.\r\n            // Higher exponent/amplitude => fewer but much denser forests.\r\n            macroWeight: {\r\n                base: 0.04,\r\n                exponent: 4.4,\r\n                amplitude: 7.2,\r\n            },\r\n            // Remap macro noise (0..1) -> denseFactor (0..1), emphasizing top-end.\r\n            denseFactor: {\r\n                start: 0.42,\r\n                range: 0.34,\r\n                power: 1.45,\r\n            },\r\n            // Keep shoreline a bit less dense.\r\n            shoreFade: {\r\n                startDistance: 250,\r\n                min: 0.24,\r\n                max: 0.76,\r\n            },\r\n            // Micro-noise threshold shift based on denseFactor.\r\n            // Positive sparseBoost makes sparse areas clearer; negative denseReduce makes dense areas pack tighter.\r\n            microThresholdShift: {\r\n                sparseBoost: 0.06,\r\n                denseReduce: 0.18,\r\n            },\r\n            // Global tree budget multiplier (overall forest fullness).\r\n            globalBudgetMultiplier: 1.5,\r\n            // Disable leaf shadow casting when a single InstancedMesh batch is extremely dense.\r\n            leafShadowCutoff: 500,\r\n        },\r\n        // 树种配置\r\n        types: [\r\n            {\r\n                type: TreeType.Pine,\r\n                probability: 0.4,\r\n                scale: { min: 0.6, max: 0.9 }, \r\n                colors: { trunk: 0x594026, leavesDeep: 0x1a661a, leavesLight: 0x338033 },\r\n                geometry: {\r\n                    layers: 5,\r\n                    baseRadius: 0.8,   // 变细一半 (1.6 -> 0.8)\r\n                    height: 5.5,       \r\n                    jaggedness: 0.3\r\n                }\r\n            },\r\n            {\r\n                type: TreeType.Oak,\r\n                probability: 0.4,\r\n                scale: { min: 0.7, max: 1.1 }, \r\n                colors: { trunk: 0x664d33, leavesDeep: 0x33801a, leavesLight: 0x66b333 },\r\n                geometry: {\r\n                    height: 3.5,\r\n                    clusters: 10,\r\n                    clusterSize: 0.6, // 变小一半 (1.2 -> 0.6)\r\n                    spread: 1.0       // 分布范围也收缩 (1.8 -> 1.0)\r\n                }\r\n            },\r\n            {\r\n                type: TreeType.Birch,\r\n                probability: 0.2,\r\n                scale: { min: 0.6, max: 0.9 }, \r\n                colors: { trunk: 0xe6e6cc, leavesDeep: 0x4d991a, leavesLight: 0xcccc33 },\r\n                geometry: {\r\n                    height: 5.2,\r\n                    clusters: 7,\r\n                    clusterSize: 0.4 // 变小一半 (0.8 -> 0.4)\r\n                }\r\n            }\r\n        ],\r\n        trunk: {\r\n            // 通用树干配置作为fallback，具体参数在各自树种生成时指定\r\n            segments: 7\r\n        },\r\n        placement: {\r\n            minAltitude: -2.0, // 高于水位 (-3.0) 避免长在水里\r\n            excludeRadius: {\r\n                spawn: 45,\r\n                default: 15\r\n            }\r\n        }\r\n    },\r\n    grass: {\r\n        noise: {\r\n            scale: 0.02,     \r\n            threshold: 0.35  \r\n        },\r\n        // Distribution tuning (controls how \"thick grass patches\" form).\r\n        distribution: {\r\n            macroWeight: {\r\n                base: 0.04,\r\n                exponent: 4.6,\r\n                amplitude: 7.8,\r\n            },\r\n            denseFactor: {\r\n                start: 0.42,\r\n                range: 0.34,\r\n                power: 1.45,\r\n            },\r\n            shoreFade: {\r\n                startDistance: 250,\r\n                min: 0.24,\r\n                max: 0.76,\r\n            },\r\n            microThresholdShift: {\r\n                sparseBoost: 0.07,\r\n                denseReduce: 0.20,\r\n            },\r\n        },\r\n        tall: {\r\n            count: 80000,\r\n            height: 1.2,\r\n            width: 0.12,\r\n            bladeCount: 7,\r\n            colorBase: 0x112200,\r\n            colorTip: 0x4d6600,\r\n            scale: { min: 0.8, max: 1.3 }\r\n        },\r\n        shrub: {\r\n            count: 35000,\r\n            colorBase: 0x003300,\r\n            colorTip: 0x2d8600,\r\n            scale: { min: 0.5, max: 0.9 },\r\n            width: 0.8, \r\n            height: 0.7, \r\n            segments: 8\r\n        },\r\n        dry: {\r\n            count: 25000,\r\n            height: 0.9,\r\n            width: 0.1,\r\n            bladeCount: 5,\r\n            colorBase: 0x3a3a10,\r\n            colorTip: 0x86862d,\r\n            scale: { min: 0.7, max: 1.1 }\r\n        },\r\n        placement: {\r\n            excludeRadius: {\r\n                spawn: 25,\r\n                default: 8\r\n            }\r\n        }\r\n    },\r\n    water: {\r\n        level: -3.0,\r\n        color: 0x234d57, // 更自然的蓝绿色 (Teal)\r\n        foamColor: 0xffffff,\r\n        opacity: 1   // 更高的不透明度\r\n    }\r\n};\r\n\r\n// ==================== 地图配置 ====================\r\nexport const MapConfig = {\r\n    size: 4000,           // 地图大小 - 扩大以覆盖可视区域 (750 + 800 * 2)\r\n    wallHeight: 0,        // 废弃\r\n    waterLevel: -3.0,     // 水面高度\r\n    boundaryRadius: 750,  // 实际可活动半径 (圆柱形边界)\r\n    chunkSize: 500,      // 分块大小 (用于LOD和剔除) - 增大以减少 InstancedMesh 数量 (从 1600->64)，大幅降低 Draw Calls\r\n    maxViewDistance: 800, // 最大可见距离 (为了看到海)\r\n    terrainSegments: 800, // 地形细分数量 (保持 ~1米精度)\r\n    terrainHeight: 15.0,  // 地形最大起伏高度\r\n};\r\n\r\n// ==================== 音效配置 ====================\r\nexport const SoundConfig = {\r\n    // 全局音量\r\n    masterVolume: 0.3,\r\n    bgmVolume: 1.0,\r\n\r\n    // 背景音乐配置\r\n    bgm: {\r\n        fadeDuration: 0.5, // Crossfade duration in seconds\r\n        sunnyVolume: 0.8,\r\n        rainyVolume: 0.8,\r\n        combatVolume: 0.8,\r\n    },\r\n    \r\n    // 武器音效\r\n    weapon: {\r\n        shoot: {\r\n            throttle: 50, // ms\r\n            volume: 0.5,\r\n        },\r\n    },\r\n\r\n    // 环境音效\r\n    ambient: {\r\n        rain: {\r\n            filterLow: 3000,\r\n            filterHigh: 500,\r\n        },\r\n        wind: {\r\n            filterFreq: 400,\r\n            lfoFreq: 0.4,\r\n        },\r\n        sandstorm: {\r\n             filterLow: 2000,\r\n             filterHigh: 200,\r\n        }\r\n    }\r\n};\r\n\r\n// Prevent accidental runtime mutation of config.\r\n// Runtime-tunable values should live in RuntimeSettings; these remain constants.\r\ndeepFreeze(PlayerConfig);\r\ndeepFreeze(WeaponConfig);\r\ndeepFreeze(EnemyTypesConfig);\r\ndeepFreeze(EnemyConfig);\r\ndeepFreeze(PickupConfig);\r\ndeepFreeze(EffectConfig);\r\ndeepFreeze(UIConfig);\r\ndeepFreeze(InitialState);\r\ndeepFreeze(LevelConfig);\r\ndeepFreeze(WeatherConfig);\r\ndeepFreeze(EnvironmentConfig);\r\ndeepFreeze(MapConfig);\r\ndeepFreeze(SoundConfig);\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\GameState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\Pathfinding.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\PhysicsSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'MapConfig' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":19},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-explicit-any').","line":114,"column":9,"severity":1,"nodeType":null,"fix":{"range":[4185,4247],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-explicit-any').","line":119,"column":17,"severity":1,"nodeType":null,"fix":{"range":[4485,4547],"text":" "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":2,"source":"import * as THREE from 'three';\r\nimport { MapConfig } from './GameConfig';\r\nimport { buildBVHForObject } from './BVH';\r\n\r\n/**\r\n * 物理系统 - 使用空间划分 (Spatial Partitioning) 优化碰撞检测\r\n * 使用 Grid (网格) 索引静态物体，避免 O(N) 遍历\r\n */\r\nexport class PhysicsSystem {\r\n    private static instance: PhysicsSystem;\r\n    \r\n    // 网格大小 (米)\r\n    // 玩家移动速度约 6m/s ~ 12m/s\r\n    // 10m 的网格比较合适，每次查询周围 3x3 个网格\r\n    private cellSize: number = 20; \r\n    \r\n    // 空间哈希表: Key = \"x_z\", Value = colliders list\r\n    private grid: Map<number, Array<{ box: THREE.Box3; object: THREE.Object3D; colliderId: number }>> = new Map();\r\n    \r\n    // 所有的静态碰撞体 (备用)\r\n    private staticColliders: Array<{ box: THREE.Box3; object: THREE.Object3D; colliderId: number }> = [];\r\n\r\n    // Avoid per-query Set allocations by using an ever-increasing stamp.\r\n    // Note: AABB broadphase needs to de-dupe by colliderId (InstancedMesh uses per-instance colliders),\r\n    // while raycast candidate collection should de-dupe by object.id.\r\n    private visitStampCollider = 1;\r\n    private visitedColliderIds: Map<number, number> = new Map();\r\n\r\n    private visitStampObject = 1;\r\n    private visitedObjectIds: Map<number, number> = new Map();\r\n\r\n    private nextColliderId = 1;\r\n\r\n    // Packed grid key (x,z) -> uint32 in JS number.\r\n    // With current map sizes, 16-bit signed cell indices are plenty.\r\n    private readonly keyOffset = 32768;\r\n    private packKey(x: number, z: number): number {\r\n        const xx = (x + this.keyOffset) & 0xffff;\r\n        const zz = (z + this.keyOffset) & 0xffff;\r\n        return (xx << 16) | zz;\r\n    }\r\n\r\n    private beginVisitColliders() {\r\n        this.visitStampCollider++;\r\n        if (this.visitStampCollider >= Number.MAX_SAFE_INTEGER) {\r\n            this.visitStampCollider = 1;\r\n            this.visitedColliderIds.clear();\r\n        }\r\n    }\r\n\r\n    private isColliderVisited(id: number): boolean {\r\n        return this.visitedColliderIds.get(id) === this.visitStampCollider;\r\n    }\r\n\r\n    private markColliderVisited(id: number) {\r\n        this.visitedColliderIds.set(id, this.visitStampCollider);\r\n    }\r\n\r\n    private beginVisitObjects() {\r\n        this.visitStampObject++;\r\n        if (this.visitStampObject >= Number.MAX_SAFE_INTEGER) {\r\n            this.visitStampObject = 1;\r\n            this.visitedObjectIds.clear();\r\n        }\r\n    }\r\n\r\n    private isObjectVisited(id: number): boolean {\r\n        return this.visitedObjectIds.get(id) === this.visitStampObject;\r\n    }\r\n\r\n    private markObjectVisited(id: number) {\r\n        this.visitedObjectIds.set(id, this.visitStampObject);\r\n    }\r\n\r\n    constructor() {\r\n        // Singleton or Instance per Level\r\n    }\r\n\r\n    /**\r\n     * 添加静态碰撞体\r\n     * 会计算包围盒并添加到对应的网格中\r\n     */\r\n    public addStaticObject(object: THREE.Object3D) {\r\n        this.prepareStaticObject(object);\r\n\r\n        // 计算精确的世界坐标包围盒\r\n        const box = new THREE.Box3().setFromObject(object);\r\n        \r\n        // 如果包围盒无效，跳过\r\n        if (box.isEmpty()) return;\r\n        \r\n        // Use object.id as colliderId for normal objects\r\n        this.addStaticBoxCollider(box, object, object.id);\r\n    }\r\n\r\n    /**\r\n     * Prepare an object for raycasts / BVH (without registering its AABB into the grid).\r\n     * Useful when the render object is an InstancedMesh but collision is registered per-instance.\r\n     */\r\n    public prepareStaticObject(object: THREE.Object3D) {\r\n        // IMPORTANT:\r\n        // Many environment obstacles are Meshes parented under a transformed Group (stairs, sandbags, etc.).\r\n        // Before the first render, their `matrixWorld` may still be stale, causing Box3 to be computed at the\r\n        // origin and resulting in \"no collision\" even though the mesh is visible elsewhere.\r\n        // Force-update the full transform chain so the cached Box3 is correct.\r\n        object.updateWorldMatrix(true, true);\r\n\r\n        // Build BVH for meshes under this object so later raycasts are fast.\r\n        // (Done once at registration time; safe for static geometry)\r\n        buildBVHForObject(object);\r\n\r\n        // Precompute raycast mesh targets for weapons/LOS so the first shot doesn't\r\n        // traverse complex object hierarchies at runtime.\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        const ud = (object.userData ?? (object.userData = {})) as any;\r\n        if (!ud._hitscanTargets || !ud._meleeTargets) {\r\n            const targets: THREE.Object3D[] = [];\r\n            object.traverse((obj) => {\r\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                const anyObj = obj as any;\r\n                if (!anyObj.isMesh) return;\r\n                const userData = obj.userData;\r\n                if (userData?.noRaycast) return;\r\n                if (userData?.isWayPoint) return;\r\n                if (userData?.isDust) return;\r\n                if (userData?.isSkybox) return;\r\n                if (userData?.isWeatherParticle) return;\r\n                if (userData?.isEffect) return;\r\n                if (userData?.isBulletTrail) return;\r\n                if (userData?.isGrenade) return;\r\n                targets.push(obj);\r\n            });\r\n            ud._hitscanTargets = targets;\r\n            ud._meleeTargets = targets;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register a precomputed world-space AABB collider into the spatial grid.\r\n     * If colliderId is not provided, an internal unique id is generated.\r\n     */\r\n    public addStaticBoxCollider(box: THREE.Box3, object: THREE.Object3D, colliderId?: number) {\r\n        if (box.isEmpty()) return;\r\n\r\n        const id = colliderId ?? this.nextColliderId++;\r\n        const entry = { box, object, colliderId: id };\r\n        this.staticColliders.push(entry);\r\n\r\n        // 将物体添加到覆盖的所有网格中\r\n        const minX = Math.floor(box.min.x / this.cellSize);\r\n        const maxX = Math.floor(box.max.x / this.cellSize);\r\n        const minZ = Math.floor(box.min.z / this.cellSize);\r\n        const maxZ = Math.floor(box.max.z / this.cellSize);\r\n\r\n        for (let x = minX; x <= maxX; x++) {\r\n            for (let z = minZ; z <= maxZ; z++) {\r\n                const key = this.packKey(x, z);\r\n                if (!this.grid.has(key)) {\r\n                    this.grid.set(key, []);\r\n                }\r\n                this.grid.get(key)!.push(entry);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * 获取指定区域附近的碰撞体\r\n     * @param position 中心位置\r\n     * @param radius 查询半径\r\n     */\r\n    public getNearbyObjectsInto(\r\n        position: THREE.Vector3,\r\n        radius: number,\r\n        out: Array<{ box: THREE.Box3; object: THREE.Object3D }>\r\n    ): Array<{ box: THREE.Box3; object: THREE.Object3D }> {\r\n        this.beginVisitColliders();\r\n        out.length = 0;\r\n        // 计算查询范围覆盖的网格\r\n        const minX = Math.floor((position.x - radius) / this.cellSize);\r\n        const maxX = Math.floor((position.x + radius) / this.cellSize);\r\n        const minZ = Math.floor((position.z - radius) / this.cellSize);\r\n        const maxZ = Math.floor((position.z + radius) / this.cellSize);\r\n\r\n        for (let x = minX; x <= maxX; x++) {\r\n            for (let z = minZ; z <= maxZ; z++) {\r\n                const key = this.packKey(x, z);\r\n                const cellObjects = this.grid.get(key);\r\n                if (cellObjects) {\r\n                    for (const entry of cellObjects) {\r\n                        if (this.isColliderVisited(entry.colliderId)) continue;\r\n                        // 简单的距离裁剪 (可选，Box3 Intersects Box3 已经很快了)\r\n                        // 这里我们直接返回所有候选者，交给调用者做精确的 AABB 测试\r\n                        out.push(entry);\r\n                        this.markColliderVisited(entry.colliderId);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return out;\r\n    }\r\n\r\n    public getNearbyObjects(position: THREE.Vector3, radius: number = 2.0): Array<{ box: THREE.Box3, object: THREE.Object3D }> {\r\n        return this.getNearbyObjectsInto(position, radius, []);\r\n    }\r\n    \r\n    /**\r\n     * 清理\r\n     */\r\n    public clear() {\r\n        this.grid.clear();\r\n        this.staticColliders = [];\r\n        this.nextColliderId = 1;\r\n    }\r\n\r\n    /**\r\n     * 射线检测 - 获取射线路径上的所有候选物体 (Broad Phase)\r\n     * 使用网格遍历算法 (Grid Traversal) 快速筛选\r\n     * @param origin 射线起点\r\n     * @param direction 射线方向 (主要是 X Z 平面)\r\n     * @param maxDistance 最大检测距离\r\n     */\r\n    public getRaycastCandidates(origin: THREE.Vector3, direction: THREE.Vector3, maxDistance: number): THREE.Object3D[] {\r\n        return this.getRaycastCandidatesInto(origin, direction, maxDistance, []);\r\n    }\r\n\r\n    public getRaycastCandidatesInto(\r\n        origin: THREE.Vector3,\r\n        direction: THREE.Vector3,\r\n        maxDistance: number,\r\n        out: THREE.Object3D[],\r\n    ): THREE.Object3D[] {\r\n        this.beginVisitObjects();\r\n        out.length = 0;\r\n\r\n        // 2D DDA Algorithm (Amanatides & Woo) on XZ plane\r\n        // Normalize direction for 2D\r\n        const dirX = direction.x;\r\n        const dirZ = direction.z;\r\n        \r\n        // Ray start in grid coords\r\n        let currentX = Math.floor(origin.x / this.cellSize);\r\n        let currentZ = Math.floor(origin.z / this.cellSize);\r\n        \r\n        // Step direction\r\n        const stepX = Math.sign(dirX);\r\n        const stepZ = Math.sign(dirZ);\r\n        \r\n        // Delta distance (distance to travel one cell on that axis)\r\n        const tDeltaX = Math.abs(this.cellSize / dirX);\r\n        const tDeltaZ = Math.abs(this.cellSize / dirZ);\r\n        \r\n        // Initial distance to next boundary\r\n        let tMaxX = 0;\r\n        let tMaxZ = 0;\r\n        \r\n        if (dirX > 0) {\r\n            tMaxX = ((currentX + 1) * this.cellSize - origin.x) / dirX;\r\n        } else if (dirX < 0) {\r\n            tMaxX = (currentX * this.cellSize - origin.x) / dirX;\r\n        } else {\r\n            tMaxX = Infinity;\r\n        }\r\n        \r\n        if (dirZ > 0) {\r\n            tMaxZ = ((currentZ + 1) * this.cellSize - origin.z) / dirZ;\r\n        } else if (dirZ < 0) {\r\n            tMaxZ = (currentZ * this.cellSize - origin.z) / dirZ;\r\n        } else {\r\n            tMaxZ = Infinity;\r\n        }\r\n        \r\n        // Walk the grid\r\n        let tCurrent = 0;\r\n        \r\n        // Safety Break\r\n        let iterations = 0;\r\n        const maxSteps = Math.ceil(maxDistance / this.cellSize) * 2 + 5;\r\n\r\n        while (tCurrent < maxDistance && iterations < maxSteps) {\r\n            // Check current cell\r\n            const key = this.packKey(currentX, currentZ);\r\n            const cellObjects = this.grid.get(key);\r\n            \r\n            if (cellObjects) {\r\n                for (const entry of cellObjects) {\r\n                    if (!this.isObjectVisited(entry.object.id)) {\r\n                        const ud = entry.object.userData;\r\n                        if (ud?.noRaycast || ud?.isWayPoint) {\r\n                            this.markObjectVisited(entry.object.id);\r\n                            continue;\r\n                        }\r\n                        out.push(entry.object);\r\n                        this.markObjectVisited(entry.object.id);\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // Move to next cell\r\n            if (tMaxX < tMaxZ) {\r\n                tCurrent = tMaxX;\r\n                tMaxX += tDeltaX;\r\n                currentX += stepX;\r\n            } else {\r\n                tCurrent = tMaxZ;\r\n                tMaxZ += tDeltaZ;\r\n                currentZ += stepZ;\r\n            }\r\n            \r\n            iterations++;\r\n        }\r\n        \r\n        return out;\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\SoundManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":524,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":524,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { SoundConfig } from './GameConfig';\r\nimport { invoke } from '@tauri-apps/api/core';\r\n\r\nexport class SoundManager {\r\n    private static instance: SoundManager;\r\n    private audioContext: AudioContext;\r\n    private masterGain: GainNode;\r\n    \r\n    // 天气音效\r\n    private weatherGain: GainNode | null = null;\r\n    private weatherNodes: (OscillatorNode | AudioBufferSourceNode)[] = [];\r\n    private currentWeatherSound: string | null = null;\r\n    private weatherCleanupId: number = 0;  // 用于标识清理操作\r\n    \r\n    // 背景音乐系统\r\n    private bgmGain: GainNode;\r\n    private currentBGMState: 'none' | 'sunny' | 'rainy' | 'combat' = 'none';\r\n    private bgmBuffers: Map<string, AudioBuffer> = new Map();\r\n    private activeBgmSource: AudioBufferSourceNode | null = null;\r\n    private activeBgmGain: GainNode | null = null;\r\n\r\n    // Weapon shoot sound: keep nodes alive to avoid per-shot allocations.\r\n    private shootOsc: OscillatorNode | null = null;\r\n    private shootGain: GainNode | null = null;\r\n\r\n    private constructor() {\r\n        this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\r\n        this.masterGain = this.audioContext.createGain();\r\n        this.masterGain.gain.value = SoundConfig.masterVolume;\r\n        this.masterGain.connect(this.audioContext.destination);\r\n        \r\n        // 独立的 BGM 音量控制\r\n        this.bgmGain = this.audioContext.createGain();\r\n        this.bgmGain.gain.value = SoundConfig.bgmVolume;\r\n        this.bgmGain.connect(this.masterGain);\r\n\r\n        this.loadBgmAssets();\r\n    }\r\n\r\n    private async loadBgmAssets() {\r\n        const loadBuffer = async (filename: string, key: string) => {\r\n            try {\r\n                console.log(`Loading BGM from Rust: ${filename}`);\r\n                // Call Rust command to get raw bytes\r\n                const data = await invoke<number[]>('load_audio_asset', { filename });\r\n                \r\n                // Convert number[] (Vec<u8>) to Uint8Array/ArrayBuffer\r\n                const arrayBuffer = Uint8Array.from(data).buffer;\r\n                \r\n                // Decode audio data\r\n                const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);\r\n                this.bgmBuffers.set(key, audioBuffer);\r\n                console.log(`Loaded BGM: ${key}`);\r\n\r\n                // Check if this BGM should be playing now but was waiting for asset\r\n                if (this.currentBGMState === key && !this.activeBgmSource) {\r\n                    console.log(`BGM asset ${key} ready, starting delayed playback.`);\r\n                    this.startBGM(key);\r\n                }\r\n            } catch (error) {\r\n                console.error(`Failed to load BGM ${key} via Rust:`, error);\r\n            }\r\n        };\r\n\r\n        // Avoid decoding multiple MP3s concurrently: it can cause a short CPU spike.\r\n        // Prefer doing this work during idle time, and stagger the tracks.\r\n        const scheduleIdle = (fn: () => void, timeoutMs: number) => {\r\n            const ric = (window as any).requestIdleCallback as undefined | ((cb: () => void, opts?: { timeout: number }) => number);\r\n            if (ric) {\r\n                ric(fn, { timeout: timeoutMs });\r\n                return;\r\n            }\r\n            window.setTimeout(fn, Math.min(timeoutMs, 2500));\r\n        };\r\n\r\n        scheduleIdle(() => { void loadBuffer('sunny.mp3', 'sunny'); }, 2500);\r\n        window.setTimeout(() => scheduleIdle(() => { void loadBuffer('rainy.mp3', 'rainy'); }, 2500), 2000);\r\n        window.setTimeout(() => scheduleIdle(() => { void loadBuffer('combat.mp3', 'combat'); }, 2500), 4500);\r\n    }\r\n\r\n    public static getInstance(): SoundManager {\r\n        if (!SoundManager.instance) {\r\n            SoundManager.instance = new SoundManager();\r\n        }\r\n        return SoundManager.instance;\r\n    }\r\n\r\n    /**\r\n     * 设置背景音乐状态\r\n     */\r\n    public setBGMState(state: 'sunny' | 'rainy' | 'combat' | 'none') {\r\n        if (this.currentBGMState === state) return;\r\n        \r\n        console.log(`BGM State Switch: ${this.currentBGMState} -> ${state}`);\r\n\r\n        // Fade out current BGM\r\n        if (this.activeBgmGain) {\r\n            const oldGain = this.activeBgmGain;\r\n            const oldSource = this.activeBgmSource;\r\n            const now = this.audioContext.currentTime;\r\n            \r\n            try {\r\n                oldGain.gain.cancelScheduledValues(now);\r\n                oldGain.gain.setValueAtTime(oldGain.gain.value, now);\r\n                oldGain.gain.linearRampToValueAtTime(0, now + (SoundConfig.bgm.fadeDuration));\r\n                \r\n                if (oldSource) {\r\n                    oldSource.stop(now + (SoundConfig.bgm.fadeDuration) + 0.1);\r\n                }\r\n            } catch(e) { console.warn(\"Error stopping old BGM\", e); }\r\n        }\r\n\r\n        this.currentBGMState = state;\r\n        \r\n        if (state !== 'none') {\r\n             this.startBGM(state);\r\n        } else {\r\n             this.activeBgmSource = null;\r\n             this.activeBgmGain = null;\r\n        }\r\n    }\r\n\r\n    private startBGM(key: string) {\r\n        if (this.audioContext.state === 'suspended') {\r\n            this.resume();\r\n        }\r\n\r\n        const buffer = this.bgmBuffers.get(key);\r\n        if (!buffer) {\r\n            console.warn(`BGM asset '${key}' not ready yet.`);\r\n            return;\r\n        }\r\n\r\n        try {\r\n            const source = this.audioContext.createBufferSource();\r\n            source.buffer = buffer;\r\n            source.loop = true;\r\n\r\n            const gain = this.audioContext.createGain();\r\n            \r\n            // Determine target volume based on BGM type\r\n            let targetVolume = 1.0;\r\n            if (key === 'sunny') targetVolume = SoundConfig.bgm.sunnyVolume || 0.8;\r\n            if (key === 'rainy') targetVolume = SoundConfig.bgm.rainyVolume || 0.8;\r\n            if (key === 'combat') targetVolume = SoundConfig.bgm.combatVolume || 0.8;\r\n            \r\n            source.connect(gain);\r\n            gain.connect(this.bgmGain); \r\n\r\n            const now = this.audioContext.currentTime;\r\n            gain.gain.setValueAtTime(0, now);\r\n            gain.gain.linearRampToValueAtTime(targetVolume, now + (SoundConfig.bgm.fadeDuration));\r\n            \r\n            source.start(now);\r\n            \r\n            this.activeBgmSource = source;\r\n            this.activeBgmGain = gain;\r\n        } catch (e) {\r\n            console.error(\"Failed to start BGM\", e);\r\n        }\r\n    }\r\n\r\n    // Ensure AudioContext is resumed (browsers block auto-play)\r\n    public async resume() {\r\n        if (this.audioContext.state === 'suspended') {\r\n            await this.audioContext.resume();\r\n            \r\n            // 如果恢复成功，且当前有 BGM 状态，重启 BGM 以便立即听到声音\r\n            // 否则可能会因为 'suspended' check 跳过初始播放，导致长达数秒的静音\r\n            // 使用 type assertion 绕过 TS 的静态分析 (因为 await 改变了状态)\r\n            if ((this.audioContext.state as AudioContextState) === 'running' && this.currentBGMState !== 'none') {\r\n                const savedState = this.currentBGMState;\r\n                this.currentBGMState = 'none'; // 强制状态重置\r\n                this.setBGMState(savedState);\r\n            }\r\n        }\r\n\r\n        // Create persistent weapon sound nodes once we have a running context.\r\n        if ((this.audioContext.state as AudioContextState) === 'running') {\r\n            this.ensureShootNodes();\r\n        }\r\n    }\r\n\r\n    private ensureShootNodes() {\r\n        if (this.shootOsc && this.shootGain) return;\r\n        try {\r\n            const osc = this.audioContext.createOscillator();\r\n            const gain = this.audioContext.createGain();\r\n            osc.type = 'square';\r\n            // Keep it silent until fired.\r\n            gain.gain.setValueAtTime(0, this.audioContext.currentTime);\r\n            osc.connect(gain);\r\n            gain.connect(this.masterGain);\r\n            osc.start();\r\n\r\n            this.shootOsc = osc;\r\n            this.shootGain = gain;\r\n        } catch (e) {\r\n            console.warn('Failed to init shoot nodes', e);\r\n            this.shootOsc = null;\r\n            this.shootGain = null;\r\n        }\r\n    }\r\n\r\n    private playTone(freq: number, type: OscillatorType, duration: number, startTime: number = 0, vol: number = 1) {\r\n        const osc = this.audioContext.createOscillator();\r\n        const gain = this.audioContext.createGain();\r\n\r\n        osc.type = type;\r\n        osc.frequency.setValueAtTime(freq, this.audioContext.currentTime + startTime);\r\n\r\n        gain.gain.setValueAtTime(vol, this.audioContext.currentTime + startTime);\r\n        gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + startTime + duration);\r\n\r\n        osc.connect(gain);\r\n        gain.connect(this.masterGain);\r\n\r\n        osc.start(this.audioContext.currentTime + startTime);\r\n        osc.stop(this.audioContext.currentTime + startTime + duration);\r\n    }\r\n\r\n    private lastShootTime: number = 0;\r\n    private readonly SHOOT_THROTTLE: number = SoundConfig.weapon.shoot.throttle; // ms\r\n\r\n    public playShoot() {\r\n        const now = Date.now();\r\n        if (now - this.lastShootTime < this.SHOOT_THROTTLE) {\r\n            return;\r\n        }\r\n        this.lastShootTime = now;\r\n\r\n        void this.resume();\r\n        this.ensureShootNodes();\r\n\r\n        const osc = this.shootOsc;\r\n        const gain = this.shootGain;\r\n        if (!osc || !gain) return;\r\n\r\n        const t = this.audioContext.currentTime;\r\n        try {\r\n            // Reset envelope\r\n            gain.gain.cancelScheduledValues(t);\r\n            gain.gain.setValueAtTime(0.0001, t);\r\n\r\n            // Frequency sweep (pew)\r\n            osc.frequency.cancelScheduledValues(t);\r\n            osc.frequency.setValueAtTime(800, t);\r\n            osc.frequency.exponentialRampToValueAtTime(100, t + 0.1);\r\n\r\n            // Gain envelope\r\n            gain.gain.setValueAtTime(SoundConfig.weapon.shoot.volume, t);\r\n            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);\r\n            gain.gain.setValueAtTime(0.0001, t + 0.12);\r\n        } catch (e) {\r\n            // If scheduling fails for any reason, fall back silently.\r\n            console.warn('playShoot scheduling failed', e);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * 播放狙击枪射击声 - 更有震慑力\r\n     */\r\n    public playSniperShoot() {\r\n        this.resume();\r\n        \r\n        // 主爆发音 - 极其低沉有力\r\n        const osc1 = this.audioContext.createOscillator();\r\n        const gain1 = this.audioContext.createGain();\r\n        osc1.type = 'sawtooth';\r\n        osc1.frequency.setValueAtTime(120, this.audioContext.currentTime);\r\n        osc1.frequency.exponentialRampToValueAtTime(25, this.audioContext.currentTime + 0.5);\r\n        gain1.gain.setValueAtTime(1.5, this.audioContext.currentTime);\r\n        gain1.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);\r\n        osc1.connect(gain1);\r\n        gain1.connect(this.masterGain);\r\n        osc1.start();\r\n        osc1.stop(this.audioContext.currentTime + 0.5);\r\n        \r\n        // 高频冲击音 - 尖锐的枪击声\r\n        const osc2 = this.audioContext.createOscillator();\r\n        const gain2 = this.audioContext.createGain();\r\n        osc2.type = 'square';\r\n        osc2.frequency.setValueAtTime(1500, this.audioContext.currentTime);\r\n        osc2.frequency.exponentialRampToValueAtTime(150, this.audioContext.currentTime + 0.12);\r\n        gain2.gain.setValueAtTime(1.2, this.audioContext.currentTime);\r\n        gain2.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.12);\r\n        osc2.connect(gain2);\r\n        gain2.connect(this.masterGain);\r\n        osc2.start();\r\n        osc2.stop(this.audioContext.currentTime + 0.12);\r\n        \r\n        // 超低频震撼 - 身体能感受到的低音\r\n        const osc3 = this.audioContext.createOscillator();\r\n        const gain3 = this.audioContext.createGain();\r\n        osc3.type = 'sine';\r\n        osc3.frequency.setValueAtTime(45, this.audioContext.currentTime);\r\n        osc3.frequency.exponentialRampToValueAtTime(20, this.audioContext.currentTime + 0.7);\r\n        gain3.gain.setValueAtTime(1.5, this.audioContext.currentTime);\r\n        gain3.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.7);\r\n        osc3.connect(gain3);\r\n        gain3.connect(this.masterGain);\r\n        osc3.start();\r\n        osc3.stop(this.audioContext.currentTime + 0.7);\r\n        \r\n        // 中频爆破音\r\n        const osc4 = this.audioContext.createOscillator();\r\n        const gain4 = this.audioContext.createGain();\r\n        osc4.type = 'sawtooth';\r\n        osc4.frequency.setValueAtTime(300, this.audioContext.currentTime);\r\n        osc4.frequency.exponentialRampToValueAtTime(80, this.audioContext.currentTime + 0.25);\r\n        gain4.gain.setValueAtTime(1.0, this.audioContext.currentTime);\r\n        gain4.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.25);\r\n        osc4.connect(gain4);\r\n        gain4.connect(this.masterGain);\r\n        osc4.start();\r\n        osc4.stop(this.audioContext.currentTime + 0.25);\r\n        \r\n        // 回响余音 - 远处的回声\r\n        const osc5 = this.audioContext.createOscillator();\r\n        const gain5 = this.audioContext.createGain();\r\n        osc5.type = 'sine';\r\n        osc5.frequency.setValueAtTime(80, this.audioContext.currentTime + 0.08);\r\n        osc5.frequency.exponentialRampToValueAtTime(35, this.audioContext.currentTime + 1.0);\r\n        gain5.gain.setValueAtTime(0, this.audioContext.currentTime);\r\n        gain5.gain.linearRampToValueAtTime(0.6, this.audioContext.currentTime + 0.08);\r\n        gain5.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 1.0);\r\n        osc5.connect(gain5);\r\n        gain5.connect(this.masterGain);\r\n        osc5.start();\r\n        osc5.stop(this.audioContext.currentTime + 1.0);\r\n        \r\n        // 噪声层 - 模拟爆炸气流\r\n        const bufferSize = this.audioContext.sampleRate * 0.3;\r\n        const noiseBuffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);\r\n        const output = noiseBuffer.getChannelData(0);\r\n        for (let i = 0; i < bufferSize; i++) {\r\n            output[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);\r\n        }\r\n        const noise = this.audioContext.createBufferSource();\r\n        noise.buffer = noiseBuffer;\r\n        const noiseGain = this.audioContext.createGain();\r\n        noiseGain.gain.setValueAtTime(0.8, this.audioContext.currentTime);\r\n        noiseGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);\r\n        const noiseFilter = this.audioContext.createBiquadFilter();\r\n        noiseFilter.type = 'lowpass';\r\n        noiseFilter.frequency.value = 2000;\r\n        noise.connect(noiseFilter);\r\n        noiseFilter.connect(noiseGain);\r\n        noiseGain.connect(this.masterGain);\r\n        noise.start();\r\n    }\r\n\r\n    public playHit() {\r\n        this.resume();\r\n        // Short high pitch ping\r\n        this.playTone(1200, 'sine', 0.05, 0, 0.5);\r\n    }\r\n\r\n    public playJump() {\r\n        this.resume();\r\n        // Rising pitch\r\n        const osc = this.audioContext.createOscillator();\r\n        const gain = this.audioContext.createGain();\r\n\r\n        osc.type = 'sine';\r\n        osc.frequency.setValueAtTime(200, this.audioContext.currentTime);\r\n        osc.frequency.linearRampToValueAtTime(400, this.audioContext.currentTime + 0.2);\r\n\r\n        gain.gain.setValueAtTime(0.5, this.audioContext.currentTime);\r\n        gain.gain.linearRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);\r\n\r\n        osc.connect(gain);\r\n        gain.connect(this.masterGain);\r\n\r\n        osc.start();\r\n        osc.stop(this.audioContext.currentTime + 0.2);\r\n    }\r\n\r\n    public playEnemyDeath() {\r\n        this.resume();\r\n        // Explosion-ish noise (simulated with low freq saw/square)\r\n        this.playTone(100, 'sawtooth', 0.3, 0, 0.8);\r\n        this.playTone(80, 'square', 0.3, 0.05, 0.8);\r\n    }\r\n\r\n    public playDamage() {\r\n        this.resume();\r\n        // Low thud\r\n        this.playTone(150, 'sawtooth', 0.1, 0, 0.8);\r\n    }\r\n\r\n    public playPickup() {\r\n        this.resume();\r\n        // High happy chime\r\n        this.playTone(1000, 'sine', 0.1, 0, 0.3);\r\n        this.playTone(1500, 'sine', 0.2, 0.05, 0.3);\r\n    }\r\n    \r\n    public playHitImpact() {\r\n        this.resume();\r\n        // Short impact sound\r\n        this.playTone(200, 'square', 0.05, 0, 0.3);\r\n    }\r\n    \r\n    public playExplosion() {\r\n        this.resume();\r\n        // Explosion sound - layered low frequency rumble\r\n        \r\n        // Main boom\r\n        const osc1 = this.audioContext.createOscillator();\r\n        const gain1 = this.audioContext.createGain();\r\n        osc1.type = 'sawtooth';\r\n        osc1.frequency.setValueAtTime(100, this.audioContext.currentTime);\r\n        osc1.frequency.exponentialRampToValueAtTime(30, this.audioContext.currentTime + 0.5);\r\n        gain1.gain.setValueAtTime(1.0, this.audioContext.currentTime);\r\n        gain1.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);\r\n        osc1.connect(gain1);\r\n        gain1.connect(this.masterGain);\r\n        osc1.start();\r\n        osc1.stop(this.audioContext.currentTime + 0.5);\r\n        \r\n        // Secondary crack\r\n        const osc2 = this.audioContext.createOscillator();\r\n        const gain2 = this.audioContext.createGain();\r\n        osc2.type = 'square';\r\n        osc2.frequency.setValueAtTime(200, this.audioContext.currentTime);\r\n        osc2.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.3);\r\n        gain2.gain.setValueAtTime(0.8, this.audioContext.currentTime);\r\n        gain2.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);\r\n        osc2.connect(gain2);\r\n        gain2.connect(this.masterGain);\r\n        osc2.start();\r\n        osc2.stop(this.audioContext.currentTime + 0.3);\r\n        \r\n        // High frequency crack\r\n        this.playTone(800, 'sawtooth', 0.08, 0, 0.5);\r\n        this.playTone(400, 'square', 0.15, 0.02, 0.4);\r\n    }\r\n    \r\n    public playWeaponSwitch() {\r\n        this.resume();\r\n        // Click sound for weapon switch\r\n        this.playTone(600, 'sine', 0.03, 0, 0.2);\r\n        this.playTone(800, 'sine', 0.03, 0.02, 0.2);\r\n    }\r\n    \r\n    public playGrenadeThrow() {\r\n        this.resume();\r\n        // Whoosh sound\r\n        const osc = this.audioContext.createOscillator();\r\n        const gain = this.audioContext.createGain();\r\n        \r\n        osc.type = 'sine';\r\n        osc.frequency.setValueAtTime(200, this.audioContext.currentTime);\r\n        osc.frequency.linearRampToValueAtTime(100, this.audioContext.currentTime + 0.2);\r\n        \r\n        gain.gain.setValueAtTime(0.3, this.audioContext.currentTime);\r\n        gain.gain.linearRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);\r\n        \r\n        osc.connect(gain);\r\n        gain.connect(this.masterGain);\r\n        \r\n        osc.start();\r\n        osc.stop(this.audioContext.currentTime + 0.2);\r\n    }\r\n    \r\n    /**\r\n     * 播放天气环境音效\r\n     */\r\n    public playWeatherSound(weather: 'sunny' | 'rainy' | 'windy' | 'sandstorm') {\r\n        this.resume();\r\n        \r\n        // 如果是同一个天气音效，不重复播放\r\n        if (this.currentWeatherSound === weather) return;\r\n        \r\n        // 停止当前天气音效\r\n        this.stopWeatherSound();\r\n        \r\n        this.currentWeatherSound = weather;\r\n        \r\n        // 晴天没有特殊音效\r\n        if (weather === 'sunny') return;\r\n        \r\n        // 创建天气音效增益节点\r\n        this.weatherGain = this.audioContext.createGain();\r\n        this.weatherGain.gain.setValueAtTime(0, this.audioContext.currentTime);\r\n        this.weatherGain.gain.linearRampToValueAtTime(0.5, this.audioContext.currentTime + 1);\r\n        this.weatherGain.connect(this.masterGain);\r\n        \r\n        if (weather === 'rainy') {\r\n            this.createRainSound();\r\n        } else if (weather === 'windy') {\r\n            this.createWindSound();\r\n        } else if (weather === 'sandstorm') {\r\n            this.createSandstormSound();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * 停止天气音效\r\n     */\r\n    public stopWeatherSound() {\r\n        this.currentWeatherSound = null;  // 立即设置，阻止新的循环音效\r\n        \r\n        // 保存当前要清理的节点引用\r\n        const nodesToClean = [...this.weatherNodes];\r\n        const gainToClean = this.weatherGain;\r\n        \r\n        // 清空当前数组，为新音效腾出空间\r\n        this.weatherNodes = [];\r\n        this.weatherGain = null;\r\n        \r\n        if (gainToClean) {\r\n            // 渐出\r\n            gainToClean.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 1);\r\n        }\r\n        \r\n        // 延迟停止旧节点\r\n        setTimeout(() => {\r\n            for (const node of nodesToClean) {\r\n                try {\r\n                    node.stop();\r\n                    node.disconnect();\r\n                } catch (e) {\r\n                    // 忽略已停止的节点\r\n                }\r\n            }\r\n            if (gainToClean) {\r\n                gainToClean.disconnect();\r\n            }\r\n        }, 1100);\r\n    }\r\n    \r\n    /**\r\n     * 创建雨声 - 使用白噪声模拟\r\n     */\r\n    private createRainSound() {\r\n        if (!this.weatherGain) return;\r\n        \r\n        // 创建白噪声缓冲区\r\n        const bufferSize = 2 * this.audioContext.sampleRate;\r\n        const noiseBuffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);\r\n        const output = noiseBuffer.getChannelData(0);\r\n        \r\n        for (let i = 0; i < bufferSize; i++) {\r\n            output[i] = Math.random() * 2 - 1;\r\n        }\r\n        \r\n        // 创建噪声源\r\n        const whiteNoise = this.audioContext.createBufferSource();\r\n        whiteNoise.buffer = noiseBuffer;\r\n        whiteNoise.loop = true;\r\n        \r\n        // 滤波器 - 让雨声更自然\r\n        const lowpass = this.audioContext.createBiquadFilter();\r\n        lowpass.type = 'lowpass';\r\n        lowpass.frequency.value = 3000;\r\n        \r\n        const highpass = this.audioContext.createBiquadFilter();\r\n        highpass.type = 'highpass';\r\n        highpass.frequency.value = 500;\r\n        \r\n        // 连接节点\r\n        whiteNoise.connect(highpass);\r\n        highpass.connect(lowpass);\r\n        lowpass.connect(this.weatherGain);\r\n        \r\n        whiteNoise.start();\r\n        this.weatherNodes.push(whiteNoise);\r\n        \r\n        // 添加雨滴滴答声\r\n        this.addRainDrops();\r\n    }\r\n    \r\n    /**\r\n     * 添加雨滴滴答声效果\r\n     */\r\n    private addRainDrops() {\r\n        if (!this.weatherGain || this.currentWeatherSound !== 'rainy') return;\r\n        \r\n        // 随机播放更多雨滴声\r\n        const dropCount = 5 + Math.floor(Math.random() * 5);\r\n        for (let i = 0; i < dropCount; i++) {\r\n            setTimeout(() => {\r\n                if (!this.weatherGain || this.currentWeatherSound !== 'rainy') return;\r\n                \r\n                const osc = this.audioContext.createOscillator();\r\n                const gain = this.audioContext.createGain();\r\n                \r\n                osc.type = 'sine';\r\n                const freq = 1500 + Math.random() * 3000;\r\n                osc.frequency.setValueAtTime(freq, this.audioContext.currentTime);\r\n                osc.frequency.exponentialRampToValueAtTime(freq * 0.3, this.audioContext.currentTime + 0.08);\r\n                \r\n                gain.gain.setValueAtTime(0.08, this.audioContext.currentTime);\r\n                gain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.08);\r\n                \r\n                osc.connect(gain);\r\n                gain.connect(this.weatherGain!);\r\n                \r\n                osc.start();\r\n                osc.stop(this.audioContext.currentTime + 0.08);\r\n            }, Math.random() * 300);\r\n        }\r\n        \r\n        // 更频繁地循环播放雨滴声\r\n        setTimeout(() => this.addRainDrops(), 100 + Math.random() * 200);\r\n    }\r\n    \r\n    /**\r\n     * 创建风声\r\n     */\r\n    private createWindSound() {\r\n        if (!this.weatherGain) return;\r\n        \r\n        // 使用低频振荡器调制噪声来模拟风声\r\n        const bufferSize = 2 * this.audioContext.sampleRate;\r\n        const noiseBuffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);\r\n        const output = noiseBuffer.getChannelData(0);\r\n        \r\n        for (let i = 0; i < bufferSize; i++) {\r\n            output[i] = Math.random() * 2 - 1;\r\n        }\r\n        \r\n        const whiteNoise = this.audioContext.createBufferSource();\r\n        whiteNoise.buffer = noiseBuffer;\r\n        whiteNoise.loop = true;\r\n        \r\n        // 带通滤波器让风声更自然\r\n        const bandpass = this.audioContext.createBiquadFilter();\r\n        bandpass.type = 'bandpass';\r\n        bandpass.frequency.value = 400;\r\n        bandpass.Q.value = 0.5;\r\n        \r\n        // LFO 调制音量模拟阵风 - 更强烈\r\n        const lfo = this.audioContext.createOscillator();\r\n        const lfoGain = this.audioContext.createGain();\r\n        lfo.type = 'sine';\r\n        lfo.frequency.value = 0.4; // 更快的阵风\r\n        lfoGain.gain.value = 0.5;\r\n        \r\n        const modulatedGain = this.audioContext.createGain();\r\n        modulatedGain.gain.value = 1.2;\r\n        \r\n        lfo.connect(lfoGain);\r\n        lfoGain.connect(modulatedGain.gain);\r\n        \r\n        whiteNoise.connect(bandpass);\r\n        bandpass.connect(modulatedGain);\r\n        modulatedGain.connect(this.weatherGain);\r\n        \r\n        whiteNoise.start();\r\n        lfo.start();\r\n        \r\n        this.weatherNodes.push(whiteNoise, lfo);\r\n        \r\n        // 添加呼啸声\r\n        this.addWindWhistle();\r\n    }\r\n    \r\n    /**\r\n     * 添加风的呼啸声\r\n     */\r\n    private addWindWhistle() {\r\n        if (!this.weatherGain || this.currentWeatherSound !== 'windy') return;\r\n        \r\n        const osc = this.audioContext.createOscillator();\r\n        const gain = this.audioContext.createGain();\r\n        \r\n        osc.type = 'sine';\r\n        const baseFreq = 250 + Math.random() * 300;\r\n        osc.frequency.setValueAtTime(baseFreq, this.audioContext.currentTime);\r\n        osc.frequency.linearRampToValueAtTime(baseFreq * 2.0, this.audioContext.currentTime + 0.8);\r\n        osc.frequency.linearRampToValueAtTime(baseFreq * 0.5, this.audioContext.currentTime + 1.8);\r\n        \r\n        gain.gain.setValueAtTime(0, this.audioContext.currentTime);\r\n        gain.gain.linearRampToValueAtTime(0.12, this.audioContext.currentTime + 0.3);\r\n        gain.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 1.8);\r\n        \r\n        osc.connect(gain);\r\n        gain.connect(this.weatherGain!);\r\n        \r\n        osc.start();\r\n        osc.stop(this.audioContext.currentTime + 1.8);\r\n        \r\n        // 更频繁地添加呼啸声\r\n        setTimeout(() => this.addWindWhistle(), 800 + Math.random() * 1500);\r\n    }\r\n    \r\n    /**\r\n     * 创建沙尘暴声音\r\n     */\r\n    private createSandstormSound() {\r\n        if (!this.weatherGain) return;\r\n        \r\n        // 沙尘暴 = 强风 + 沙粒摩擦声\r\n        const bufferSize = 2 * this.audioContext.sampleRate;\r\n        const noiseBuffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);\r\n        const output = noiseBuffer.getChannelData(0);\r\n        \r\n        // 更粗糙的噪声模拟沙粒\r\n        for (let i = 0; i < bufferSize; i++) {\r\n            output[i] = (Math.random() * 2 - 1) * (0.5 + Math.random() * 0.5);\r\n        }\r\n        \r\n        const whiteNoise = this.audioContext.createBufferSource();\r\n        whiteNoise.buffer = noiseBuffer;\r\n        whiteNoise.loop = true;\r\n        \r\n        // 滤波器\r\n        const lowpass = this.audioContext.createBiquadFilter();\r\n        lowpass.type = 'lowpass';\r\n        lowpass.frequency.value = 2000;\r\n        \r\n        const highpass = this.audioContext.createBiquadFilter();\r\n        highpass.type = 'highpass';\r\n        highpass.frequency.value = 200;\r\n        \r\n        // 更强烈的 LFO 调制\r\n        const lfo = this.audioContext.createOscillator();\r\n        const lfoGain = this.audioContext.createGain();\r\n        lfo.type = 'triangle';\r\n        lfo.frequency.value = 0.5;\r\n        lfoGain.gain.value = 0.6;\r\n        \r\n        const modulatedGain = this.audioContext.createGain();\r\n        modulatedGain.gain.value = 1.5;\r\n        \r\n        lfo.connect(lfoGain);\r\n        lfoGain.connect(modulatedGain.gain);\r\n        \r\n        whiteNoise.connect(highpass);\r\n        highpass.connect(lowpass);\r\n        lowpass.connect(modulatedGain);\r\n        modulatedGain.connect(this.weatherGain);\r\n        \r\n        whiteNoise.start();\r\n        lfo.start();\r\n        \r\n        this.weatherNodes.push(whiteNoise, lfo);\r\n        \r\n        // 添加低频隆隆声\r\n        this.addSandRumble();\r\n    }\r\n    \r\n    /**\r\n     * 添加沙尘暴的低频隆隆声\r\n     */\r\n    private addSandRumble() {\r\n        if (!this.weatherGain || this.currentWeatherSound !== 'sandstorm') return;\r\n        \r\n        const osc = this.audioContext.createOscillator();\r\n        const gain = this.audioContext.createGain();\r\n        \r\n        osc.type = 'sawtooth';\r\n        osc.frequency.setValueAtTime(40 + Math.random() * 40, this.audioContext.currentTime);\r\n        \r\n        gain.gain.setValueAtTime(0, this.audioContext.currentTime);\r\n        gain.gain.linearRampToValueAtTime(0.2, this.audioContext.currentTime + 0.3);\r\n        gain.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 1.2);\r\n        \r\n        osc.connect(gain);\r\n        gain.connect(this.weatherGain!);\r\n        \r\n        osc.start();\r\n        osc.stop(this.audioContext.currentTime + 1.2);\r\n        \r\n        // 更频繁的隆隆声\r\n        setTimeout(() => this.addSandRumble(), 600 + Math.random() * 1000);\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\composition\\GameplayComposition.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\composition\\GpuSystemsFactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\composition\\PlayerFactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\composition\\RenderCompositionFactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\composition\\SystemGraphFactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\engine\\FrameContextBuilder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\engine\\System.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\engine\\SystemManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\events\\DefaultGameEventHandlers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\events\\GameEventBus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\events\\GameEvents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\gpu\\GpuSimulationFacade.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\init\\GameInitSteps.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\init\\InitConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\init\\InitPipeline.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\init\\LoadedGate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\perf\\FpsCounter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\perf\\HitchProfiler.ts","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-explicit-any').","line":74,"column":9,"severity":1,"nodeType":null,"fix":{"range":[2208,2270],"text":" "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import * as THREE from \"three\";\r\n\r\nimport { readBooleanFlag, readNumber } from \"../runtime/RuntimeToggles\";\r\n\r\nexport type HitchProfilerSettings = {\r\n    enabled: boolean;\r\n    thresholdMs: number;\r\n    logBudget: number;\r\n};\r\n\r\nexport function resolveHitchProfilerSettings(): HitchProfilerSettings {\r\n    // Enable by default outside production.\r\n    // In some runtimes `import.meta.env.DEV` may be missing/falsey; `PROD` is more reliable.\r\n    const env = (import.meta as any)?.env;\r\n    const isProd = Boolean(env?.PROD);\r\n    const isDev = !isProd;\r\n\r\n    const hitchEnabledOverride = readBooleanFlag(\"hitch\");\r\n    const hitchThresholdOverride = readNumber(\"hitchMs\");\r\n\r\n    const disabled = hitchEnabledOverride === false;\r\n    const forced = hitchEnabledOverride === true;\r\n\r\n    const thresholdMs =\r\n        hitchThresholdOverride !== null && hitchThresholdOverride > 0\r\n            ? hitchThresholdOverride\r\n            : 24; // ~1.5 frames at 60fps\r\n\r\n    return {\r\n        enabled: (isDev || forced) && !disabled,\r\n        thresholdMs,\r\n        logBudget: 50,\r\n    };\r\n}\r\n\r\nexport class HitchProfiler {\r\n    private enabled: boolean;\r\n    private thresholdMs: number;\r\n    private logBudget: number;\r\n    private bannerLogged: boolean = false;\r\n\r\n    constructor(settings: HitchProfilerSettings) {\r\n        this.enabled = settings.enabled;\r\n        this.thresholdMs = settings.thresholdMs;\r\n        this.logBudget = settings.logBudget;\r\n    }\r\n\r\n    public isEnabled(): boolean {\r\n        return this.enabled;\r\n    }\r\n\r\n    public getThresholdMs(): number {\r\n        return this.thresholdMs;\r\n    }\r\n\r\n    public beginFrame(): number {\r\n        if (!this.enabled) return 0;\r\n\r\n        if (!this.bannerLogged) {\r\n            this.bannerLogged = true;\r\n            console.log(\r\n                `[HITCH] profiler enabled (threshold ${this.thresholdMs}ms). ` +\r\n                    `Force enable: add ?hitch=1, adjust: ?hitchMs=12, or run localStorage.setItem('hitch','1').`\r\n            );\r\n        }\r\n\r\n        return performance.now();\r\n    }\r\n\r\n    public recordFrame(params: {\r\n        frameStartMs: number;\r\n        rawDeltaSeconds: number;\r\n        camera: THREE.PerspectiveCamera;\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        renderer: any;\r\n        systemTimings: Record<string, number>;\r\n        enemies: {\r\n            all: ReadonlyArray<{\r\n                isDead: boolean;\r\n                mesh: THREE.Object3D;\r\n                isRenderCulled?: () => boolean;\r\n            }>;\r\n        };\r\n        pickups: { all: ReadonlyArray<unknown> };\r\n        grenades: { activeCount: number };\r\n    }): void {\r\n        if (!this.enabled || this.logBudget <= 0) return;\r\n\r\n        const frameTotalMs = performance.now() - params.frameStartMs;\r\n        if (frameTotalMs < this.thresholdMs) return;\r\n\r\n        this.logBudget--;\r\n\r\n        const t = (name: string) => params.systemTimings[name] ?? 0;\r\n\r\n        let visibleEnemies = 0;\r\n        for (const e of params.enemies.all) {\r\n            if (!e.isDead && e.mesh.visible) visibleEnemies++;\r\n        }\r\n\r\n        // Frustum stats: if hitch correlates with enemies entering the frustum, it's likely render-side.\r\n        const frustum = new THREE.Frustum();\r\n        const projView = new THREE.Matrix4();\r\n        projView.multiplyMatrices(params.camera.projectionMatrix, params.camera.matrixWorldInverse);\r\n        frustum.setFromProjectionMatrix(projView);\r\n\r\n        let enemiesInFrustum = 0;\r\n        let renderCulledEnemies = 0;\r\n        for (const e of params.enemies.all) {\r\n            if (e.isDead) continue;\r\n            if (typeof e.isRenderCulled === \"function\" && e.isRenderCulled()) {\r\n                renderCulledEnemies++;\r\n                continue;\r\n            }\r\n            // Cheap point test; good enough to correlate facing-direction spikes.\r\n            if (frustum.containsPoint(e.mesh.position)) enemiesInFrustum++;\r\n        }\r\n\r\n        // Renderer stats (WebGPU/three): calls/triangles rise sharply when many enemies are visible.\r\n        const info = params.renderer?.info;\r\n        const calls = info?.render?.calls ?? 0;\r\n        const tris = info?.render?.triangles ?? 0;\r\n        const lines = info?.render?.lines ?? 0;\r\n        const points = info?.render?.points ?? 0;\r\n\r\n        const rawDeltaMs = params.rawDeltaSeconds * 1000;\r\n\r\n        console.log(\r\n            `[HITCH] ${frameTotalMs.toFixed(1)}ms (rawDelta ${rawDeltaMs.toFixed(1)}ms) ` +\r\n                `player ${t(\"player\").toFixed(1)} | uniforms ${t(\"uniforms\").toFixed(1)} | compute ${t(\"gpuCompute\").toFixed(1)} | ` +\r\n                `particles ${t(\"particles\").toFixed(1)} | weather ${t(\"weather\").toFixed(1)} | pickups ${t(\"pickups\").toFixed(1)} | ` +\r\n                `enemies ${t(\"enemies\").toFixed(1)} | trails ${t(\"trails\").toFixed(1)} | grenades ${t(\"grenades\").toFixed(1)} | ` +\r\n                `spawns ${t(\"spawns\").toFixed(1)} | audio ${t(\"audio\").toFixed(1)} | shadows ${t(\"shadows\").toFixed(1)} | render ${t(\"render\").toFixed(1)} ` +\r\n                `| enemies=${params.enemies.all.length} visibleEnemies=${visibleEnemies} frustumEnemies=${enemiesInFrustum} culledEnemies=${renderCulledEnemies} ` +\r\n                `calls=${calls} tris=${tris} lines=${lines} points=${points} ` +\r\n                `pickups=${params.pickups.all.length} grenades=${params.grenades.activeCount}`\r\n        );\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\render\\LightingSetup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\render\\PostFXPipeline.ts","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-explicit-any').","line":51,"column":1,"severity":1,"nodeType":null,"fix":{"range":[1421,1483],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-explicit-any').","line":72,"column":1,"severity":1,"nodeType":null,"fix":{"range":[2126,2188],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-explicit-any').","line":91,"column":1,"severity":1,"nodeType":null,"fix":{"range":[2731,2793],"text":" "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"import type * as THREE from 'three';\r\n// @ts-ignore - WebGPU types not fully available\r\nimport { PostProcessing } from 'three/webgpu';\r\n// @ts-ignore - WebGPU types not fully available\r\nimport type { WebGPURenderer } from 'three/webgpu';\r\nimport {\r\n    pass,\r\n    uniform,\r\n    time,\r\n    sin,\r\n    vec3,\r\n    vec4,\r\n    mix,\r\n    float,\r\n    smoothstep,\r\n    screenUV,\r\n} from 'three/tsl';\r\n\r\nimport type { UniformManager } from '../../shaders/TSLMaterials';\r\n\r\nexport type NumberUniform = { value: number };\r\n\r\nexport type PostFXPipeline = {\r\n    postProcessing: PostProcessing;\r\n    scopeAimProgress: NumberUniform;\r\n};\r\n\r\nexport function createPostFXPipeline(opts: {\r\n    renderer: WebGPURenderer;\r\n    scene: THREE.Scene;\r\n    camera: THREE.PerspectiveCamera;\r\n    uniforms: UniformManager;\r\n}): PostFXPipeline {\r\n    const pp = new PostProcessing(opts.renderer);\r\n\r\n    const scopeAimProgressNode = uniform(0);\r\n\r\n    // Scene render pass\r\n    const scenePass = pass(opts.scene, opts.camera);\r\n    const sceneColor = scenePass.getTextureNode('output');\r\n\r\n    const damageOverlay = createDamageOverlay(sceneColor, opts.uniforms);\r\n    const scopeOverlay = createScopeEffect(damageOverlay, scopeAimProgressNode);\r\n    const vignette = createVignetteEffect(scopeOverlay);\r\n\r\n    pp.outputNode = vignette;\r\n\r\n    return { postProcessing: pp, scopeAimProgress: scopeAimProgressNode as unknown as NumberUniform };\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction createDamageOverlay(inputColor: any, uniforms: UniformManager) {\r\n    const coord = screenUV;\r\n    const damageAmount = uniforms.damageFlash;\r\n\r\n    const damageColor = vec3(0.8, 0.1, 0.05);\r\n\r\n    const center = vec3(0.5, 0.5, 0);\r\n    const distFromCenter = coord.sub(center.xy).length();\r\n    const edgeFade = smoothstep(float(0.3), float(0.8), distFromCenter);\r\n\r\n    const t = time;\r\n    const pulse = sin(t.mul(15)).mul(0.2).add(0.8);\r\n\r\n    const damageStrength = damageAmount.mul(edgeFade).mul(pulse);\r\n\r\n    const finalColor = mix(inputColor, vec4(damageColor, 1), damageStrength.mul(0.5));\r\n\r\n    return finalColor;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction createVignetteEffect(inputColor: any) {\r\n    const coord = screenUV;\r\n\r\n    const center = vec3(0.5, 0.5, 0);\r\n    const dist = coord.sub(center.xy).length();\r\n\r\n    const vignetteStrength = float(0.4);\r\n    const vignetteRadius = float(0.8);\r\n    const vignetteSoftness = float(0.5);\r\n\r\n    const vignette = smoothstep(vignetteRadius, vignetteRadius.sub(vignetteSoftness), dist);\r\n\r\n    const darkening = mix(float(1), vignette, vignetteStrength);\r\n    const finalColor = inputColor.mul(darkening);\r\n\r\n    return finalColor;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction createScopeEffect(inputColor: any, scopeAimProgress: any) {\r\n    const coord = screenUV;\r\n\r\n    const aimProgress = scopeAimProgress;\r\n\r\n    const aspect = float(16.0 / 9.0);\r\n\r\n    const correctedCoord = vec3(coord.x.sub(0.5).mul(aspect), coord.y.sub(0.5), float(0));\r\n    const dist = correctedCoord.length();\r\n\r\n    const innerRadius = float(0.35);\r\n    const outerRadius = float(0.38);\r\n    const borderRadius = float(0.42);\r\n\r\n    const borderMask = smoothstep(innerRadius, outerRadius, dist);\r\n    const outerMask = smoothstep(outerRadius, borderRadius, dist);\r\n\r\n    const borderColor = vec3(0.08, 0.08, 0.1);\r\n\r\n    const crosshairThickness = float(0.002);\r\n    const crosshairLength = float(0.15);\r\n    const horizontalLine = smoothstep(crosshairThickness, float(0), correctedCoord.y.abs())\r\n        .mul(\r\n            smoothstep(\r\n                crosshairLength,\r\n                crosshairLength.sub(0.02),\r\n                correctedCoord.x.abs()\r\n            )\r\n        )\r\n        .mul(smoothstep(float(0.02), float(0.03), correctedCoord.x.abs()));\r\n\r\n    const verticalLine = smoothstep(crosshairThickness, float(0), correctedCoord.x.abs())\r\n        .mul(\r\n            smoothstep(\r\n                crosshairLength,\r\n                crosshairLength.sub(0.02),\r\n                correctedCoord.y.abs()\r\n            )\r\n        )\r\n        .mul(smoothstep(float(0.02), float(0.03), correctedCoord.y.abs()));\r\n\r\n    const crosshair = horizontalLine.add(verticalLine).clamp(0, 1);\r\n    const crosshairColor = vec3(0, 0, 0);\r\n\r\n    const dotRadius = float(0.008);\r\n    const redDot = smoothstep(dotRadius, dotRadius.mul(0.5), dist);\r\n    const redDotColor = vec3(1.0, 0.1, 0.05);\r\n\r\n    let result = inputColor;\r\n\r\n    result = mix(inputColor, vec4(borderColor, 1), borderMask.mul(aimProgress));\r\n    result = mix(result, vec4(0, 0, 0, 1), outerMask.mul(aimProgress));\r\n\r\n    const crosshairVisible = crosshair.mul(float(1).sub(borderMask)).mul(aimProgress);\r\n    result = mix(result, vec4(crosshairColor, 1), crosshairVisible.mul(0.8));\r\n\r\n    result = mix(result, vec4(redDotColor, 1), redDot.mul(aimProgress));\r\n\r\n    const edgeHighlight = smoothstep(innerRadius.sub(0.02), innerRadius, dist).mul(\r\n        smoothstep(outerRadius, innerRadius, dist)\r\n    );\r\n    const highlightColor = vec3(0.3, 0.4, 0.5);\r\n    result = mix(\r\n        result,\r\n        result.add(vec4(highlightColor.mul(0.1), 0)),\r\n        edgeHighlight.mul(aimProgress)\r\n    );\r\n\r\n    return result;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\render\\RendererFactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\render\\Resize.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\render\\SceneFactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\runtime\\GameRuntime.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\runtime\\RuntimeToggles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\services\\GameServices.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\settings\\RuntimeSettings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\settings\\RuntimeSettingsStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\warmup\\ShaderWarmupService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\core\\warmup\\WarmupConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\enemy\\Enemy.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'MeshStandardNodeMaterial' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'time' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sin' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cos' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'vec3' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'mix' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":41,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'float' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'smoothstep' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":53,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":63},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'uv' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":65,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":67},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-explicit-any').","line":186,"column":9,"severity":1,"nodeType":null,"fix":{"range":[7279,7341],"text":" "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":1,"source":"/**\r\n * Enemy - 使用 TSL 材质优化的敌人类\r\n * 结合 GPU Compute 进行高性能更新\r\n */\r\nimport * as THREE from 'three';\r\nimport { MeshStandardNodeMaterial } from 'three/webgpu';\r\nimport { uniform, time, sin, cos, vec3, mix, float, smoothstep, uv } from 'three/tsl';\r\nimport type { GameServices } from '../core/services/GameServices';\r\nimport { getDefaultGameServices } from '../core/services/GameServices';\r\nimport { Pathfinding } from '../core/Pathfinding';\r\nimport { EnemyConfig, EnemyType, EnemyTypesConfig } from '../core/GameConfig';\r\nimport { PhysicsSystem } from '../core/PhysicsSystem';\r\nimport { EnemyFactory } from './EnemyFactory';\r\nimport type { WeaponId } from '../weapon/WeaponTypes';\r\nimport { GameEventBus } from '../core/events/GameEventBus';\r\n\r\nexport class Enemy {\r\n    public mesh: THREE.Group;\r\n    public type: EnemyType;\r\n    private config: any; // 当前类型的配置\r\n\r\n    private speed: number;\r\n    private health: number;\r\n    public isDead: boolean = false;\r\n    public isActive: boolean = true;\r\n\r\n    private readonly services: GameServices;\r\n    private readonly events: GameEventBus;\r\n    \r\n    // TSL Uniforms (使用 any 类型绕过 WebGPU 类型问题)\r\n    private hitStrength: any;\r\n    private dissolveAmount: any;\r\n    \r\n    // Pathfinding\r\n    private currentPath: THREE.Vector3[] = [];\r\n    private pathUpdateTimer: number = 0;\r\n    private pathUpdateInterval: number = EnemyConfig.ai.pathUpdateInterval;\r\n\r\n    // Stuck detection (avoid \"idle\" enemies when direct chasing into obstacles)\r\n    private stuckTimer: number = 0;\r\n    private stuckCheckTimer: number = 0;\r\n    private lastStuckCheckPos = new THREE.Vector3();\r\n\r\n    // Stair forcing (fallback when player is on a stair platform)\r\n    private forcedStairTimer: number = 0;\r\n    private forcedStairBottom = new THREE.Vector3();\r\n    private forcedStairTop = new THREE.Vector3();\r\n    \r\n    // GPU Index (用于 GPU Compute 系统)\r\n    public gpuIndex: number = -1;\r\n\r\n    // Render culling / LOD (do NOT rely on mesh.visible; keep shootability independent)\r\n    private renderCulled: boolean = false;\r\n\r\n    // 动画状态\r\n    private walkCycle: number = 0;\r\n    private originalY: number = 1;\r\n    \r\n    // 平滑转向\r\n    private currentRotation: number = 0;  // 当前朝向角度\r\n    private targetRotation: number = 0;   // 目标朝向角度\r\n    private readonly rotationSpeed: number = EnemyConfig.rotationSpeed;  // 转向速度\r\n\r\n    // Movement (jump/airborne)\r\n    private verticalVelocity: number = 0;\r\n    private jumpCooldownTimer: number = 0;\r\n    \r\n    // 身体部件引用 (用于动画)\r\n    private body!: THREE.Mesh;\r\n    private head!: THREE.Mesh;\r\n    private leftArm!: THREE.Group;\r\n    private rightArm!: THREE.Group;\r\n    private leftLeg!: THREE.Group;\r\n    private rightLeg!: THREE.Group;\r\n    private eyes!: THREE.Mesh;\r\n    private headDetails!: THREE.Group; // LOD 优化: 头部细节组\r\n    \r\n    // 武器系统\r\n    private weapon!: THREE.Group;\r\n    private muzzleFlash!: THREE.Mesh;\r\n    private muzzlePoint!: THREE.Object3D;\r\n    \r\n    // 射击参数\r\n    private fireRate: number;\r\n    private fireTimer: number = 0;\r\n    private fireRange: number;\r\n    private fireDamage: number;\r\n    private accuracy: number;\r\n    private engageRange: number;\r\n        private weaponId: WeaponId;\r\n    private muzzleFlashDuration: number = EnemyConfig.attack.muzzleFlashDuration;\r\n    private muzzleFlashTimer: number = 0;\r\n    \r\n    // 射击状态 (供外部读取)\r\n    public lastShotHit: boolean = false;\r\n    \r\n        // Reuse objects for raycasting/LOS checks\r\n        private losRaycaster = new THREE.Raycaster();\r\n        private losEye = new THREE.Vector3();\r\n        private losDir = new THREE.Vector3();\r\n        private losCandidates: THREE.Object3D[] = [];\r\n        private losIntersects: THREE.Intersection[] = [];\r\n\r\n        private nearbyCollisionEntries: Array<{ box: THREE.Box3; object: THREE.Object3D }> = [];\r\n\r\n        private lastCollisionUserData: any | null = null;\r\n\r\n        private tmpToPlayer = new THREE.Vector3();\r\n        private tmpMoveDir = new THREE.Vector3();\r\n        private tmpNextPosX = new THREE.Vector3();\r\n        private tmpNextPosZ = new THREE.Vector3();\r\n        private tmpYawDir = new THREE.Vector3();\r\n        private tmpMuzzleWorldPos = new THREE.Vector3();\r\n        private tmpTargetPos = new THREE.Vector3();\r\n        private tmpNavTargetPos = new THREE.Vector3();\r\n        private tmpStairTargetPos = new THREE.Vector3();\r\n        private tmpStairDir = new THREE.Vector3();\r\n        private tmpStairApproach = new THREE.Vector3();\r\n        private tmpStairEntry = new THREE.Vector3();\r\n        private tmpShotDir = new THREE.Vector3();\r\n    public lastShotDirection: THREE.Vector3 = new THREE.Vector3();\r\n    \r\n    // 视线检测优化\r\n    private visibilityCheckTimer: number = 0;\r\n    private isPlayerVisible: boolean = false;\r\n    private readonly VISIBILITY_CHECK_INTERVAL: number = 0.25; // 每秒检测4次\r\n\r\n    // LOD / far update throttling\r\n    private currentLodLevel: number = -1;\r\n    private farUpdateAccumulator: number = 0;\r\n    private shadowsDisabled: boolean = false;\r\n    \r\n    // 射击姿态\r\n    private isAiming: boolean = false;\r\n    private aimProgress: number = 0;           // 0 = 放下, 1 = 完全抬起\r\n    private aimSpeed: number;\r\n    private aimHoldTime: number = 0;           // 瞄准保持时间\r\n    private aimHoldDuration: number = EnemyConfig.ai.aimHoldDuration;\r\n    private targetAimDirection: THREE.Vector3 = new THREE.Vector3();  // 瞄准方向\r\n    \r\n    // 地形高度回调\r\n    public onGetGroundHeight: ((x: number, z: number) => number) | null = null;\r\n    \r\n    // 物理系统引用\r\n    private physicsSystem: PhysicsSystem | null = null;\r\n\r\n        constructor(\r\n        position: THREE.Vector3,\r\n        type: EnemyType = 'soldier',\r\n        weaponId?: WeaponId,\r\n        services: GameServices = getDefaultGameServices(),\r\n        events: GameEventBus = new GameEventBus(),\r\n    ) {\r\n        this.type = type;\r\n        this.config = EnemyTypesConfig[type];\r\n\r\n        this.services = services;\r\n        this.events = events;\r\n\r\n            this.weaponId = weaponId ?? ((this.config.weapon as WeaponId) || 'rifle');\r\n\r\n        // 初始化属性\r\n        this.speed = this.config.speed;\r\n        this.health = this.config.health;\r\n        \r\n        // 基础参数来自敌人类型配置，再叠加武器差异\r\n        const baseAttack = this.config.attack;\r\n        const weaponScale: Record<string, { dmg: number; range: number; rate: number; acc: number }> = {\r\n            rifle: { dmg: 1.0, range: 1.0, rate: 1.0, acc: 1.0 },\r\n            smg: { dmg: 0.75, range: 0.75, rate: 1.8, acc: 0.9 },\r\n            shotgun: { dmg: 1.6, range: 0.55, rate: 0.75, acc: 0.85 },\r\n            sniper: { dmg: 2.1, range: 1.35, rate: 0.55, acc: 1.1 },\r\n            pistol: { dmg: 0.85, range: 0.65, rate: 1.2, acc: 0.95 },\r\n            bow: { dmg: 1.2, range: 0.7, rate: 0.9, acc: 0.95 },\r\n        };\r\n        const s = weaponScale[this.weaponId] ?? weaponScale.rifle;\r\n\r\n        this.fireRate = baseAttack.fireRate * s.rate;\r\n        this.fireRange = baseAttack.range * s.range;\r\n        this.fireDamage = baseAttack.damage * s.dmg;\r\n        this.accuracy = Math.max(0.05, Math.min(0.99, baseAttack.accuracy * s.acc));\r\n        this.engageRange = Math.min(baseAttack.engageRange, this.fireRange);\r\n        this.aimSpeed = this.config.ai.aimSpeed;\r\n\r\n        // When three-mesh-bvh is enabled, this stops traversal after the first hit.\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        (this.losRaycaster as any).firstHitOnly = true;\r\n        this.losRaycaster.near = 0;\r\n\r\n        // TSL Uniforms\r\n        this.hitStrength = uniform(0);\r\n        this.dissolveAmount = uniform(0);\r\n        \r\n        // 创建人形敌人 (使用工厂模式)\r\n        const assets = EnemyFactory.createHumanoidEnemy(this.type, this.hitStrength, this.weaponId);\r\n        this.mesh = assets.group;\r\n        this.body = assets.body;\r\n        this.head = assets.head;\r\n        this.leftArm = assets.leftArm;\r\n        this.rightArm = assets.rightArm;\r\n        this.leftLeg = assets.leftLeg;\r\n        this.rightLeg = assets.rightLeg;\r\n        this.eyes = assets.eyes;\r\n        this.headDetails = assets.headDetails;\r\n        this.weapon = assets.weapon;\r\n        this.muzzlePoint = assets.muzzlePoint;\r\n        this.muzzleFlash = assets.muzzleFlash;\r\n        \r\n        this.mesh.position.copy(position);\r\n        this.mesh.position.y = 0;\r\n        this.originalY = 0;\r\n        \r\n        // 设置实体引用\r\n        this.mesh.userData = { isEnemy: true, entity: this };\r\n        this.mesh.traverse((child) => {\r\n            if (child.userData && child.userData.isEnemy) {\r\n                child.userData.entity = this;\r\n            }\r\n        });\r\n\r\n        // 应用缩放\r\n        if (this.config.scale !== 1) {\r\n            this.mesh.scale.setScalar(this.config.scale);\r\n        }\r\n    }\r\n\r\n    public setPhysicsSystem(system: PhysicsSystem) {\r\n        this.physicsSystem = system;\r\n    }\r\n\r\n    public getWeaponId(): WeaponId {\r\n        return this.weaponId;\r\n    }\r\n\r\n    public getPoolKey(): string {\r\n        return `${this.type}:${this.weaponId}`;\r\n    }\r\n\r\n    \r\n    \r\n\r\n    public update(\r\n        playerPosition: THREE.Vector3, \r\n        delta: number, \r\n        obstacles: THREE.Object3D[], \r\n        pathfinding: Pathfinding\r\n    ): { fired: boolean; hit: boolean; damage: number } {\r\n        const result = { fired: false, hit: false, damage: 0 };\r\n        \r\n        if (this.isDead) {\r\n            // 死亡溶解动画\r\n            this.dissolveAmount.value = Math.min(1, this.dissolveAmount.value + delta * 2);\r\n            return result;\r\n        }\r\n        \r\n        // 更新枪口闪光计时器\r\n        if (this.muzzleFlashTimer > 0) {\r\n            this.muzzleFlashTimer -= delta;\r\n            if (this.muzzleFlashTimer <= 0) {\r\n                this.muzzleFlash.visible = false;\r\n            }\r\n        }\r\n\r\n        // 计算到玩家的距离和方向 (avoid per-frame allocations)\r\n        this.tmpToPlayer.subVectors(playerPosition, this.mesh.position);\r\n        const distanceToPlayer = this.tmpToPlayer.length();\r\n        if (distanceToPlayer > 0.00001) this.tmpToPlayer.multiplyScalar(1 / distanceToPlayer);\r\n\r\n        // LOD / culling: reduce drawcalls and skip expensive AI for distant enemies\r\n        this.applyLOD(distanceToPlayer);\r\n        if (this.renderCulled) {\r\n            // Still advance muzzle flash timer so it doesn't get stuck on.\r\n            if (this.muzzleFlashTimer > 0) {\r\n                this.muzzleFlashTimer -= delta;\r\n                if (this.muzzleFlashTimer <= 0) this.muzzleFlash.visible = false;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        // Far enemies: run the heavy AI less frequently (accumulate delta so behavior is time-consistent)\r\n        const farUpdateDistance = EnemyConfig.ai.farUpdateDistance;\r\n        if (distanceToPlayer > farUpdateDistance) {\r\n            this.farUpdateAccumulator += delta;\r\n            const interval = EnemyConfig.ai.farUpdateInterval;\r\n            if (this.farUpdateAccumulator < interval) {\r\n                // Keep lightweight timers moving.\r\n                if (this.muzzleFlashTimer > 0) {\r\n                    this.muzzleFlashTimer -= delta;\r\n                    if (this.muzzleFlashTimer <= 0) this.muzzleFlash.visible = false;\r\n                }\r\n                this.forcedStairTimer = Math.max(0, this.forcedStairTimer - delta);\r\n                return result;\r\n            }\r\n\r\n            // Clamp to avoid huge simulation steps.\r\n            delta = Math.min(this.farUpdateAccumulator, 0.1);\r\n            this.farUpdateAccumulator = 0;\r\n        } else {\r\n            this.farUpdateAccumulator = 0;\r\n        }\r\n\r\n        // Stuck detection at a low frequency to avoid extra per-frame work.\r\n        // When we aren't making progress, we force a pathfinding update to route around obstacles.\r\n        this.stuckCheckTimer -= delta;\r\n        if (this.stuckCheckTimer <= 0) {\r\n            this.stuckCheckTimer = 0.25 + Math.random() * 0.05;\r\n            const dx = this.mesh.position.x - this.lastStuckCheckPos.x;\r\n            const dz = this.mesh.position.z - this.lastStuckCheckPos.z;\r\n            const moved = Math.sqrt(dx * dx + dz * dz);\r\n            if (moved < 0.15) {\r\n                this.stuckTimer = Math.min(2.0, this.stuckTimer + 0.25);\r\n            } else {\r\n                this.stuckTimer = Math.max(0, this.stuckTimer - 0.5);\r\n            }\r\n            this.lastStuckCheckPos.copy(this.mesh.position);\r\n        }\r\n\r\n        this.forcedStairTimer = Math.max(0, this.forcedStairTimer - delta);\r\n        \r\n           // NOTE: visual LOD is handled in applyLOD(distanceToPlayer)\r\n        \r\n        // 射击逻辑\r\n        this.fireTimer += delta;\r\n        \r\n        // 更新瞄准保持计时\r\n        if (this.aimHoldTime > 0) {\r\n            this.aimHoldTime -= delta;\r\n            if (this.aimHoldTime <= 0) {\r\n                this.isAiming = false;\r\n            }\r\n        }\r\n        \r\n        // 优化视线检测频率\r\n        this.visibilityCheckTimer -= delta;\r\n        if (this.visibilityCheckTimer <= 0) {\r\n             this.visibilityCheckTimer = this.VISIBILITY_CHECK_INTERVAL + Math.random() * 0.1; // 随机化避免尖峰\r\n             \r\n             // 只有在攻击距离内才检测视线\r\n             if (distanceToPlayer <= this.engageRange) {\r\n                 this.isPlayerVisible = this.canSeePlayer(playerPosition);\r\n             } else {\r\n                 this.isPlayerVisible = false;\r\n             }\r\n        }\r\n        \r\n        // 检查是否应该瞄准/射击\r\n        if (this.isPlayerVisible) {\r\n            // 计算瞄准方向\r\n            this.targetAimDirection.subVectors(playerPosition, this.mesh.position);\r\n            this.targetAimDirection.y = playerPosition.y + 0.8 - (this.mesh.position.y + 1.3); // 瞄准玩家躯干\r\n            this.targetAimDirection.normalize();\r\n            \r\n            // 开始瞄准\r\n            this.isAiming = true;\r\n            this.aimHoldTime = this.aimHoldDuration;\r\n            \r\n            // 射击 (需要瞄准到一定程度才能射击)\r\n            if (this.fireTimer >= 1 / this.fireRate && this.aimProgress > 0.7) {\r\n                // 这里不需要再次传递 obstacles，因为 fireAtPlayer 不需要做碰撞检测 (基于概率)\r\n                const shotResult = this.fireAtPlayer(playerPosition);\r\n                result.fired = true;\r\n                result.hit = shotResult.hit;\r\n                result.damage = shotResult.damage;\r\n                this.fireTimer = 0;\r\n            }\r\n        }\r\n\r\n        // 行走动画\r\n        this.walkCycle += delta * this.speed * 2;\r\n        this.updateWalkAnimation();\r\n        \r\n        // 更新路径\r\n        this.pathUpdateTimer += delta;\r\n        if (this.pathUpdateTimer >= this.pathUpdateInterval) {\r\n            this.pathUpdateTimer = 0;\r\n            // IMPORTANT:\r\n            // `playerPosition` is the camera position (can be high when the player jumps or stands on a tall obstacle).\r\n            // Pathfinding has a stairs heuristic that triggers on vertical distance, so feeding it camera Y can cause\r\n            // enemies to \"randomly\" head for stairs even when the player is just on a non-navigable box.\r\n            // We instead compute a navigation target Y at the player's XZ: prefer a nearby walkable surface (stairs/platform),\r\n            // otherwise fall back to terrain height.\r\n            // Pathfinding is the heaviest part of enemy AI. Only run it when it matters:\r\n            // - large vertical delta (stairs/elevation)\r\n            // - we appear stuck (direct chase is blocked)\r\n            // - relatively close to the player (routing around dense obstacles)\r\n            const assumedCameraToFeet = 1.6;\r\n            const playerFeetY = playerPosition.y - assumedCameraToFeet;\r\n            const terrainY = this.onGetGroundHeight ? this.onGetGroundHeight(playerPosition.x, playerPosition.z) : 0;\r\n            const approxPlayerNavY = Math.abs(playerFeetY - terrainY) < 1.0 ? terrainY : playerFeetY;\r\n            const verticalDelta = Math.abs(approxPlayerNavY - this.mesh.position.y);\r\n\r\n            const needsVerticalNav = verticalDelta > 2.0;\r\n            const isStuck = this.stuckTimer > 0.75;\r\n            const isCloseEnoughForRouting = distanceToPlayer < 80;\r\n\r\n            if (needsVerticalNav || isStuck || isCloseEnoughForRouting) {\r\n                const navTarget = this.getNavTargetPosition(playerPosition);\r\n                this.currentPath = pathfinding.findPath(this.mesh.position, navTarget);\r\n            }\r\n        }\r\n\r\n        // Jump cooldown\r\n        this.jumpCooldownTimer = Math.max(0, this.jumpCooldownTimer - delta);\r\n\r\n        let targetPos = playerPosition;\r\n\r\n        // Prefer direct chasing when player is visible and roughly on the same vertical level.\r\n        // This makes enemies feel more \"player-like\" (jump/step over small props) instead of always hugging A* nodes.\r\n        // Avoid per-frame PhysicsSystem queries here; approximate using terrain + camera-to-feet.\r\n        const assumedCameraToFeet = 1.6;\r\n        const playerFeetY = playerPosition.y - assumedCameraToFeet;\r\n        const terrainY = this.onGetGroundHeight ? this.onGetGroundHeight(playerPosition.x, playerPosition.z) : 0;\r\n        const approxPlayerNavY = Math.abs(playerFeetY - terrainY) < 1.0 ? terrainY : playerFeetY;\r\n        const heightDelta = Math.abs(approxPlayerNavY - this.mesh.position.y);\r\n        const preferDirectChase = this.isPlayerVisible && heightDelta < 1.6;\r\n\r\n        // Stair forcing:\r\n        // When the player is on a stair platform (target Y close to a stair top), guide enemies to the entrance.\r\n        // We keep a short-lived cached staircase selection to prevent oscillation and to steer into the stair front.\r\n        const shouldForceStairs = heightDelta > 2.0 && (this.currentPath.length === 0 || this.stuckTimer > 0.75);\r\n        if (shouldForceStairs) {\r\n            const waypoints = pathfinding.getWaypoints();\r\n            if (waypoints.length > 0) {\r\n                const onTopTol = 2.0;\r\n                const enemyPos = this.mesh.position;\r\n\r\n                // Only force stairs when the player is actually on a walkable elevated surface (stairs/platform),\r\n                // NOT when standing on a random tall prop.\r\n                const navTargetForStairs = this.getNavTargetPosition(playerPosition);\r\n                const snappedToWalkableSurface = navTargetForStairs.y > terrainY + 0.25;\r\n                if (!snappedToWalkableSurface) {\r\n                    // Player is on terrain or a non-walkable prop: do not force stairs.\r\n                } else {\r\n                    // Refresh cached staircase if none active.\r\n                    if (this.forcedStairTimer <= 0.0001) {\r\n                        let best: { bottom: THREE.Vector3; top: THREE.Vector3 } | null = null;\r\n                        let bestScore = Infinity;\r\n\r\n                        // Choose a staircase whose TOP level matches the snapped nav target and whose top is near the player in XZ.\r\n                        const maxTopMatchXZ = 22.0;\r\n                        const maxTopMatchXZ2 = maxTopMatchXZ * maxTopMatchXZ;\r\n\r\n                        for (const wp of waypoints) {\r\n                            if (Math.abs(navTargetForStairs.y - wp.top.y) > onTopTol) continue;\r\n\r\n                            const dxTop = navTargetForStairs.x - wp.top.x;\r\n                            const dzTop = navTargetForStairs.z - wp.top.z;\r\n                            if (dxTop * dxTop + dzTop * dzTop > maxTopMatchXZ2) continue;\r\n\r\n                            const dx = enemyPos.x - wp.bottom.x;\r\n                            const dz = enemyPos.z - wp.bottom.z;\r\n                            const dBottomXZ = dx * dx + dz * dz;\r\n                            if (dBottomXZ < bestScore) {\r\n                                bestScore = dBottomXZ;\r\n                                best = wp;\r\n                            }\r\n                        }\r\n\r\n                        if (best) {\r\n                            this.forcedStairBottom.copy(best.bottom);\r\n                            this.forcedStairTop.copy(best.top);\r\n                            this.forcedStairTimer = 2.0;\r\n                        }\r\n                    }\r\n\r\n                    if (this.forcedStairTimer > 0.0001) {\r\n                        // Compute stair direction in XZ.\r\n                        this.tmpStairDir.subVectors(this.forcedStairTop, this.forcedStairBottom);\r\n                        this.tmpStairDir.y = 0;\r\n                        const dirLen = this.tmpStairDir.length();\r\n                        if (dirLen > 0.0001) this.tmpStairDir.multiplyScalar(1 / dirLen);\r\n\r\n                        // Approach from the front: step back a bit from the entrance along the stair direction.\r\n                        const approachBack = 4.0;\r\n                        const enterForward = 4.0;\r\n                        this.tmpStairApproach.copy(this.forcedStairBottom).addScaledVector(this.tmpStairDir, -approachBack);\r\n                        this.tmpStairEntry.copy(this.forcedStairBottom).addScaledVector(this.tmpStairDir, enterForward);\r\n\r\n                        // Distances in XZ.\r\n                        const dxB = enemyPos.x - this.forcedStairBottom.x;\r\n                        const dzB = enemyPos.z - this.forcedStairBottom.z;\r\n                        const distBottomXZ = Math.sqrt(dxB * dxB + dzB * dzB);\r\n\r\n                        const enemyBelowTop = enemyPos.y < this.forcedStairTop.y - 1.0;\r\n\r\n                        // Stage selection:\r\n                        // 1) Far away: go to the approach point to align with the stair front.\r\n                        // 2) Near: go to the bottom waypoint.\r\n                        // 3) At entrance: push into the stairs to avoid clustering at the sides.\r\n                        // 4) Near top level: aim for top waypoint.\r\n                        if (enemyBelowTop) {\r\n                            if (distBottomXZ > 10.0) {\r\n                                targetPos = this.tmpStairTargetPos.copy(this.tmpStairApproach);\r\n                            } else if (distBottomXZ > 4.0) {\r\n                                targetPos = this.tmpStairTargetPos.copy(this.forcedStairBottom);\r\n                            } else {\r\n                                targetPos = this.tmpStairTargetPos.copy(this.tmpStairEntry);\r\n                            }\r\n                        } else {\r\n                            targetPos = this.tmpStairTargetPos.copy(this.forcedStairTop);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // 跟随路径（当不可直追，或需要处理垂直导航时）\r\n        if (!preferDirectChase && this.currentPath.length > 0) {\r\n            const nextPoint = this.currentPath[0];\r\n            const dx = nextPoint.x - this.mesh.position.x;\r\n            const dz = nextPoint.z - this.mesh.position.z;\r\n            const dist = Math.sqrt(dx * dx + dz * dz);\r\n\r\n            // Path nodes may be coarse (see Pathfinding cell size), so allow a larger reach distance.\r\n            if (dist < 2.0) {\r\n                this.currentPath.shift();\r\n                if (this.currentPath.length > 0) {\r\n                    targetPos = this.currentPath[0];\r\n                }\r\n            } else {\r\n                targetPos = nextPoint;\r\n            }\r\n        }\r\n\r\n        // 移动计算\r\n        const direction = this.tmpMoveDir.subVectors(targetPos, this.mesh.position);\r\n        direction.y = 0;\r\n        direction.normalize();\r\n\r\n        const moveDistance = this.speed * delta;\r\n\r\n        // X 轴移动\r\n        const nextPosX = this.tmpNextPosX.copy(this.mesh.position);\r\n        nextPosX.x += direction.x * moveDistance;\r\n        \r\n        let collisionBox = this.checkCollisions(nextPosX, obstacles, false);\r\n        if (!collisionBox) {\r\n            this.mesh.position.x = nextPosX.x;\r\n        } else {\r\n            if (!this.tryJumpOverObstacle(collisionBox, direction.x * moveDistance, 0, obstacles)) {\r\n                this.handleObstacle(collisionBox, direction.x * moveDistance, 0);\r\n            }\r\n        }\r\n\r\n        // Z 轴移动\r\n        const nextPosZ = this.tmpNextPosZ.copy(this.mesh.position);\r\n        nextPosZ.z += direction.z * moveDistance;\r\n        \r\n        collisionBox = this.checkCollisions(nextPosZ, obstacles, false);\r\n        if (!collisionBox) {\r\n            this.mesh.position.z = nextPosZ.z;\r\n        } else {\r\n            if (!this.tryJumpOverObstacle(collisionBox, 0, direction.z * moveDistance, obstacles)) {\r\n                this.handleObstacle(collisionBox, 0, direction.z * moveDistance);\r\n            }\r\n        }\r\n\r\n        // Vertical movement:\r\n        // - When not jumping (verticalVelocity == 0), keep the existing stair/ground smoothing.\r\n        // - When airborne, integrate gravity and land on the highest walkable ground under us.\r\n        if (Math.abs(this.verticalVelocity) < 0.0001) {\r\n            // 检查脚下的地面/楼梯高度\r\n            const targetGroundY = this.findGroundHeight(this.mesh.position, obstacles);\r\n\r\n            // 平滑调整高度（用于上下楼梯）\r\n            const heightDiff = targetGroundY - this.mesh.position.y;\r\n            if (Math.abs(heightDiff) > 0.01) {\r\n                // 上楼梯时快速调整，下楼梯时受重力影响\r\n                if (heightDiff > 0) {\r\n                    // 上楼梯 - 快速抬升\r\n                    this.mesh.position.y += Math.min(heightDiff, 8 * delta);\r\n                } else {\r\n                    // 下楼梯/重力 - 正常下降\r\n                    this.mesh.position.y += Math.max(heightDiff, -9.8 * delta);\r\n                }\r\n            }\r\n\r\n            if (this.mesh.position.y < targetGroundY) {\r\n                this.mesh.position.y = targetGroundY;\r\n            }\r\n        } else {\r\n            // Airborne physics\r\n            this.verticalVelocity -= EnemyConfig.movement.gravity * delta;\r\n            this.mesh.position.y += this.verticalVelocity * delta;\r\n\r\n            const groundY = this.findGroundHeight(this.mesh.position, obstacles);\r\n            if (this.mesh.position.y <= groundY) {\r\n                this.mesh.position.y = groundY;\r\n                this.verticalVelocity = 0;\r\n            }\r\n        }\r\n\r\n        // 计算目标朝向\r\n        if (this.isAiming) {\r\n            // 瞄准时朝向玩家\r\n            const toPlayerDir = this.tmpYawDir.subVectors(playerPosition, this.mesh.position);\r\n            toPlayerDir.y = 0;\r\n            if (toPlayerDir.lengthSq() > 0.001) {\r\n                this.targetRotation = Math.atan2(toPlayerDir.x, toPlayerDir.z);\r\n            }\r\n        } else if (direction.lengthSq() > 0.001) {\r\n            // 非瞄准时朝向移动方向\r\n            this.targetRotation = Math.atan2(direction.x, direction.z);\r\n        }\r\n        \r\n        // 平滑转向 - 计算最短旋转距离\r\n        let rotationDiff = this.targetRotation - this.currentRotation;\r\n        \r\n        // 角度归一化到 -PI 到 PI\r\n        while (rotationDiff > Math.PI) rotationDiff -= Math.PI * 2;\r\n        while (rotationDiff < -Math.PI) rotationDiff += Math.PI * 2;\r\n        \r\n        // 平滑插值转向\r\n        this.currentRotation += rotationDiff * Math.min(1, this.rotationSpeed * delta);\r\n        \r\n        // 角度归一化\r\n        while (this.currentRotation > Math.PI) this.currentRotation -= Math.PI * 2;\r\n        while (this.currentRotation < -Math.PI) this.currentRotation += Math.PI * 2;\r\n        \r\n        // 应用旋转\r\n        this.mesh.rotation.y = this.currentRotation;\r\n        \r\n        return result;\r\n    }\r\n\r\n    public isRenderCulled(): boolean {\r\n        return this.renderCulled;\r\n    }\r\n\r\n    private applyLOD(distanceToPlayer: number) {\r\n        const renderCullDistance = EnemyConfig.ai.renderCullDistance;\r\n        const limbLodDistance = EnemyConfig.ai.limbLodDistance;\r\n        const shadowDisableDistance = EnemyConfig.ai.shadowDisableDistance;\r\n\r\n        let lod = 0;\r\n        if (distanceToPlayer > renderCullDistance) lod = 3;\r\n        else if (distanceToPlayer > limbLodDistance) lod = 2;\r\n        else if (distanceToPlayer > 30) lod = 1;\r\n\r\n        if (lod !== this.currentLodLevel) {\r\n            this.currentLodLevel = lod;\r\n\r\n            if (lod === 3) {\r\n                this.renderCulled = true;\r\n                this.setFullRigVisible(false);\r\n                return;\r\n            }\r\n\r\n            this.renderCulled = false;\r\n\r\n            // LOD 1+: hide head details\r\n            this.headDetails.visible = lod <= 0;\r\n\r\n            // LOD 2+: keep a decent silhouette (torso+head) but hide limbs/weapon (visual quality > cylinder)\r\n            const showFullRig = lod <= 1;\r\n            if (showFullRig) {\r\n                this.setFullRigVisible(true);\r\n            } else {\r\n                // torso + head only\r\n                this.body.visible = true;\r\n                this.head.visible = true;\r\n                this.eyes.visible = true;\r\n                this.leftArm.visible = false;\r\n                this.rightArm.visible = false;\r\n                this.leftLeg.visible = false;\r\n                this.rightLeg.visible = false;\r\n                this.weapon.visible = false;\r\n                this.muzzleFlash.visible = false;\r\n                this.headDetails.visible = false;\r\n            }\r\n        } else if (lod === 3) {\r\n            // If already culled, keep hidden.\r\n            this.renderCulled = true;\r\n            return;\r\n        }\r\n\r\n        // Shadows: toggle at distance threshold (only flip when crossing)\r\n        const shouldDisableShadows = distanceToPlayer > shadowDisableDistance;\r\n        if (shouldDisableShadows !== this.shadowsDisabled) {\r\n            this.shadowsDisabled = shouldDisableShadows;\r\n            const cast = !shouldDisableShadows;\r\n            this.setCastShadowRecursive(this.mesh, cast);\r\n        }\r\n    }\r\n\r\n    private setFullRigVisible(visible: boolean) {\r\n        // Keep the root group visible to allow raycasts to still consider this enemy.\r\n        this.body.visible = visible;\r\n        this.head.visible = visible;\r\n        this.eyes.visible = visible;\r\n        this.leftArm.visible = visible;\r\n        this.rightArm.visible = visible;\r\n        this.leftLeg.visible = visible;\r\n        this.rightLeg.visible = visible;\r\n        this.weapon.visible = visible;\r\n        // headDetails handled separately in applyLOD\r\n    }\r\n\r\n    private setCastShadowRecursive(root: THREE.Object3D, castShadow: boolean) {\r\n        root.traverse((obj) => {\r\n            const mesh = obj as THREE.Mesh;\r\n            // @ts-ignore\r\n            if (mesh && typeof mesh.castShadow === 'boolean') {\r\n                // @ts-ignore\r\n                mesh.castShadow = castShadow;\r\n            }\r\n        });\r\n    }\r\n\r\n    private isGrounded(obstacles: THREE.Object3D[]): boolean {\r\n        if (Math.abs(this.verticalVelocity) >= 0.0001) return false;\r\n        const groundY = this.findGroundHeight(this.mesh.position, obstacles);\r\n        return this.mesh.position.y <= groundY + 0.03;\r\n    }\r\n\r\n    private startJump() {\r\n        const g = EnemyConfig.movement.gravity;\r\n        const h = Math.max(0.2, EnemyConfig.movement.jumpHeight);\r\n        // v = sqrt(2gh)\r\n        this.verticalVelocity = Math.sqrt(2 * g * h);\r\n        this.jumpCooldownTimer = EnemyConfig.movement.jumpCooldown;\r\n    }\r\n\r\n    /**\r\n     * Attempt to jump onto/over a low obstacle when colliding.\r\n     * Returns true if we initiated a jump and performed a small motion this frame.\r\n     */\r\n    private tryJumpOverObstacle(\r\n        obstacleBox: THREE.Box3,\r\n        dx: number,\r\n        dz: number,\r\n        obstacles: THREE.Object3D[],\r\n    ): boolean {\r\n        // Only jump when grounded and off cooldown.\r\n        if (!this.isGrounded(obstacles)) return false;\r\n        if (this.jumpCooldownTimer > 0) return false;\r\n\r\n        // Don't jump on stairs/walkable ground; they should be climbed smoothly.\r\n        const ud = this.lastCollisionUserData;\r\n        if (ud?.isStair || ud?.isGround) return false;\r\n\r\n        const enemyFeetY = this.mesh.position.y;\r\n        const obstacleTopY = obstacleBox.max.y;\r\n        const stepHeight = obstacleTopY - enemyFeetY;\r\n\r\n        const minJump = EnemyConfig.collision.maxStepHeight + 0.05;\r\n        const maxJump = EnemyConfig.movement.maxJumpObstacleHeight;\r\n        if (stepHeight < minJump || stepHeight > maxJump) return false;\r\n\r\n        // Start jump.\r\n        this.startJump();\r\n\r\n        // Give a small immediate lift and forward nudge so we don't collide again on the same frame.\r\n        this.mesh.position.y += 0.08;\r\n        const forwardBoost = EnemyConfig.movement.jumpForwardBoost;\r\n\r\n        // Try moving slightly forward at the lifted position.\r\n        const testPos = this.tmpNextPosX.copy(this.mesh.position);\r\n        testPos.x += dx * forwardBoost;\r\n        testPos.z += dz * forwardBoost;\r\n        const hit = this.checkCollisions(testPos, obstacles, false);\r\n        if (!hit) {\r\n            this.mesh.position.copy(testPos);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Compute a navigation target for pathfinding.\r\n     * Keeps XZ = player XZ, but snaps Y to a walkable surface at that XZ when the player is actually standing on it.\r\n     * This avoids stairs mis-selection when the player is simply elevated (jumping / standing on a tall prop).\r\n     */\r\n    private getNavTargetPosition(playerPosition: THREE.Vector3): THREE.Vector3 {\r\n        const out = this.tmpNavTargetPos.copy(playerPosition);\r\n\r\n        // Terrain baseline.\r\n        let terrainY = 0;\r\n        if (this.onGetGroundHeight) {\r\n            terrainY = this.onGetGroundHeight(playerPosition.x, playerPosition.z);\r\n        }\r\n        let navY = terrainY;\r\n\r\n        // Approximate camera-to-feet offset (player stand camera height is 1.6m).\r\n        // We only snap to a surface if the player's feet are close to that surface top.\r\n        const assumedCameraToFeet = 1.6;\r\n        const feetY = playerPosition.y - assumedCameraToFeet;\r\n\r\n        // Prefer a nearby walkable surface (stairs/platform). We purposely ignore generic props,\r\n        // so standing on an arbitrary tall obstacle doesn't trigger a vertical-navigation plan.\r\n        if (this.physicsSystem) {\r\n            const radius = 3.0;\r\n            const pad = 0.25;\r\n            const nearby = this.physicsSystem.getNearbyObjectsInto(playerPosition, radius, this.nearbyCollisionEntries);\r\n            for (const entry of nearby) {\r\n                const ud = entry.object.userData;\r\n                if (!ud) continue;\r\n                const isWalkableSurface = ud.isGround === true || ud.isStair === true;\r\n                if (!isWalkableSurface) continue;\r\n\r\n                // Must be within the surface XZ bounds.\r\n                if (\r\n                    playerPosition.x < entry.box.min.x - pad ||\r\n                    playerPosition.x > entry.box.max.x + pad ||\r\n                    playerPosition.z < entry.box.min.z - pad ||\r\n                    playerPosition.z > entry.box.max.z + pad\r\n                ) {\r\n                    continue;\r\n                }\r\n\r\n                const topY = entry.box.max.y;\r\n\r\n                // Only treat as the player's surface if feet are near it.\r\n                // (If the player is just near stairs but on the ground, this will be false.)\r\n                if (Math.abs(feetY - topY) > 0.85) continue;\r\n\r\n                if (topY > navY) navY = topY;\r\n            }\r\n        }\r\n\r\n        out.y = navY;\r\n        return out;\r\n    }\r\n    \r\n    /**\r\n     * 检查是否能看到玩家 (视线检测)\r\n     * 优化：使用 PhysicsSystem 网格遍历，避免检测全场景\r\n     */\r\n    private canSeePlayer(playerPosition: THREE.Vector3): boolean {\r\n        this.losEye.copy(this.mesh.position);\r\n        this.losEye.y += 1.7; // 眼睛高度\r\n\r\n        this.losDir.subVectors(playerPosition, this.losEye);\r\n        const distance = this.losDir.length();\r\n        this.losDir.normalize();\r\n\r\n        this.losRaycaster.set(this.losEye, this.losDir);\r\n        this.losRaycaster.near = 0;\r\n        this.losRaycaster.far = distance;\r\n        \r\n        // 1. 使用 PhysicsSystem 获取候选物体 (Broad Phase)\r\n        // 如果没有 PhysicsSystem，则无法检测遮挡 (默认可见)\r\n        if (!this.physicsSystem) return true;\r\n\r\n        const candidates = this.physicsSystem.getRaycastCandidatesInto(this.losEye, this.losDir, distance, this.losCandidates);\r\n        \r\n        // 2. 精确检测 (Raycast)\r\n        // 不需要过滤 blockedObjects，因为 PhysicsSystem 只包含静态障碍物\r\n        this.losIntersects.length = 0;\r\n        this.losRaycaster.intersectObjects(candidates, true, this.losIntersects);\r\n        \r\n        // 如果没有障碍物遮挡，可以看到玩家\r\n        return this.losIntersects.length === 0;\r\n    }\r\n    \r\n    /**\r\n     * 向玩家射击\r\n     */\r\n    private fireAtPlayer(playerPosition: THREE.Vector3): { hit: boolean; damage: number } {\r\n        // 显示枪口闪光\r\n        this.muzzleFlash.visible = true;\r\n        this.muzzleFlashTimer = this.muzzleFlashDuration;\r\n        \r\n        // 播放射击音效\r\n        this.events.emit({ type: 'sound:play', sound: 'shoot' });\r\n        \r\n        // 计算射击方向 (带散布)\r\n        // 优化: 不强制更新整个矩阵树，接受一帧的延迟或使用上一帧的矩阵\r\n        // this.mesh.updateMatrixWorld(true);\r\n        const muzzleWorldPos = this.tmpMuzzleWorldPos;\r\n        this.muzzlePoint.getWorldPosition(muzzleWorldPos);\r\n        \r\n        // 玩家躯干位置 (稍微降低目标点)\r\n        const targetPos = this.tmpTargetPos.copy(playerPosition);\r\n        targetPos.y += EnemyConfig.collision.targetHeightOffset; // 瞄准躯干\r\n        \r\n        const direction = this.tmpShotDir.subVectors(targetPos, muzzleWorldPos);\r\n        direction.normalize();\r\n        \r\n        // 保存射击方向 (供外部使用，如弹道效果)\r\n        this.lastShotDirection.copy(direction);\r\n        \r\n        // 命中判定 (基于准确度)\r\n        const hitRoll = Math.random();\r\n        const distanceToPlayer = this.mesh.position.distanceTo(playerPosition);\r\n        \r\n        // 距离影响命中率\r\n        const distanceFactor = Math.max(0.5, 1 - (distanceToPlayer / this.fireRange) * 0.3);\r\n        const effectiveAccuracy = this.accuracy * distanceFactor;\r\n        \r\n        if (hitRoll <= effectiveAccuracy) {\r\n            this.lastShotHit = true;\r\n            return { hit: true, damage: this.fireDamage };\r\n        } else {\r\n            this.lastShotHit = false;\r\n            return { hit: false, damage: 0 };\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * 获取枪口世界坐标 (供外部使用绘制弹道)\r\n     */\r\n    public getMuzzleWorldPosition(): THREE.Vector3;\r\n    public getMuzzleWorldPosition(out: THREE.Vector3): THREE.Vector3;\r\n    public getMuzzleWorldPosition(out?: THREE.Vector3): THREE.Vector3 {\r\n        // 确保矩阵已更新\r\n        this.mesh.updateMatrixWorld(true);\r\n\r\n        const pos = out ?? new THREE.Vector3();\r\n        this.muzzlePoint.getWorldPosition(pos);\r\n        return pos;\r\n    }\r\n    \r\n    /**\r\n     * 更新行走和射击动画\r\n     */\r\n    private updateWalkAnimation() {\r\n        const cycle = this.walkCycle;\r\n        \r\n        // 更新瞄准进度\r\n        if (this.isAiming) {\r\n            this.aimProgress = Math.min(1, this.aimProgress + this.aimSpeed * 0.016);\r\n        } else {\r\n            this.aimProgress = Math.max(0, this.aimProgress - this.aimSpeed * 0.5 * 0.016);\r\n        }\r\n        \r\n        // 身体上下弹跳 (瞄准时减少)\r\n        const bobAmount = Math.sin(cycle * 2) * 0.03 * (1 - this.aimProgress * 0.7);\r\n        this.body.position.y = 1.2 + bobAmount;\r\n        \r\n        // 身体左右摇摆 (瞄准时减少)\r\n        const swayAmount = Math.sin(cycle) * 0.03 * (1 - this.aimProgress * 0.8);\r\n        this.body.rotation.z = swayAmount;\r\n        \r\n        // ========== 手臂动画 ==========\r\n        // 行走时的手臂摆动\r\n        const walkArmSwing = Math.sin(cycle) * 0.5 * (1 - this.aimProgress);\r\n        \r\n        // 瞄准时的手臂姿态\r\n        // 计算抬枪角度 (基于目标方向)\r\n        let aimPitch = 0;\r\n        if (this.aimProgress > 0) {\r\n            // 计算垂直瞄准角度\r\n            aimPitch = Math.asin(Math.max(-0.5, Math.min(0.5, this.targetAimDirection.y)));\r\n        }\r\n        \r\n        // 右臂 (持枪手) - 抬起瞄准\r\n        const rightArmBaseX = -Math.PI / 2 - 0.3; // 抬枪基础角度 (向前平举)\r\n        const rightArmAimX = rightArmBaseX + aimPitch * 0.5; // 加上俯仰调整\r\n        this.rightArm.rotation.x = walkArmSwing * (1 - this.aimProgress) + rightArmAimX * this.aimProgress;\r\n        this.rightArm.rotation.z = -0.1 * (1 - this.aimProgress) + (-0.3) * this.aimProgress; // 手臂内收\r\n        this.rightArm.rotation.y = 0.2 * this.aimProgress; // 手臂向前\r\n        \r\n        // 左臂 - 辅助握枪\r\n        const leftArmBaseX = -Math.PI / 2 - 0.1; // 辅助手抬起角度\r\n        this.leftArm.rotation.x = walkArmSwing + (leftArmBaseX - walkArmSwing) * this.aimProgress;\r\n        this.leftArm.rotation.z = 0.1 * (1 - this.aimProgress) + 0.4 * this.aimProgress; // 手臂外展握护木\r\n        this.leftArm.rotation.y = -0.3 * this.aimProgress; // 向前伸\r\n        \r\n        // 腿部摆动 (瞄准时减少)\r\n        const legSwing = Math.sin(cycle) * 0.6 * (1 - this.aimProgress * 0.5);\r\n        this.leftLeg.rotation.x = -legSwing;\r\n        this.rightLeg.rotation.x = legSwing;\r\n    }\r\n\r\n    /**\r\n     * 找到指定位置下方的地面高度\r\n     */\r\n    private findGroundHeight(position: THREE.Vector3, obstacles: THREE.Object3D[]): number {\r\n        let groundY = 0; // 默认地面高度\r\n        if (this.onGetGroundHeight) {\r\n            groundY = this.onGetGroundHeight(position.x, position.z);\r\n        }\r\n        \r\n        const checkRadius = EnemyConfig.collision.radius;\r\n        // Enemy mesh Y is treated as feet (ground contact) height.\r\n        const feetY = position.y;\r\n        \r\n        // 优化：优先使用物理系统\r\n        if (this.physicsSystem) {\r\n            const nearbyEntries = this.physicsSystem.getNearbyObjectsInto(position, 5.0, this.nearbyCollisionEntries);\r\n            for (const entry of nearbyEntries) {\r\n                // box 已经是世界坐标\r\n                 if (position.x >= entry.box.min.x - checkRadius &&\r\n                    position.x <= entry.box.max.x + checkRadius &&\r\n                    position.z >= entry.box.min.z - checkRadius &&\r\n                    position.z <= entry.box.max.z + checkRadius) {\r\n                    \r\n                    if (entry.box.max.y > groundY && entry.box.max.y <= feetY + EnemyConfig.collision.maxStepHeight) {\r\n                        groundY = entry.box.max.y;\r\n                    }\r\n                }\r\n            }\r\n            return groundY;\r\n        }\r\n\r\n        // 降级：遍历所有障碍物\r\n        for (const object of obstacles) {\r\n            if (object.userData.isGround) continue;\r\n            if (object.userData.isWayPoint) continue;\r\n            \r\n            const objectBox = new THREE.Box3().setFromObject(object);\r\n            \r\n            // 检查是否在该物体的XZ范围内\r\n            if (position.x >= objectBox.min.x - checkRadius &&\r\n                position.x <= objectBox.max.x + checkRadius &&\r\n                position.z >= objectBox.min.z - checkRadius &&\r\n                position.z <= objectBox.max.z + checkRadius) {\r\n                \r\n                // 如果物体顶部在敌人脚下附近（可以站上去）\r\n                if (objectBox.max.y > groundY && objectBox.max.y <= feetY + EnemyConfig.collision.maxStepHeight) {\r\n                    groundY = objectBox.max.y;\r\n                }\r\n            }\r\n        }\r\n        \r\n        return groundY;\r\n    }\r\n\r\n    private handleObstacle(obstacleBox: THREE.Box3, dx: number, dz: number) {\r\n        const enemyFeetY = this.mesh.position.y;\r\n        const obstacleTopY = obstacleBox.max.y;\r\n        const stepHeight = obstacleTopY - enemyFeetY;\r\n\r\n        if (stepHeight > 0 && stepHeight <= EnemyConfig.collision.maxStepHeight * 3) {\r\n            // Step up onto the obstacle by raising feet to the obstacle top.\r\n            this.mesh.position.y = obstacleTopY + 0.01;\r\n            \r\n            const len = Math.sqrt(dx * dx + dz * dz);\r\n            if (len > 0.0001) {\r\n                const scale = 0.3 / len;\r\n                this.mesh.position.x += dx + (dx * scale);\r\n                this.mesh.position.z += dz + (dz * scale);\r\n            } else {\r\n                this.mesh.position.x += dx;\r\n                this.mesh.position.z += dz;\r\n            }\r\n        }\r\n    }\r\n\r\n    private checkCollisions(\r\n        position: THREE.Vector3, \r\n        obstacles: THREE.Object3D[], \r\n        isGroundCheck: boolean = false\r\n    ): THREE.Box3 | null {\r\n        const enemyRadius = EnemyConfig.collision.radius;\r\n        const enemyBox = new THREE.Box3();\r\n        const skinWidth = isGroundCheck ? 0.0 : EnemyConfig.collision.skinWidth;\r\n        const maxStepHeight = EnemyConfig.collision.maxStepHeight;\r\n\r\n        // Enemy mesh Y is feet height; collision capsule/box extends upward.\r\n        enemyBox.min.set(position.x - enemyRadius, position.y + skinWidth, position.z - enemyRadius);\r\n        enemyBox.max.set(position.x + enemyRadius, position.y + EnemyConfig.collision.height * 2, position.z + enemyRadius);\r\n\r\n        this.lastCollisionUserData = null;\r\n\r\n        // 优化：优先使用物理系统 (Spatial Grid)\r\n        if (this.physicsSystem) {\r\n            const nearbyEntries = this.physicsSystem.getNearbyObjectsInto(position, 5.0, this.nearbyCollisionEntries);\r\n            for (const entry of nearbyEntries) {\r\n                // entry.box 已经是世界坐标 AABB\r\n                if (enemyBox.intersectsBox(entry.box)) {\r\n                    // 如果是楼梯，检查是否可以跨越\r\n                    if (entry.object.userData.isStair) {\r\n                        const enemyFeetY = position.y;\r\n                        const stepHeight = entry.box.max.y - enemyFeetY;\r\n                        if (stepHeight > 0 && stepHeight <= maxStepHeight) {\r\n                            continue;\r\n                        }\r\n                    }\r\n                    this.lastCollisionUserData = entry.object.userData;\r\n                    return entry.box;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n\r\n        // 降级：遍历所有障碍物 (性能较差)\r\n        for (const object of obstacles) {\r\n            if (object.userData.isGround) continue;\r\n            if (object.userData.isWayPoint) continue;\r\n\r\n            const objectBox = new THREE.Box3().setFromObject(object);\r\n            if (enemyBox.intersectsBox(objectBox)) {\r\n                // 如果是楼梯，检查是否可以跨越\r\n                if (object.userData.isStair) {\r\n                    const enemyFeetY = position.y;\r\n                    const stepHeight = objectBox.max.y - enemyFeetY;\r\n                    \r\n                    // 如果台阶高度可跨越，不视为碰撞，让敌人可以走上去\r\n                    if (stepHeight > 0 && stepHeight <= maxStepHeight) {\r\n                        continue; // 跳过这个碰撞，允许敌人走上去\r\n                    }\r\n                }\r\n                this.lastCollisionUserData = object.userData;\r\n                return objectBox;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public takeDamage(amount: number) {\r\n        if (this.isDead) return;\r\n\r\n        this.health -= amount;\r\n        \r\n        // 受击闪烁 - 使用 TSL uniform\r\n        this.hitStrength.value = 1;\r\n        \r\n        // 击退效果\r\n        const knockback = new THREE.Vector3(\r\n            (Math.random() - 0.5) * 0.3,\r\n            0.1,\r\n            (Math.random() - 0.5) * 0.3\r\n        );\r\n        this.mesh.position.add(knockback);\r\n\r\n        // 延迟恢复\r\n        setTimeout(() => {\r\n            if (!this.isDead) {\r\n                // 渐变恢复\r\n                const fadeOut = () => {\r\n                    if (this.hitStrength.value > 0.01) {\r\n                        this.hitStrength.value *= 0.8;\r\n                        requestAnimationFrame(fadeOut);\r\n                    } else {\r\n                        this.hitStrength.value = 0;\r\n                    }\r\n                };\r\n                fadeOut();\r\n            }\r\n        }, 80);\r\n\r\n        if (this.health <= 0) {\r\n            this.die();\r\n        }\r\n    }\r\n\r\n    private die() {\r\n        this.isDead = true;\r\n        this.isActive = false;\r\n        this.hitStrength.value = 0.5; // 死亡时保持一定亮度\r\n        this.events.emit({ type: 'sound:play', sound: 'enemyDeath' });\r\n        this.events.emit({ type: 'state:updateScore', delta: EnemyConfig.rewards.score });\r\n\r\n        // NOTE:\r\n        // Do NOT run requestAnimationFrame loops here.\r\n        // Enemies are frequently pooled/reused; an RAF-driven shrink animation would keep running\r\n        // after respawn and corrupt the new enemy state.\r\n        this.mesh.visible = false;\r\n    }\r\n\r\n    /**\r\n     * Re-activate this Enemy instance for pooling.\r\n     * Keeps all GPU resources/materials, only resets runtime state.\r\n     */\r\n    public respawn(position: THREE.Vector3) {\r\n        this.isDead = false;\r\n        this.isActive = true;\r\n\r\n        this.health = this.config.health;\r\n\r\n        // reset uniforms\r\n        this.hitStrength.value = 0;\r\n        this.dissolveAmount.value = 0;\r\n\r\n        // reset movement/ai\r\n        this.currentPath.length = 0;\r\n        this.pathUpdateTimer = 0;\r\n        this.stuckTimer = 0;\r\n        this.stuckCheckTimer = 0;\r\n        this.lastStuckCheckPos.copy(position);\r\n        this.forcedStairTimer = 0;\r\n        this.verticalVelocity = 0;\r\n        this.jumpCooldownTimer = 0;\r\n\r\n        // reset shooting/aim\r\n        this.fireTimer = 0;\r\n        this.muzzleFlashTimer = 0;\r\n        this.lastShotHit = false;\r\n        this.isAiming = false;\r\n        this.aimProgress = 0;\r\n        this.aimHoldTime = 0;\r\n        this.targetAimDirection.set(0, 0, -1);\r\n        if (this.muzzleFlash) this.muzzleFlash.visible = false;\r\n\r\n        // reset render state\r\n        this.renderCulled = false;\r\n        this.currentLodLevel = -1;\r\n        this.farUpdateAccumulator = 0;\r\n        this.shadowsDisabled = false;\r\n\r\n        // reset transform\r\n        this.mesh.visible = true;\r\n        this.mesh.position.copy(position);\r\n        this.mesh.position.y = 0;\r\n        this.originalY = 0;\r\n        this.walkCycle = 0;\r\n\r\n        // reset scale (death might have modified it)\r\n        const s = this.config.scale ?? 1;\r\n        this.mesh.scale.setScalar(s);\r\n    }\r\n\r\n    /**\r\n     * Deactivate without freeing GPU resources (pool reuse).\r\n     */\r\n    public release() {\r\n        this.isActive = false;\r\n        this.mesh.visible = false;\r\n    }\r\n\r\n    public dispose() {\r\n        // Final cleanup only.\r\n        // IMPORTANT: EnemyFactory caches shared geometries; do not dispose geometries here.\r\n        this.mesh.traverse((child) => {\r\n            if (child instanceof THREE.Mesh) {\r\n                if (child.material) {\r\n                    if (Array.isArray(child.material)) {\r\n                        child.material.forEach(m => m.dispose());\r\n                    } else {\r\n                        child.material.dispose();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\enemy\\EnemyFactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\enemy\\EnemyMaterials.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\entities\\ExplosionEffect.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\entities\\GrenadeTSL.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'uniform' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'time' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cos' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'mix' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":39}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Grenade - 手榴弹系统\r\n * 包含投掷动画、物理模拟和爆炸效果\r\n */\r\nimport * as THREE from 'three';\r\nimport { MeshStandardNodeMaterial } from 'three/webgpu';\r\nimport { \r\n    uniform, time, sin, cos, vec3, mix, float, \r\n    uv, smoothstep\r\n} from 'three/tsl';\r\nimport type { ParticleSimulation } from '../core/gpu/GpuSimulationFacade';\r\nimport { ExplosionManager } from './ExplosionEffect';\r\nimport { GameEventBus } from '../core/events/GameEventBus';\r\nimport { WeaponConfig } from '../core/GameConfig';\r\nimport { PhysicsSystem } from '../core/PhysicsSystem';\r\n\r\nexport class Grenade {\r\n    public mesh: THREE.Group;\r\n    public isExploded: boolean = false;\r\n    public isActive: boolean = true;\r\n\r\n    private readonly events: GameEventBus;\r\n\r\n    // Shared render resources (avoid per-grenade geometry/material allocations)\r\n    private static sharedBodyGeo: THREE.BufferGeometry | null = null;\r\n    private static sharedRingGeo: THREE.BufferGeometry | null = null;\r\n    private static sharedPinGeo: THREE.BufferGeometry | null = null;\r\n    private static sharedHandleGeo: THREE.BufferGeometry | null = null;\r\n    private static sharedBodyMaterial: MeshStandardNodeMaterial | null = null;\r\n    private static sharedRingMaterial: MeshStandardNodeMaterial | null = null;\r\n    private static sharedPinMaterial: MeshStandardNodeMaterial | null = null;\r\n    private static sharedHandleMaterial: MeshStandardNodeMaterial | null = null;\r\n    \r\n    // 物理属性\r\n    private velocity: THREE.Vector3;\r\n    private angularVelocity: THREE.Vector3;\r\n    private gravity: number = WeaponConfig.grenade.physics.gravity;\r\n    private bounceFactor: number = WeaponConfig.grenade.physics.bounceFactor;\r\n    private friction: number = WeaponConfig.grenade.physics.friction;\r\n    \r\n    // 定时器\r\n    private fuseTime: number = WeaponConfig.grenade.fuseTime;\r\n    private currentTime: number = 0;\r\n    \r\n    // 爆炸参数\r\n    private explosionRadius: number = WeaponConfig.grenade.explosionRadius;\r\n    private explosionDamage: number = WeaponConfig.grenade.explosionDamage;\r\n    \r\n    // 粒子系统引用 (用于少量碎片)\r\n    private particleSystem: ParticleSimulation | null = null;\r\n    \r\n    // 爆炸特效管理器\r\n    private explosionManager: ExplosionManager | null = null;\r\n    \r\n    // 场景和碰撞对象\r\n    private scene: THREE.Scene;\r\n    private collisionObjects: THREE.Object3D[];\r\n    \r\n    // 敌人引用 (用于伤害计算)\r\n    private enemies: any[] = [];\r\n    \r\n    // 玩家位置引用\r\n    private playerPosition: THREE.Vector3;\r\n    \r\n    // 地面高度回调\r\n    private groundHeightCallback: ((x: number, z: number) => number) | null = null;\r\n\r\n    private physicsSystem: PhysicsSystem | null = null;\r\n    private readonly nearbyColliders: Array<{ box: THREE.Box3; object: THREE.Object3D }> = [];\r\n\r\n    private readonly tmpOldPosition = new THREE.Vector3();\r\n    private readonly tmpObjCenter = new THREE.Vector3();\r\n    private readonly tmpBounceDir = new THREE.Vector3();\r\n    private readonly tmpExplosionPosition = new THREE.Vector3();\r\n    private readonly grenadeBox = new THREE.Box3();\r\n    private readonly tmpObjBox = new THREE.Box3();\r\n\r\n    private static readonly DEBRIS_DIRECTION = new THREE.Vector3(0, 0.8, 0);\r\n    private static readonly DEBRIS_COLOR = {\r\n        start: new THREE.Color(0.4, 0.35, 0.3),\r\n        end: new THREE.Color(0.2, 0.18, 0.15)\r\n    };\r\n\r\n    constructor(\r\n        position: THREE.Vector3, \r\n        direction: THREE.Vector3, \r\n        throwStrength: number,\r\n        scene: THREE.Scene,\r\n        collisionObjects: THREE.Object3D[],\r\n        playerPosition: THREE.Vector3,\r\n        events: GameEventBus = new GameEventBus()\r\n    ) {\r\n        this.scene = scene;\r\n        this.collisionObjects = collisionObjects;\r\n        this.playerPosition = playerPosition;\r\n        this.events = events;\r\n        \r\n        // 创建手榴弹模型\r\n        this.mesh = this.createGrenadeMesh();\r\n\r\n        // Init dynamic state\r\n        this.velocity = new THREE.Vector3();\r\n        this.angularVelocity = new THREE.Vector3();\r\n        this.reset(position, direction, throwStrength);\r\n    }\r\n\r\n    /**\r\n     * Reset grenade state for pooling reuse.\r\n     */\r\n    public reset(position: THREE.Vector3, direction: THREE.Vector3, throwStrength: number) {\r\n        this.isExploded = false;\r\n        this.isActive = true;\r\n        this.currentTime = 0;\r\n\r\n        this.mesh.visible = true;\r\n        this.mesh.position.copy(position);\r\n        this.mesh.rotation.set(0, 0, 0);\r\n\r\n        // 设置初始速度 (投掷方向 + 向上的抛物线)\r\n        this.velocity.copy(direction).normalize().multiplyScalar(throwStrength);\r\n        this.velocity.y += throwStrength * 0.5; // 向上的初始速度\r\n\r\n        // 随机旋转速度\r\n        this.angularVelocity.set(\r\n            (Math.random() - 0.5) * 15,\r\n            (Math.random() - 0.5) * 15,\r\n            (Math.random() - 0.5) * 15\r\n        );\r\n\r\n        // Ensure present in scene\r\n        if (!this.mesh.parent) {\r\n            this.scene.add(this.mesh);\r\n        }\r\n    }\r\n\r\n    public setPhysicsSystem(physicsSystem: PhysicsSystem | null) {\r\n        this.physicsSystem = physicsSystem;\r\n    }\r\n\r\n    /**\r\n     * Release this grenade back to a pool (no GPU resource disposal).\r\n     */\r\n    public release(): void {\r\n        this.isActive = false;\r\n        this.mesh.visible = false;\r\n        if (this.mesh.parent) {\r\n            this.scene.remove(this.mesh);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * 设置粒子系统\r\n     */\r\n    public setParticleSystem(ps: ParticleSimulation) {\r\n        this.particleSystem = ps;\r\n    }\r\n    \r\n    /**\r\n     * 设置爆炸特效管理器\r\n     */\r\n    public setExplosionManager(em: ExplosionManager) {\r\n        this.explosionManager = em;\r\n    }\r\n\r\n    /**\r\n     * 设置地面高度回调\r\n     */\r\n    public setGroundHeightCallback(callback: (x: number, z: number) => number) {\r\n        this.groundHeightCallback = callback;\r\n    }\r\n    \r\n    /**\r\n     * 设置敌人列表 (用于爆炸伤害)\r\n     */\r\n    public setEnemies(enemies: any[]) {\r\n        this.enemies = enemies;\r\n    }\r\n\r\n    /**\r\n     * 创建手榴弹网格\r\n     */\r\n    private createGrenadeMesh(): THREE.Group {\r\n        const group = new THREE.Group();\r\n        group.userData = { isGrenade: true };\r\n\r\n        // Init shared resources once\r\n        if (!Grenade.sharedBodyGeo) {\r\n            const bodyGeo = new THREE.SphereGeometry(0.06, 12, 8);\r\n            bodyGeo.scale(1, 1.4, 1);\r\n            Grenade.sharedBodyGeo = bodyGeo;\r\n        }\r\n        if (!Grenade.sharedRingGeo) Grenade.sharedRingGeo = new THREE.TorusGeometry(0.025, 0.008, 8, 16);\r\n        if (!Grenade.sharedPinGeo) Grenade.sharedPinGeo = new THREE.CylinderGeometry(0.004, 0.004, 0.04, 6);\r\n        if (!Grenade.sharedHandleGeo) Grenade.sharedHandleGeo = new THREE.BoxGeometry(0.015, 0.08, 0.025);\r\n\r\n        if (!Grenade.sharedBodyMaterial) {\r\n            Grenade.sharedBodyMaterial = Grenade.createSharedGrenadeMaterial();\r\n        }\r\n        if (!Grenade.sharedRingMaterial) {\r\n            const ringMaterial = new MeshStandardNodeMaterial({ roughness: 0.3, metalness: 0.9 });\r\n            ringMaterial.colorNode = vec3(0.75, 0.75, 0.78);\r\n            Grenade.sharedRingMaterial = ringMaterial;\r\n        }\r\n        if (!Grenade.sharedPinMaterial) {\r\n            const pinMaterial = new MeshStandardNodeMaterial({ roughness: 0.25, metalness: 0.85 });\r\n            pinMaterial.colorNode = vec3(0.8, 0.8, 0.82);\r\n            Grenade.sharedPinMaterial = pinMaterial;\r\n        }\r\n        if (!Grenade.sharedHandleMaterial) {\r\n            const handleMaterial = new MeshStandardNodeMaterial({ roughness: 0.4, metalness: 0.7 });\r\n            handleMaterial.colorNode = vec3(0.3, 0.32, 0.28);\r\n            Grenade.sharedHandleMaterial = handleMaterial;\r\n        }\r\n        \r\n        // 手榴弹主体 - 椭圆形\r\n        const body = new THREE.Mesh(Grenade.sharedBodyGeo!, Grenade.sharedBodyMaterial!);\r\n        group.add(body);\r\n        \r\n        // 顶部圆环\r\n        const ring = new THREE.Mesh(Grenade.sharedRingGeo!, Grenade.sharedRingMaterial!);\r\n        ring.position.y = 0.1;\r\n        ring.rotation.x = Math.PI / 2;\r\n        group.add(ring);\r\n        \r\n        // 保险销\r\n        const pin = new THREE.Mesh(Grenade.sharedPinGeo!, Grenade.sharedPinMaterial!);\r\n        pin.position.set(0.03, 0.1, 0);\r\n        pin.rotation.z = Math.PI / 4;\r\n        group.add(pin);\r\n        \r\n        // 手柄/击发装置\r\n        const handle = new THREE.Mesh(Grenade.sharedHandleGeo!, Grenade.sharedHandleMaterial!);\r\n        handle.position.set(0.045, 0.03, 0);\r\n        group.add(handle);\r\n        \r\n        return group;\r\n    }\r\n\r\n    /**\r\n     * 手榴弹材质 - 军绿色金属质感\r\n     */\r\n    private static createSharedGrenadeMaterial(): MeshStandardNodeMaterial {\r\n        const material = new MeshStandardNodeMaterial({\r\n            roughness: 0.65,\r\n            metalness: 0.3\r\n        });\r\n        \r\n        const uvCoord = uv();\r\n        \r\n        // 军绿色基底\r\n        const baseGreen = vec3(0.25, 0.30, 0.18);\r\n        \r\n        // 添加一些纹理变化\r\n        const noise = sin(uvCoord.x.mul(50)).mul(sin(uvCoord.y.mul(50))).mul(0.02);\r\n        \r\n        // 横向凹槽\r\n        const grooves = smoothstep(float(0.48), float(0.52), \r\n            sin(uvCoord.y.mul(40)).abs()\r\n        ).mul(0.05);\r\n        \r\n        const finalColor = baseGreen.add(noise).sub(grooves);\r\n        material.colorNode = finalColor;\r\n        \r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * 更新手榴弹\r\n     */\r\n    public update(delta: number): void {\r\n        if (!this.isActive || this.isExploded) return;\r\n        \r\n        // 更新计时器\r\n        this.currentTime += delta;\r\n        \r\n        // 检查是否应该爆炸\r\n        if (this.currentTime >= this.fuseTime) {\r\n            this.explode();\r\n            return;\r\n        }\r\n        \r\n        // 应用重力\r\n        this.velocity.y += this.gravity * delta;\r\n        \r\n        // 应用阻力\r\n        this.velocity.x *= this.friction;\r\n        this.velocity.z *= this.friction;\r\n        \r\n        // 保存旧位置\r\n        this.tmpOldPosition.copy(this.mesh.position);\r\n        \r\n        // 更新位置\r\n        this.mesh.position.addScaledVector(this.velocity, delta);\r\n        \r\n        // 更新旋转\r\n        this.mesh.rotation.x += this.angularVelocity.x * delta;\r\n        this.mesh.rotation.y += this.angularVelocity.y * delta;\r\n        this.mesh.rotation.z += this.angularVelocity.z * delta;\r\n        \r\n        // 地面碰撞检测\r\n        const grenadeRadius = WeaponConfig.grenade.radius;\r\n        \r\n        // 获取实际地面高度\r\n        let groundHeight = 0;\r\n        if (this.groundHeightCallback) {\r\n            groundHeight = this.groundHeightCallback(this.mesh.position.x, this.mesh.position.z);\r\n        }\r\n        \r\n        if (this.mesh.position.y < groundHeight + grenadeRadius) {\r\n            this.mesh.position.y = groundHeight + grenadeRadius;\r\n            this.velocity.y = -this.velocity.y * this.bounceFactor;\r\n            this.velocity.x *= WeaponConfig.grenade.physics.groundFriction;\r\n            this.velocity.z *= WeaponConfig.grenade.physics.groundFriction;\r\n            this.angularVelocity.multiplyScalar(WeaponConfig.grenade.physics.bounceAngularDamping);\r\n            \r\n            // 播放弹跳音效\r\n            if (Math.abs(this.velocity.y) > 1) {\r\n                this.events.emit({ type: 'sound:play', sound: 'hitImpact' });\r\n            }\r\n        }\r\n        \r\n        // 障碍物碰撞检测\r\n        this.checkObstacleCollision(this.tmpOldPosition);\r\n    }\r\n    \r\n    /**\r\n     * 检测与障碍物的碰撞\r\n     */\r\n    private checkObstacleCollision(oldPosition: THREE.Vector3): void {\r\n        // Prefer PhysicsSystem broadphase AABBs.\r\n        // This remains correct even when obstacles are rendered via InstancedMesh batches.\r\n        const ps = this.physicsSystem;\r\n        if (!ps) return;\r\n\r\n        const grenadeBox = this.grenadeBox;\r\n        const radius = WeaponConfig.grenade.radius;\r\n        grenadeBox.min.set(\r\n            this.mesh.position.x - radius,\r\n            this.mesh.position.y - radius,\r\n            this.mesh.position.z - radius\r\n        );\r\n        grenadeBox.max.set(\r\n            this.mesh.position.x + radius,\r\n            this.mesh.position.y + radius,\r\n            this.mesh.position.z + radius\r\n        );\r\n\r\n        // Query slightly larger than grenade radius to catch near misses and avoid tunneling.\r\n        const queryRadius = 2.5;\r\n        ps.getNearbyObjectsInto(this.mesh.position, queryRadius, this.nearbyColliders as any);\r\n\r\n        for (const entry of this.nearbyColliders) {\r\n            const obj = entry.object;\r\n            const ud: any = (obj as any).userData;\r\n            if (ud?.isWayPoint) continue;\r\n            if (ud?.isGrenade) continue;\r\n            if (ud?.noGrenadeCollision) continue;\r\n\r\n            const box = entry.box;\r\n            if (!grenadeBox.intersectsBox(box)) continue;\r\n\r\n            // 简单反弹\r\n            this.mesh.position.copy(oldPosition);\r\n\r\n            // 计算反弹方向 (简化处理)\r\n            box.getCenter(this.tmpObjCenter);\r\n            this.tmpBounceDir.copy(oldPosition).sub(this.tmpObjCenter).normalize();\r\n\r\n            const speed = this.velocity.length();\r\n            this.velocity.copy(this.tmpBounceDir).multiplyScalar(speed * this.bounceFactor);\r\n            this.angularVelocity.multiplyScalar(0.5);\r\n\r\n            // 播放碰撞音效\r\n            if (speed > 2) {\r\n                this.events.emit({ type: 'sound:play', sound: 'hitImpact' });\r\n            }\r\n            break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 爆炸\r\n     */\r\n    public explode(): void {\r\n        if (this.isExploded) return;\r\n        this.isExploded = true;\r\n        this.isActive = false;\r\n        \r\n        this.tmpExplosionPosition.copy(this.mesh.position);\r\n        const explosionPosition = this.tmpExplosionPosition;\r\n        \r\n        // 播放爆炸音效\r\n        this.events.emit({ type: 'sound:play', sound: 'explosion' });\r\n        \r\n        // 使用高效的爆炸特效管理器\r\n        if (this.explosionManager) {\r\n            this.explosionManager.createExplosion(explosionPosition, 2.5);\r\n        }\r\n        \r\n        // 只发射少量碎片粒子 (可选)\r\n        if (this.particleSystem) {\r\n            // 少量快速碎片\r\n            this.particleSystem.emit({\r\n                type: 'debris',\r\n                position: explosionPosition,\r\n                direction: Grenade.DEBRIS_DIRECTION,\r\n                spread: Math.PI,\r\n                speed: { min: 15, max: 30 },\r\n                lifetime: { min: 0.3, max: 0.8 },\r\n                size: { start: 0.04, end: 0.02 },\r\n                color: Grenade.DEBRIS_COLOR,\r\n                gravity: -35,\r\n                drag: 0.95,\r\n                count: 8\r\n            });\r\n        }\r\n        \r\n        // 计算对敌人的伤害 (异步延迟执行避免卡顿)\r\n        setTimeout(() => {\r\n            this.applyExplosionDamage(explosionPosition);\r\n            this.applyPlayerDamage(explosionPosition);\r\n        }, 0);\r\n        \r\n        // 立即隐藏，实际移除/回收由外层管理\r\n        this.mesh.visible = false;\r\n    }\r\n    \r\n    /**\r\n     * 对敌人应用爆炸伤害\r\n     */\r\n    private applyExplosionDamage(explosionPosition: THREE.Vector3): void {\r\n        for (const enemy of this.enemies) {\r\n            if (enemy.isDead) continue;\r\n            \r\n            const distance = enemy.mesh.position.distanceTo(explosionPosition);\r\n            if (distance < this.explosionRadius) {\r\n                // 伤害随距离衰减\r\n                const damageFactor = 1 - (distance / this.explosionRadius);\r\n                const damage = Math.floor(this.explosionDamage * damageFactor * damageFactor);\r\n                \r\n                if (damage > 0) {\r\n                    enemy.takeDamage(damage, explosionPosition);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * 对玩家应用爆炸伤害 (自伤)\r\n     */\r\n    private applyPlayerDamage(explosionPosition: THREE.Vector3): void {\r\n        const distance = this.playerPosition.distanceTo(explosionPosition);\r\n        if (distance < this.explosionRadius) {\r\n            // 伤害随距离衰减\r\n            const damageFactor = 1 - (distance / this.explosionRadius);\r\n            const damage = Math.floor(this.explosionDamage * damageFactor * 0.5);  // 自伤减半\r\n            \r\n            if (damage > 0) {\r\n                this.events.emit({ type: 'state:updateHealth', delta: -damage });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 清理资源\r\n     */\r\n    public dispose(): void {\r\n        // Instance-only cleanup (shared geometries/materials are intentionally not disposed here)\r\n        this.scene.remove(this.mesh);\r\n    }\r\n\r\n    /**\r\n     * Dispose shared render resources (call once on shutdown).\r\n     */\r\n    public static disposeSharedResources(): void {\r\n        Grenade.sharedBodyGeo?.dispose();\r\n        Grenade.sharedRingGeo?.dispose();\r\n        Grenade.sharedPinGeo?.dispose();\r\n        Grenade.sharedHandleGeo?.dispose();\r\n        Grenade.sharedBodyGeo = null;\r\n        Grenade.sharedRingGeo = null;\r\n        Grenade.sharedPinGeo = null;\r\n        Grenade.sharedHandleGeo = null;\r\n\r\n        Grenade.sharedBodyMaterial?.dispose();\r\n        Grenade.sharedRingMaterial?.dispose();\r\n        Grenade.sharedPinMaterial?.dispose();\r\n        Grenade.sharedHandleMaterial?.dispose();\r\n        Grenade.sharedBodyMaterial = null;\r\n        Grenade.sharedRingMaterial = null;\r\n        Grenade.sharedPinMaterial = null;\r\n        Grenade.sharedHandleMaterial = null;\r\n    }\r\n}\r\n\r\n/**\r\n * 手榴弹手部模型 - 用于投掷动画\r\n */\r\nexport class GrenadeHand {\r\n    public mesh: THREE.Group;\r\n    private camera: THREE.Camera;\r\n    \r\n    // 动画状态\r\n    private isAnimating: boolean = false;\r\n    private animationProgress: number = 0;\r\n    private animationSpeed: number = 4.0;\r\n    \r\n    // 位置\r\n    private restPosition = new THREE.Vector3(0.4, -0.4, -0.5);\r\n    private throwPosition = new THREE.Vector3(0.2, 0.1, -0.3);\r\n    private throwEndPosition = new THREE.Vector3(0.3, -0.2, -0.8);\r\n    \r\n    // 回调\r\n    private onThrowComplete: (() => void) | null = null;\r\n\r\n    constructor(camera: THREE.Camera) {\r\n        this.camera = camera;\r\n        this.mesh = this.createHandWithGrenade();\r\n        this.mesh.visible = false;\r\n        camera.add(this.mesh);\r\n    }\r\n    \r\n    /**\r\n     * 创建持有手榴弹的手部模型\r\n     */\r\n    private createHandWithGrenade(): THREE.Group {\r\n        const group = new THREE.Group();\r\n        \r\n        // 简单的手部模型\r\n        const handGeo = new THREE.BoxGeometry(0.08, 0.12, 0.15);\r\n        const handMaterial = new MeshStandardNodeMaterial({\r\n            roughness: 0.8,\r\n            metalness: 0.1\r\n        });\r\n        handMaterial.colorNode = vec3(0.85, 0.7, 0.6);  // 皮肤色\r\n        const hand = new THREE.Mesh(handGeo, handMaterial);\r\n        group.add(hand);\r\n        \r\n        // 手指\r\n        const fingerGeo = new THREE.BoxGeometry(0.02, 0.08, 0.02);\r\n        for (let i = 0; i < 4; i++) {\r\n            const finger = new THREE.Mesh(fingerGeo, handMaterial);\r\n            finger.position.set(-0.03 + i * 0.025, 0.08, 0);\r\n            finger.rotation.x = -0.3;\r\n            group.add(finger);\r\n        }\r\n        \r\n        // 手榴弹 (简化版)\r\n        const grenadeBody = new THREE.SphereGeometry(0.045, 8, 6);\r\n        grenadeBody.scale(1, 1.3, 1);\r\n        const grenadeMaterial = new MeshStandardNodeMaterial({\r\n            roughness: 0.6,\r\n            metalness: 0.3\r\n        });\r\n        grenadeMaterial.colorNode = vec3(0.25, 0.30, 0.18);\r\n        const grenade = new THREE.Mesh(grenadeBody, grenadeMaterial);\r\n        grenade.position.set(0, 0.12, 0);\r\n        group.add(grenade);\r\n        \r\n        group.position.copy(this.restPosition);\r\n        \r\n        return group;\r\n    }\r\n    \r\n    /**\r\n     * 显示手部\r\n     */\r\n    public show(): void {\r\n        this.mesh.visible = true;\r\n        this.mesh.position.copy(this.restPosition);\r\n        this.animationProgress = 0;\r\n        this.isAnimating = false;\r\n    }\r\n    \r\n    /**\r\n     * 隐藏手部\r\n     */\r\n    public hide(): void {\r\n        this.mesh.visible = false;\r\n    }\r\n    \r\n    /**\r\n     * 开始投掷动画\r\n     */\r\n    public startThrow(onComplete: () => void): void {\r\n        if (this.isAnimating) return;\r\n        \r\n        this.isAnimating = true;\r\n        this.animationProgress = 0;\r\n        this.onThrowComplete = onComplete;\r\n    }\r\n    \r\n    /**\r\n     * 更新动画\r\n     */\r\n    public update(delta: number): void {\r\n        if (!this.isAnimating) return;\r\n        \r\n        this.animationProgress += delta * this.animationSpeed;\r\n        \r\n        if (this.animationProgress < 0.5) {\r\n            // 向后拉手 (准备投掷)\r\n            const t = this.animationProgress * 2;\r\n            this.mesh.position.lerpVectors(this.restPosition, this.throwPosition, t);\r\n            this.mesh.rotation.x = -t * 0.5;\r\n        } else if (this.animationProgress < 1.0) {\r\n            // 向前投掷\r\n            const t = (this.animationProgress - 0.5) * 2;\r\n            this.mesh.position.lerpVectors(this.throwPosition, this.throwEndPosition, t);\r\n            this.mesh.rotation.x = -0.5 + t * 1.0;\r\n            \r\n            // 在投掷动作中间触发实际投掷\r\n            if (this.animationProgress >= 0.7 && this.onThrowComplete) {\r\n                const callback = this.onThrowComplete;\r\n                this.onThrowComplete = null;\r\n                callback();\r\n            }\r\n        } else {\r\n            // 动画结束，恢复到休息位置\r\n            this.isAnimating = false;\r\n            this.mesh.position.copy(this.restPosition);\r\n            this.mesh.rotation.x = 0;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * 是否正在动画中\r\n     */\r\n    public isPlaying(): boolean {\r\n        return this.isAnimating;\r\n    }\r\n    \r\n    /**\r\n     * 清理资源\r\n     */\r\n    public dispose(): void {\r\n        this.camera.remove(this.mesh);\r\n        this.mesh.traverse((child) => {\r\n            if (child instanceof THREE.Mesh) {\r\n                if (child.geometry) child.geometry.dispose();\r\n                if (child.material) {\r\n                    if (Array.isArray(child.material)) {\r\n                        child.material.forEach(m => m.dispose());\r\n                    } else {\r\n                        child.material.dispose();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\entities\\PickupTSL.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cos' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fract' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'floor' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sub' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":8},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'pow' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'normalize' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'delta' is defined but never used. Allowed unused args must match /^_/u.","line":399,"column":45,"nodeType":null,"messageId":"unusedVar","endLine":399,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Pickup - 真实风格的拾取物\r\n * 医疗包和弹药箱 - 漂浮、发光、按F拾取\r\n */\r\nimport * as THREE from 'three';\r\nimport { MeshStandardNodeMaterial, MeshBasicNodeMaterial } from 'three/webgpu';\r\nimport { \r\n    uniform, time, sin, cos, vec3, mix, float, \r\n    smoothstep, uv, length, fract, floor,\r\n    sub, abs, pow, step, normalize, max\r\n} from 'three/tsl';\r\nimport { GameEventBus } from '../core/events/GameEventBus';\r\nimport { PickupConfig } from '../core/GameConfig';\r\n\r\nexport type PickupType = 'health' | 'ammo';\r\n\r\nexport class Pickup {\r\n    public mesh: THREE.Group;\r\n    public type: PickupType;\r\n    public isCollected: boolean = false;\r\n    public isInRange: boolean = false;  // 玩家是否在拾取范围内\r\n    \r\n    // 基础高度 (地形高度)\r\n    private baseHeight: number;\r\n\r\n    private readonly events: GameEventBus;\r\n\r\n    // TSL Uniforms\r\n    private collectProgress: any;\r\n    private floatOffset: number;\r\n    private glowMesh: THREE.Mesh | null = null;\r\n    private glowRing: THREE.Mesh | null = null;  // 地面光环\r\n\r\n    // Shared prototypes to avoid per-spawn geometry/material/TSL graph creation spikes.\r\n    // Note: prototype materials bake a fixed pulse offset; visuals are still acceptable,\r\n    // while greatly improving spawn-time stability.\r\n    private static healthPrototype: THREE.Group | null = null;\r\n    private static ammoPrototype: THREE.Group | null = null;\r\n\r\n    constructor(type: PickupType, position: THREE.Vector3, events: GameEventBus = new GameEventBus()) {\r\n        this.type = type;\r\n        this.events = events;\r\n        this.baseHeight = position.y;\r\n        this.floatOffset = Math.random() * 100;\r\n        \r\n        // TSL Uniforms\r\n        this.collectProgress = uniform(0);\r\n\r\n        // Create pickup mesh using shared prototypes to avoid spawn spikes.\r\n        if (type === 'health') {\r\n            if (!Pickup.healthPrototype) {\r\n                // Build prototype once (fixed offset baked into materials)\r\n                const prevOffset = this.floatOffset;\r\n                this.floatOffset = 0;\r\n                Pickup.healthPrototype = this.createHealthPack();\r\n                this.floatOffset = prevOffset;\r\n            }\r\n            this.mesh = Pickup.healthPrototype.clone(true);\r\n        } else {\r\n            if (!Pickup.ammoPrototype) {\r\n                const prevOffset = this.floatOffset;\r\n                this.floatOffset = 0;\r\n                Pickup.ammoPrototype = this.createAmmoBox();\r\n                this.floatOffset = prevOffset;\r\n            }\r\n            this.mesh = Pickup.ammoPrototype.clone(true);\r\n        }\r\n        \r\n        this.mesh.position.copy(position);\r\n        this.mesh.position.y += PickupConfig.visual.floatHeight;  // 叠加漂浮高度\r\n        \r\n        this.mesh.userData = { isPickup: true, type: type };\r\n    }\r\n\r\n    /**\r\n     * 创建真实的医疗包\r\n     */\r\n    private createHealthPack(): THREE.Group {\r\n        const group = new THREE.Group();\r\n        \r\n        // ========== 地面光环 ==========\r\n        this.glowRing = this.createGroundGlow(0x00ff44);\r\n        this.glowRing.position.y = -0.75;\r\n        group.add(this.glowRing);\r\n        \r\n        // ========== 主体盒子 ==========\r\n        const boxGeo = new THREE.BoxGeometry(0.6, 0.4, 0.35);\r\n        const boxMaterial = this.createHealthBoxMaterial();\r\n        const box = new THREE.Mesh(boxGeo, boxMaterial);\r\n        group.add(box);\r\n        \r\n        // ========== 盒盖 ==========\r\n        const lidGeo = new THREE.BoxGeometry(0.62, 0.05, 0.37);\r\n        const lidMaterial = this.createHealthLidMaterial();\r\n        const lid = new THREE.Mesh(lidGeo, lidMaterial);\r\n        lid.position.y = 0.225;\r\n        group.add(lid);\r\n        \r\n        // ========== 提手 ==========\r\n        const handleGeo = new THREE.TorusGeometry(0.12, 0.02, 8, 16, Math.PI);\r\n        const handleMaterial = new MeshStandardNodeMaterial({\r\n            roughness: 0.3,\r\n            metalness: 0.8\r\n        });\r\n        handleMaterial.colorNode = vec3(0.7, 0.7, 0.72);\r\n        const handle = new THREE.Mesh(handleGeo, handleMaterial);\r\n        handle.rotation.x = Math.PI;\r\n        handle.rotation.z = Math.PI / 2;\r\n        handle.position.set(0, 0.32, 0);\r\n        group.add(handle);\r\n        \r\n        // ========== 锁扣 ==========\r\n        const claspGeo = new THREE.BoxGeometry(0.08, 0.06, 0.05);\r\n        const claspMaterial = new MeshStandardNodeMaterial({\r\n            roughness: 0.25,\r\n            metalness: 0.9\r\n        });\r\n        claspMaterial.colorNode = vec3(0.75, 0.75, 0.78);\r\n        \r\n        const clasp1 = new THREE.Mesh(claspGeo, claspMaterial);\r\n        clasp1.position.set(0.2, 0, 0.2);\r\n        group.add(clasp1);\r\n        \r\n        const clasp2 = new THREE.Mesh(claspGeo, claspMaterial);\r\n        clasp2.position.set(-0.2, 0, 0.2);\r\n        group.add(clasp2);\r\n        \r\n        // ========== 顶部发光指示器 ==========\r\n        this.glowMesh = this.createGlowIndicator(0x00ff44);\r\n        this.glowMesh.position.set(0, 0.32, 0);\r\n        group.add(this.glowMesh);\r\n        \r\n        return group;\r\n    }\r\n\r\n    /**\r\n     * 医疗包盒体材质 - 白色带红十字和轻微发光\r\n     */\r\n    private createHealthBoxMaterial(): MeshStandardNodeMaterial {\r\n        const material = new MeshStandardNodeMaterial({\r\n            roughness: 0.6,\r\n            metalness: 0.1\r\n        });\r\n        \r\n        const uvCoord = uv();\r\n        const t = time;\r\n        \r\n        // 白色塑料基底\r\n        const baseWhite = vec3(0.95, 0.95, 0.95);\r\n        \r\n        // ========== 红十字标志 ==========\r\n        const crossWidth = float(0.12);\r\n        const crossLength = float(0.35);\r\n        \r\n        const inHorizontal = step(abs(uvCoord.y.sub(0.5)), crossWidth.div(2))\r\n            .mul(step(abs(uvCoord.x.sub(0.5)), crossLength.div(2)));\r\n        const inVertical = step(abs(uvCoord.x.sub(0.5)), crossWidth.div(2))\r\n            .mul(step(abs(uvCoord.y.sub(0.5)), crossLength.div(2)));\r\n        const crossMask = max(inHorizontal, inVertical);\r\n        \r\n        const redCross = vec3(0.85, 0.1, 0.1);\r\n        \r\n        // 表面细节\r\n        const surfaceNoise = sin(uvCoord.x.mul(100)).mul(sin(uvCoord.y.mul(100))).mul(0.02);\r\n        \r\n        // 组合\r\n        const baseWithCross = mix(baseWhite, redCross, crossMask);\r\n        const finalColor = baseWithCross.add(surfaceNoise);\r\n        \r\n        material.colorNode = finalColor;\r\n        \r\n        // ========== 轻微自发光 ==========\r\n        const glowPulse = sin(t.mul(3)).mul(0.15).add(0.2);\r\n        const emissiveColor = vec3(0.1, 0.4, 0.15).mul(glowPulse);\r\n        material.emissiveNode = emissiveColor;\r\n        \r\n        return material;\r\n    }\r\n    \r\n    /**\r\n     * 医疗包盖子材质\r\n     */\r\n    private createHealthLidMaterial(): MeshStandardNodeMaterial {\r\n        const material = new MeshStandardNodeMaterial({\r\n            roughness: 0.55,\r\n            metalness: 0.1\r\n        });\r\n        \r\n        const uvCoord = uv();\r\n        const t = time;\r\n        \r\n        const baseWhite = vec3(0.92, 0.92, 0.92);\r\n        const noise = sin(uvCoord.x.mul(80)).mul(sin(uvCoord.y.mul(80))).mul(0.015);\r\n        \r\n        const finalColor = baseWhite.add(noise);\r\n        material.colorNode = finalColor;\r\n        \r\n        // 轻微发光\r\n        const glowPulse = sin(t.mul(3)).mul(0.1).add(0.15);\r\n        material.emissiveNode = vec3(0.1, 0.35, 0.12).mul(glowPulse);\r\n        \r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * 创建真实的弹药箱\r\n     */\r\n    private createAmmoBox(): THREE.Group {\r\n        const group = new THREE.Group();\r\n        \r\n        // ========== 地面光环 ==========\r\n        this.glowRing = this.createGroundGlow(0xffaa00);\r\n        this.glowRing.position.y = -0.75;\r\n        group.add(this.glowRing);\r\n        \r\n        // ========== 主体金属箱 ==========\r\n        const boxGeo = new THREE.BoxGeometry(0.55, 0.35, 0.3);\r\n        const boxMaterial = this.createAmmoBoxMaterial();\r\n        const box = new THREE.Mesh(boxGeo, boxMaterial);\r\n        group.add(box);\r\n        \r\n        // ========== 加强筋 ==========\r\n        const ribGeo = new THREE.BoxGeometry(0.02, 0.36, 0.32);\r\n        const ribMaterial = new MeshStandardNodeMaterial({\r\n            roughness: 0.4,\r\n            metalness: 0.85\r\n        });\r\n        ribMaterial.colorNode = vec3(0.25, 0.28, 0.22);\r\n        \r\n        const rib1 = new THREE.Mesh(ribGeo, ribMaterial);\r\n        rib1.position.x = 0.2;\r\n        group.add(rib1);\r\n        \r\n        const rib2 = new THREE.Mesh(ribGeo, ribMaterial);\r\n        rib2.position.x = -0.2;\r\n        group.add(rib2);\r\n        \r\n        // ========== 提手 ==========\r\n        const handleGeo = new THREE.BoxGeometry(0.35, 0.04, 0.04);\r\n        const handleMaterial = new MeshStandardNodeMaterial({\r\n            roughness: 0.35,\r\n            metalness: 0.85\r\n        });\r\n        handleMaterial.colorNode = vec3(0.3, 0.32, 0.28);\r\n        \r\n        const handle = new THREE.Mesh(handleGeo, handleMaterial);\r\n        handle.position.y = 0.2;\r\n        group.add(handle);\r\n        \r\n        // 提手支架\r\n        const bracketGeo = new THREE.BoxGeometry(0.04, 0.06, 0.04);\r\n        const bracket1 = new THREE.Mesh(bracketGeo, handleMaterial);\r\n        bracket1.position.set(0.15, 0.175, 0);\r\n        group.add(bracket1);\r\n        \r\n        const bracket2 = new THREE.Mesh(bracketGeo, handleMaterial);\r\n        bracket2.position.set(-0.15, 0.175, 0);\r\n        group.add(bracket2);\r\n        \r\n        // ========== 锁扣 ==========\r\n        const latchGeo = new THREE.BoxGeometry(0.06, 0.08, 0.03);\r\n        const latchMaterial = new MeshStandardNodeMaterial({\r\n            roughness: 0.3,\r\n            metalness: 0.9\r\n        });\r\n        latchMaterial.colorNode = vec3(0.65, 0.63, 0.58);\r\n        \r\n        const latch = new THREE.Mesh(latchGeo, latchMaterial);\r\n        latch.position.set(0, 0, 0.165);\r\n        group.add(latch);\r\n        \r\n        // ========== 子弹装饰 ==========\r\n        const bulletGeo = new THREE.CylinderGeometry(0.025, 0.025, 0.12, 8);\r\n        const bulletMaterial = new MeshStandardNodeMaterial({\r\n            roughness: 0.2,\r\n            metalness: 0.95\r\n        });\r\n        bulletMaterial.colorNode = vec3(0.85, 0.7, 0.3);\r\n        \r\n        for (let i = 0; i < 5; i++) {\r\n            const bullet = new THREE.Mesh(bulletGeo, bulletMaterial);\r\n            bullet.position.set(-0.12 + i * 0.06, 0.22, 0);\r\n            bullet.rotation.x = Math.PI / 2;\r\n            group.add(bullet);\r\n        }\r\n        \r\n        // ========== 顶部发光指示器 ==========\r\n        this.glowMesh = this.createGlowIndicator(0xffaa00);\r\n        this.glowMesh.position.set(0, 0.25, 0);\r\n        group.add(this.glowMesh);\r\n        \r\n        return group;\r\n    }\r\n    \r\n    /**\r\n     * 弹药箱材质 - 军绿色金属带发光\r\n     */\r\n    private createAmmoBoxMaterial(): MeshStandardNodeMaterial {\r\n        const material = new MeshStandardNodeMaterial({\r\n            roughness: 0.5,\r\n            metalness: 0.75\r\n        });\r\n        \r\n        const uvCoord = uv();\r\n        const t = time;\r\n        \r\n        // 军绿色基底\r\n        const baseGreen = vec3(0.22, 0.28, 0.18);\r\n        const darkGreen = vec3(0.15, 0.2, 0.12);\r\n        \r\n        const largeNoise = sin(uvCoord.x.mul(8)).mul(sin(uvCoord.y.mul(6))).mul(0.5).add(0.5);\r\n        const baseColor = mix(baseGreen, darkGreen, largeNoise.mul(0.3));\r\n        \r\n        // 划痕\r\n        const scratchNoise = sin(uvCoord.x.mul(60).add(uvCoord.y.mul(5)));\r\n        const scratchMask = smoothstep(float(0.92), float(0.98), scratchNoise.mul(0.5).add(0.5));\r\n        const scratchColor = vec3(0.4, 0.42, 0.38);\r\n        \r\n        const withScratch = mix(baseColor, scratchColor, scratchMask.mul(0.5));\r\n        \r\n        // 标记区域\r\n        const labelArea = step(float(0.3), uvCoord.x).mul(step(uvCoord.x, float(0.7)))\r\n            .mul(step(float(0.35), uvCoord.y)).mul(step(uvCoord.y, float(0.65)));\r\n        const labelBg = vec3(0.18, 0.22, 0.15);\r\n        \r\n        const finalColor = mix(withScratch, labelBg, labelArea.mul(0.4));\r\n        material.colorNode = finalColor;\r\n        \r\n        // ========== 轻微自发光 ==========\r\n        const glowPulse = sin(t.mul(3)).mul(0.12).add(0.18);\r\n        const emissiveColor = vec3(0.4, 0.3, 0.05).mul(glowPulse);\r\n        material.emissiveNode = emissiveColor;\r\n        \r\n        // 粗糙度和金属度\r\n        material.roughnessNode = float(0.5);\r\n        material.metalnessNode = float(0.75);\r\n        \r\n        return material;\r\n    }\r\n    \r\n    /**\r\n     * 创建地面光环效果\r\n     */\r\n    private createGroundGlow(color: number): THREE.Mesh {\r\n        const geo = new THREE.RingGeometry(0.3, 0.6, 32);\r\n        const material = new MeshBasicNodeMaterial({\r\n            transparent: true,\r\n            side: THREE.DoubleSide,\r\n            depthWrite: false\r\n        });\r\n        \r\n        const t = time;\r\n        const offset = float(this.floatOffset);\r\n        const baseColor = new THREE.Color(color);\r\n        const glowColor = vec3(baseColor.r, baseColor.g, baseColor.b);\r\n        \r\n        // 脉动和旋转效果\r\n        const pulse = sin(t.mul(2).add(offset)).mul(0.3).add(0.6);\r\n        \r\n        // 从中心向外渐变\r\n        const uvCoord = uv();\r\n        const dist = length(uvCoord.sub(vec3(0.5, 0.5, 0)));\r\n        const fade = smoothstep(float(0.5), float(0.2), dist);\r\n        \r\n        material.colorNode = glowColor.mul(pulse);\r\n        material.opacityNode = pulse.mul(0.5).mul(fade);\r\n        \r\n        const mesh = new THREE.Mesh(geo, material);\r\n        mesh.rotation.x = -Math.PI / 2;\r\n        return mesh;\r\n    }\r\n    \r\n    /**\r\n     * 创建发光指示器\r\n     */\r\n    private createGlowIndicator(color: number): THREE.Mesh {\r\n        const geo = new THREE.SphereGeometry(0.06, 12, 12);\r\n        const material = new MeshBasicNodeMaterial({\r\n            transparent: true\r\n        });\r\n        \r\n        const t = time;\r\n        const offset = float(this.floatOffset);\r\n        \r\n        const pulse = sin(t.mul(4).add(offset)).mul(0.3).add(0.7);\r\n        const baseColor = new THREE.Color(color);\r\n        const glowColor = vec3(baseColor.r, baseColor.g, baseColor.b);\r\n        \r\n        material.colorNode = glowColor.mul(pulse).mul(1.8);\r\n        material.opacityNode = pulse;\r\n        \r\n        const mesh = new THREE.Mesh(geo, material);\r\n        return mesh;\r\n    }\r\n\r\n    /**\r\n     * 更新 - 检测玩家距离并显示提示\r\n     */\r\n    public update(playerPos: THREE.Vector3, delta: number) {\r\n        if (this.isCollected) return;\r\n\r\n        const t = performance.now() * 0.001;\r\n        \r\n        // 漂浮动画 (基于基础高度)\r\n        const floatY = Math.sin(t * PickupConfig.visual.bobSpeed + this.floatOffset) * PickupConfig.visual.bobHeight;\r\n        this.mesh.position.y = this.baseHeight + PickupConfig.visual.floatHeight + floatY;\r\n        \r\n        // 缓慢旋转\r\n        this.mesh.rotation.y = t * PickupConfig.visual.rotateSpeed + this.floatOffset;\r\n\r\n        // 检测距离\r\n        const dist = this.mesh.position.distanceTo(playerPos);\r\n        \r\n        if (dist < PickupConfig.interaction.range) {\r\n            if (!this.isInRange) {\r\n                this.isInRange = true;\r\n                // 显示拾取提示\r\n                const hintText = this.type === 'health' ? '拾取医疗包' : '拾取弹药';\r\n                this.events.emit({ type: 'state:setPickupHint', hint: hintText });\r\n            }\r\n        } else {\r\n            if (this.isInRange) {\r\n                this.isInRange = false;\r\n                this.events.emit({ type: 'state:setPickupHint', hint: null });\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * 尝试拾取 (由外部按键触发)\r\n     */\r\n    public tryCollect(): boolean {\r\n        if (this.isCollected || !this.isInRange) return false;\r\n        \r\n        this.collect();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * 收集拾取物\r\n     */\r\n    private collect() {\r\n        if (this.isCollected) return;\r\n        this.isCollected = true;\r\n        this.isInRange = false;\r\n        \r\n        // 清除提示\r\n        this.events.emit({ type: 'state:setPickupHint', hint: null });\r\n        \r\n        this.events.emit({ type: 'sound:play', sound: 'pickup' });\r\n\r\n        // 应用效果\r\n        if (this.type === 'health') {\r\n            this.events.emit({ type: 'state:updateHealth', delta: PickupConfig.health.amount });\r\n        } else {\r\n            this.events.emit({ type: 'state:updateAmmo', delta: PickupConfig.ammo.amount });\r\n        }\r\n\r\n        // 收集动画\r\n        const animateCollect = () => {\r\n            if (this.collectProgress.value < 1) {\r\n                this.collectProgress.value += 0.12;\r\n                \r\n                this.mesh.scale.multiplyScalar(0.88);\r\n                this.mesh.position.y += 0.08;\r\n                this.mesh.rotation.y += 0.5;\r\n                \r\n                requestAnimationFrame(animateCollect);\r\n            } else {\r\n                this.mesh.visible = false;\r\n            }\r\n        };\r\n        animateCollect();\r\n    }\r\n\r\n    /**\r\n     * 清理资源\r\n     */\r\n    public dispose() {\r\n        if (this.isInRange) {\r\n            this.events.emit({ type: 'state:setPickupHint', hint: null });\r\n        }\r\n        // Meshes share geometries/materials via static prototypes; do not dispose per instance.\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\level\\EnvironmentSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'mapRadius' is defined but never used. Allowed unused args must match /^_/u.","line":206,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":206,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'mapRadius' is defined but never used. Allowed unused args must match /^_/u.","line":279,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":279,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'mapRadius' is defined but never used. Allowed unused args must match /^_/u.","line":337,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":337,"endColumn":41}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from 'three';\r\nimport { MapConfig, EnvironmentConfig, LevelConfig } from '../core/GameConfig';\r\nimport { LevelMaterials } from './LevelMaterials';\r\nimport { PhysicsSystem } from '../core/PhysicsSystem';\r\n\r\nexport class EnvironmentSystem {\r\n    private scene: THREE.Scene;\r\n    private objects: THREE.Object3D[];\r\n    private getTerrainHeight: (x: number, z: number) => number;\r\n    private physicsSystem: PhysicsSystem | null;\r\n    \r\n    // 材质缓存\r\n    private wallMaterial: THREE.Material;\r\n    private concreteMaterial: THREE.Material;\r\n    private metalMaterial: THREE.Material;\r\n    private rockMaterial: THREE.Material;\r\n\r\n    constructor(\r\n        scene: THREE.Scene, \r\n        objects: THREE.Object3D[], \r\n        getTerrainHeight: (x: number, z: number) => number,\r\n        physicsSystem: PhysicsSystem | null = null\r\n    ) {\r\n        this.scene = scene;\r\n        this.objects = objects;\r\n        this.getTerrainHeight = getTerrainHeight;\r\n        this.physicsSystem = physicsSystem;\r\n\r\n        // 初始化材质\r\n        this.wallMaterial = LevelMaterials.createWallMaterial();\r\n        this.concreteMaterial = LevelMaterials.createConcreteMaterial();\r\n        this.metalMaterial = LevelMaterials.createMetalCrateMaterial();\r\n        this.rockMaterial = LevelMaterials.createRockMaterial();\r\n    }\r\n\r\n    /**\r\n     * 创建空气墙边界 (Invisible Boundary)\r\n     */\r\n    public createWalls() {\r\n        const boundaryRadius = MapConfig.boundaryRadius;\r\n        const thickness = 10;\r\n        const range = boundaryRadius; \r\n        \r\n        // 使用透明材质而不是 TSL BasicNodeMaterial 以确保在非 TSL 环境兼容（虽然整个项目是 TSL）\r\n        // 这里还是用 MeshBasicNodeMaterial 无妨，但为了简单用 Three.MeshBasicMaterial\r\n        const wallMaterial = new THREE.MeshBasicMaterial({ visible: false });\r\n        \r\n        const configs = [\r\n            { pos: [0, 0, -range], size: [range * 2, 100, thickness] }, // North\r\n            { pos: [0, 0, range], size: [range * 2, 100, thickness] },  // South\r\n            { pos: [-range, 0, 0], size: [thickness, 100, range * 2] }, // West\r\n            { pos: [range, 0, 0], size: [thickness, 100, range * 2] },  // East\r\n        ];\r\n\r\n        configs.forEach(cfg => {\r\n             const geo = new THREE.BoxGeometry(cfg.size[0], cfg.size[1], cfg.size[2]);\r\n             const mesh = new THREE.Mesh(geo, wallMaterial);\r\n             mesh.position.set(cfg.pos[0] as number, cfg.pos[1] as number, cfg.pos[2] as number);\r\n             \r\n             this.scene.add(mesh);\r\n             this.objects.push(mesh);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 创建障碍物\r\n     */\r\n    public createObstacles() {\r\n        const boxGeo = new THREE.BoxGeometry(2, 2, 2);\r\n        const tallGeo = new THREE.BoxGeometry(2, 6, 2);\r\n        const mapRadius = MapConfig.size / 2 - 10;\r\n\r\n        const centerPositions = [\r\n            { x: 5, z: 5, type: 'box' },\r\n            { x: -5, z: 5, type: 'box' },\r\n            { x: 5, z: -5, type: 'box' },\r\n            { x: -5, z: -5, type: 'box' },\r\n            { x: 15, z: 15, type: 'tall' },\r\n            { x: -15, z: 15, type: 'tall' },\r\n            { x: 15, z: -15, type: 'tall' },\r\n            { x: -15, z: -15, type: 'tall' },\r\n            { x: 0, z: 15, type: 'box' },\r\n            { x: 0, z: -15, type: 'box' },\r\n            { x: 15, z: 0, type: 'box' },\r\n            { x: -15, z: 0, type: 'box' },\r\n        ];\r\n        \r\n        const outerPositions: {x: number, z: number, type: string}[] = [];\r\n        const gridSpacing = 25;\r\n        for (let x = -mapRadius + 30; x <= mapRadius - 30; x += gridSpacing) {\r\n            for (let z = -mapRadius + 30; z <= mapRadius - 30; z += gridSpacing) {\r\n                if (Math.abs(x) < 25 && Math.abs(z) < 25) continue;\r\n                \r\n                const seed = x * 127 + z * 311;\r\n                const offsetX = Math.sin(seed) * 5;\r\n                const offsetZ = Math.cos(seed * 1.3) * 5;\r\n                \r\n                const type = Math.sin(seed * 2.7) > 0.3 ? 'box' : 'tall';\r\n                outerPositions.push({ \r\n                    x: x + offsetX, \r\n                    z: z + offsetZ, \r\n                    type \r\n                });\r\n            }\r\n        }\r\n        \r\n        const allPositions = [...centerPositions, ...outerPositions];\r\n\r\n        // Render via instancing (massive drawcall reduction), but keep accurate per-obstacle AABB collisions\r\n        // by registering per-instance Box3 colliders into PhysicsSystem.\r\n        const instances: {\r\n            boxMetal: THREE.Matrix4[];\r\n            boxConcrete: THREE.Matrix4[];\r\n            tallMetal: THREE.Matrix4[];\r\n            tallConcrete: THREE.Matrix4[];\r\n            colliders: Array<{ box: THREE.Box3; objectKey: 'boxMetal' | 'boxConcrete' | 'tallMetal' | 'tallConcrete' }>;\r\n        } = {\r\n            boxMetal: [],\r\n            boxConcrete: [],\r\n            tallMetal: [],\r\n            tallConcrete: [],\r\n            colliders: [],\r\n        };\r\n\r\n        const embedDepth = 0.5;\r\n        const dummy = new THREE.Object3D();\r\n\r\n        allPositions.forEach((p, index) => {\r\n            const height = p.type === 'box' ? 2 : 6;\r\n            const groundY = this.getTerrainHeight(p.x, p.z);\r\n\r\n            const distToSpawn = Math.sqrt(p.x * p.x + p.z * p.z);\r\n            if (distToSpawn < LevelConfig.safeZoneRadius) return;\r\n            if (groundY < EnvironmentConfig.water.level + 0.5) return;\r\n\r\n            const y = groundY + height / 2 - embedDepth;\r\n\r\n            const isMetal = index % 2 === 0;\r\n            const key: 'boxMetal' | 'boxConcrete' | 'tallMetal' | 'tallConcrete' =\r\n                p.type === 'box'\r\n                    ? (isMetal ? 'boxMetal' : 'boxConcrete')\r\n                    : (isMetal ? 'tallMetal' : 'tallConcrete');\r\n\r\n            dummy.position.set(p.x, y, p.z);\r\n            dummy.rotation.set(0, 0, 0);\r\n            dummy.scale.set(1, 1, 1);\r\n            dummy.updateMatrix();\r\n            (instances[key] as THREE.Matrix4[]).push(dummy.matrix.clone());\r\n\r\n            // Axis-aligned collider (no rotation)\r\n            const halfX = 1;\r\n            const halfZ = 1;\r\n            const halfY = height / 2;\r\n            const collider = new THREE.Box3(\r\n                new THREE.Vector3(p.x - halfX, y - halfY, p.z - halfZ),\r\n                new THREE.Vector3(p.x + halfX, y + halfY, p.z + halfZ)\r\n            );\r\n            instances.colliders.push({ box: collider, objectKey: key });\r\n        });\r\n\r\n        const createdMeshes: Partial<Record<'boxMetal' | 'boxConcrete' | 'tallMetal' | 'tallConcrete', THREE.InstancedMesh>> = {};\r\n        const createBatch = (\r\n            key: 'boxMetal' | 'boxConcrete' | 'tallMetal' | 'tallConcrete',\r\n            geo: THREE.BufferGeometry,\r\n            mat: THREE.Material\r\n        ) => {\r\n            const matrices = instances[key];\r\n            if (matrices.length === 0) return;\r\n            const mesh = new THREE.InstancedMesh(geo, mat, matrices.length);\r\n            mesh.castShadow = true;\r\n            mesh.receiveShadow = true;\r\n            mesh.userData = { isObstacleBatch: true, noPhysics: true };\r\n\r\n            for (let i = 0; i < matrices.length; i++) {\r\n                mesh.setMatrixAt(i, matrices[i]);\r\n            }\r\n            mesh.instanceMatrix.needsUpdate = true;\r\n            mesh.computeBoundingSphere();\r\n\r\n            this.scene.add(mesh);\r\n            this.objects.push(mesh);\r\n            createdMeshes[key] = mesh;\r\n\r\n            // Prepare for raycasts (BVH/targets) without registering a huge AABB collider\r\n            this.physicsSystem?.prepareStaticObject(mesh);\r\n        };\r\n\r\n        createBatch('boxMetal', boxGeo, this.metalMaterial);\r\n        createBatch('boxConcrete', boxGeo, this.concreteMaterial);\r\n        createBatch('tallMetal', tallGeo, this.metalMaterial);\r\n        createBatch('tallConcrete', tallGeo, this.concreteMaterial);\r\n\r\n        // Register per-instance colliders\r\n        if (this.physicsSystem) {\r\n            for (const c of instances.colliders) {\r\n                const obj = createdMeshes[c.objectKey];\r\n                if (!obj) continue;\r\n                this.physicsSystem.addStaticBoxCollider(c.box, obj);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 创建岩石群\r\n     */\r\n    public createRockFormations(mapRadius: number) {\r\n        const smallRockGeo = new THREE.DodecahedronGeometry(1.5, 0);\r\n        const mediumRockGeo = new THREE.DodecahedronGeometry(2.5, 1);\r\n        const largeRockGeo = new THREE.DodecahedronGeometry(4, 1);\r\n        \r\n        const rockClusters = [\r\n            { x: 60, z: 60, count: 5, size: 'mixed' },\r\n            { x: -60, z: 60, count: 4, size: 'mixed' },\r\n            { x: 60, z: -60, count: 5, size: 'mixed' },\r\n            { x: -60, z: -60, count: 4, size: 'mixed' },\r\n            { x: 0, z: 75, count: 3, size: 'large' },\r\n            { x: 0, z: -75, count: 3, size: 'large' },\r\n            { x: 75, z: 0, count: 3, size: 'large' },\r\n            { x: -75, z: 0, count: 3, size: 'large' },\r\n            { x: 85, z: 50, count: 4, size: 'mixed' },\r\n            { x: -85, z: 50, count: 4, size: 'mixed' },\r\n            { x: 85, z: -50, count: 4, size: 'mixed' },\r\n            { x: -85, z: -50, count: 4, size: 'mixed' },\r\n            { x: 50, z: 85, count: 3, size: 'mixed' },\r\n            { x: -50, z: 85, count: 3, size: 'mixed' },\r\n            { x: 50, z: -85, count: 3, size: 'mixed' },\r\n            { x: -50, z: -85, count: 3, size: 'mixed' },\r\n        ];\r\n        \r\n        rockClusters.forEach((cluster, clusterIndex) => {\r\n            for (let i = 0; i < cluster.count; i++) {\r\n                const seed = clusterIndex * 100 + i;\r\n                const offsetX = Math.sin(seed * 12.9898) * 8;\r\n                const offsetZ = Math.cos(seed * 78.233) * 8;\r\n                \r\n                let geo: THREE.BufferGeometry;\r\n                let scale: number;\r\n                \r\n                if (cluster.size === 'large' || (cluster.size === 'mixed' && i === 0)) {\r\n                    geo = largeRockGeo;\r\n                    scale = 0.8 + Math.sin(seed * 3.14) * 0.4;\r\n                } else if (cluster.size === 'mixed' && i < 2) {\r\n                    geo = mediumRockGeo;\r\n                    scale = 0.7 + Math.sin(seed * 2.71) * 0.3;\r\n                } else {\r\n                    geo = smallRockGeo;\r\n                    scale = 0.6 + Math.sin(seed * 1.41) * 0.4;\r\n                }\r\n                \r\n                const mesh = new THREE.Mesh(geo, this.rockMaterial);\r\n                \r\n                const x = cluster.x + offsetX;\r\n                const z = cluster.z + offsetZ;\r\n                \r\n                const groundH = this.getTerrainHeight(x, z);\r\n                const y = groundH + scale * 0.8;\r\n                \r\n                mesh.position.set(x, y, z);\r\n                mesh.scale.set(scale, scale * (0.6 + Math.random() * 0.4), scale);\r\n                mesh.rotation.set(\r\n                    Math.sin(seed) * 0.3,\r\n                    Math.sin(seed * 2) * Math.PI,\r\n                    Math.cos(seed) * 0.2\r\n                );\r\n                \r\n                mesh.castShadow = true;\r\n                mesh.receiveShadow = true;\r\n                mesh.userData = { isRock: true };\r\n                \r\n                this.scene.add(mesh);\r\n                this.objects.push(mesh);\r\n            }\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * 创建废墟断墙\r\n     */\r\n    public createRuins(mapRadius: number) {\r\n        const ruinPositions = [\r\n            { x: 40, z: 40, rotation: 0.3, height: 3 },\r\n            { x: -40, z: 40, rotation: -0.2, height: 4 },\r\n            { x: 40, z: -40, rotation: 0.5, height: 2.5 },\r\n            { x: -40, z: -40, rotation: -0.4, height: 3.5 },\r\n            { x: 70, z: 20, rotation: 0.8, height: 4 },\r\n            { x: -70, z: 20, rotation: -0.6, height: 3 },\r\n            { x: 70, z: -20, rotation: 0.2, height: 3.5 },\r\n            { x: -70, z: -20, rotation: -0.3, height: 4 },\r\n            { x: 20, z: 70, rotation: 1.2, height: 3 },\r\n            { x: -20, z: 70, rotation: -1.1, height: 2.5 },\r\n            { x: 20, z: -70, rotation: 0.9, height: 4 },\r\n            { x: -20, z: -70, rotation: -0.8, height: 3 },\r\n        ];\r\n        \r\n        ruinPositions.forEach((ruin, index) => {\r\n            const wallWidth = 6 + Math.sin(index * 2.5) * 2;\r\n            const wallGeo = new THREE.BoxGeometry(wallWidth, ruin.height, 0.8);\r\n            const wallMesh = new THREE.Mesh(wallGeo, this.wallMaterial);\r\n            \r\n            const groundH = this.getTerrainHeight(ruin.x, ruin.z);\r\n            const embed = 0.5;\r\n            \r\n            wallMesh.position.set(ruin.x, groundH + ruin.height / 2 - embed, ruin.z);\r\n            wallMesh.rotation.y = ruin.rotation;\r\n            wallMesh.castShadow = true;\r\n            wallMesh.receiveShadow = true;\r\n            wallMesh.userData = { isRuin: true };\r\n            \r\n            this.scene.add(wallMesh);\r\n            this.objects.push(wallMesh);\r\n            \r\n            if (index % 2 === 0) {\r\n                const debrisGeo = new THREE.BoxGeometry(1.5, 0.8, 1);\r\n                const debrisMesh = new THREE.Mesh(debrisGeo, this.concreteMaterial);\r\n                \r\n                const offsetX = Math.cos(ruin.rotation) * 3;\r\n                const offsetZ = Math.sin(ruin.rotation) * 3;\r\n                \r\n                const debrisX = ruin.x + offsetX;\r\n                const debrisZ = ruin.z + offsetZ;\r\n                const debrisGroundH = this.getTerrainHeight(debrisX, debrisZ);\r\n                \r\n                debrisMesh.position.set(debrisX, debrisGroundH + 0.3, debrisZ);\r\n                debrisMesh.rotation.set(0.2, ruin.rotation + 0.5, 0.1);\r\n                debrisMesh.castShadow = true;\r\n                debrisMesh.receiveShadow = true;\r\n                \r\n                this.scene.add(debrisMesh);\r\n                this.objects.push(debrisMesh);\r\n            }\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * 创建沙袋掩体\r\n     */\r\n    public createSandbagCovers(mapRadius: number) {\r\n        const sandbagMaterial = LevelMaterials.createSandbagMaterial();\r\n        \r\n        const coverPositions = [\r\n            { x: 30, z: 0, rotation: 0 },\r\n            { x: -30, z: 0, rotation: Math.PI },\r\n            { x: 0, z: 30, rotation: Math.PI / 2 },\r\n            { x: 0, z: -30, rotation: -Math.PI / 2 },\r\n            { x: 50, z: 30, rotation: 0.5 },\r\n            { x: -50, z: 30, rotation: -0.5 },\r\n            { x: 50, z: -30, rotation: 0.3 },\r\n            { x: -50, z: -30, rotation: -0.3 },\r\n            { x: 30, z: 50, rotation: 1.2 },\r\n            { x: -30, z: 50, rotation: -1.2 },\r\n            { x: 30, z: -50, rotation: 0.8 },\r\n            { x: -30, z: -50, rotation: -0.8 },\r\n        ];\r\n        \r\n        coverPositions.forEach((pos) => {\r\n            const group = new THREE.Group();\r\n            \r\n            const frontGeo = new THREE.BoxGeometry(4, 1.2, 0.8);\r\n            const frontMesh = new THREE.Mesh(frontGeo, sandbagMaterial);\r\n            frontMesh.position.set(0, 0.6, 0);\r\n            group.add(frontMesh);\r\n            this.objects.push(frontMesh);\r\n            \r\n            const leftGeo = new THREE.BoxGeometry(0.8, 1, 2);\r\n            const leftMesh = new THREE.Mesh(leftGeo, sandbagMaterial);\r\n            leftMesh.position.set(-1.8, 0.5, 1.2);\r\n            group.add(leftMesh);\r\n            this.objects.push(leftMesh);\r\n            \r\n            const rightMesh = new THREE.Mesh(leftGeo, sandbagMaterial);\r\n            rightMesh.position.set(1.8, 0.5, 1.2);\r\n            group.add(rightMesh);\r\n            this.objects.push(rightMesh);\r\n            \r\n            const groundH = this.getTerrainHeight(pos.x, pos.z);\r\n            if (groundH < EnvironmentConfig.water.level + 0.5) return;\r\n\r\n            group.position.set(pos.x, groundH - 0.2, pos.z);\r\n            group.rotation.y = pos.rotation;\r\n            \r\n            group.traverse((child) => {\r\n                if (child instanceof THREE.Mesh) {\r\n                    child.castShadow = true;\r\n                    child.receiveShadow = true;\r\n                    child.userData = { isCover: true };\r\n                }\r\n            });\r\n            \r\n            this.scene.add(group);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 创建掩体物体 (额外的战术掩护)\r\n     */\r\n    public createCoverObjects() {\r\n        const barrelGeo = new THREE.CylinderGeometry(0.6, 0.6, 1.2, 12);\r\n        const barrelMaterial = LevelMaterials.createBarrelMaterial();\r\n        \r\n        const barrelPositions = [\r\n            { x: 25, z: 10 },\r\n            { x: -25, z: 10 },\r\n            { x: 25, z: -10 },\r\n            { x: -25, z: -10 },\r\n            { x: 10, z: 25 },\r\n            { x: -10, z: 25 },\r\n            { x: 10, z: -25 },\r\n            { x: -10, z: -25 },\r\n            { x: 55, z: 55 },\r\n            { x: -55, z: 55 },\r\n            { x: 55, z: -55 },\r\n            { x: -55, z: -55 },\r\n            { x: 65, z: 0 },\r\n            { x: -65, z: 0 },\r\n            { x: 0, z: 65 },\r\n            { x: 0, z: -65 },\r\n        ];\r\n        \r\n        const embedDepth = 0.3;\r\n        \r\n        barrelPositions.forEach((pos, index) => {\r\n            const groundY = this.getTerrainHeight(pos.x, pos.z);\r\n            if (groundY < EnvironmentConfig.water.level + 0.5) return;\r\n\r\n            const barrel = new THREE.Mesh(barrelGeo, barrelMaterial);\r\n            barrel.position.set(pos.x, groundY + 0.6 - embedDepth, pos.z);\r\n            \r\n            barrel.rotation.y = index * 0.7;\r\n            barrel.castShadow = true;\r\n            barrel.receiveShadow = true;\r\n            barrel.userData = { isBarrel: true };\r\n            \r\n            this.scene.add(barrel);\r\n            this.objects.push(barrel);\r\n            \r\n            if (index % 3 === 0) {\r\n                const fallenBarrel = new THREE.Mesh(barrelGeo, barrelMaterial);\r\n                const offset = 1.0;\r\n                const fallenX = pos.x + offset;\r\n                const fallenZ = pos.z + 0.5;\r\n                const fallenGroundY = this.getTerrainHeight(fallenX, fallenZ);\r\n                 \r\n                fallenBarrel.position.set(fallenX, fallenGroundY + 0.6 - embedDepth, fallenZ);\r\n                fallenBarrel.rotation.z = Math.PI / 2;\r\n                fallenBarrel.rotation.y = index * 0.3;\r\n                fallenBarrel.castShadow = true;\r\n                fallenBarrel.receiveShadow = true;\r\n                \r\n                this.scene.add(fallenBarrel);\r\n                this.objects.push(fallenBarrel);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 创建楼梯 (多处)\r\n     */\r\n    public createStairs() {\r\n        const stepHeight = 0.5;\r\n        const stepDepth = 1.0;\r\n        const stepWidth = 4.0;\r\n        const numSteps = 8;\r\n        \r\n        const stairConfigs = [\r\n            { startX: 20, startZ: -5, rotation: 0 },\r\n            { startX: -20, startZ: 5, rotation: Math.PI },\r\n            { startX: 45, startZ: 30, rotation: Math.PI / 2 },\r\n            { startX: -45, startZ: -30, rotation: -Math.PI / 2 },\r\n        ];\r\n        \r\n        stairConfigs.forEach((config, configIndex) => {\r\n            const group = new THREE.Group();\r\n            \r\n            const groundY = this.getTerrainHeight(config.startX, config.startZ);\r\n            \r\n            for (let i = 0; i < numSteps; i++) {\r\n                const currentHeight = stepHeight * (i + 1);\r\n                const baseDepth = 4.0;\r\n                \r\n                const geo = new THREE.BoxGeometry(stepWidth, currentHeight + baseDepth, stepDepth);\r\n                const material = LevelMaterials.createStairMaterial();\r\n                \r\n                const meshY = currentHeight / 2 - baseDepth / 2;\r\n                \r\n                const mesh = new THREE.Mesh(geo, material);\r\n                mesh.position.set(0, meshY, i * stepDepth);\r\n                mesh.castShadow = true;\r\n                mesh.receiveShadow = true;\r\n                mesh.userData = { isStair: true };\r\n                \r\n                group.add(mesh);\r\n                this.objects.push(mesh);\r\n            }\r\n\r\n            const platformWidth = 6;\r\n            const platformDepth = 6;\r\n            const platformHeight = stepHeight * numSteps;\r\n            const baseDepth = 4.0;\r\n            \r\n            const platformGeo = new THREE.BoxGeometry(platformWidth, platformHeight + baseDepth, platformDepth);\r\n            const platformMaterial = LevelMaterials.createStairMaterial();\r\n            const platformMesh = new THREE.Mesh(platformGeo, platformMaterial);\r\n            \r\n            const platformY = platformHeight / 2 - baseDepth / 2;\r\n            \r\n            group.position.set(config.startX, groundY, config.startZ);\r\n            group.rotation.y = config.rotation;\r\n            \r\n            platformMesh.position.set(0, platformY, (numSteps * stepDepth) + platformDepth/2 - stepDepth/2);\r\n            platformMesh.castShadow = true;\r\n            platformMesh.receiveShadow = true;\r\n            // IMPORTANT:\r\n            // PlayerController ignores horizontal collisions with objects marked `isGround`.\r\n            // The stair platform is a thick volume; if we mark it as ground, the player can pass through\r\n            // it from the sides/back. Mark as stair/platform so it's walkable on top but blocks sides.\r\n            platformMesh.userData = { isStair: true, isPlatform: true };\r\n            \r\n            group.add(platformMesh);\r\n            this.objects.push(platformMesh);\r\n\r\n            this.scene.add(group);\r\n\r\n            const stairBottom = new THREE.Object3D();\r\n            const bottomOffset = new THREE.Vector3(0, 0, -2.0).applyAxisAngle(new THREE.Vector3(0, 1, 0), config.rotation);\r\n            \r\n            const bottomX = config.startX + bottomOffset.x;\r\n            const bottomZ = config.startZ + bottomOffset.z;\r\n            const bottomY = this.getTerrainHeight(bottomX, bottomZ);\r\n            \r\n            stairBottom.position.set(bottomX, bottomY + 0.5, bottomZ);\r\n            stairBottom.userData = { isWayPoint: true, type: 'stair_bottom', id: configIndex + 1 };\r\n            this.objects.push(stairBottom);\r\n\r\n            const stairTop = new THREE.Object3D();\r\n            const topLocalZ = (numSteps * stepDepth) + platformDepth/2; \r\n            const topOffset = new THREE.Vector3(0, 0, topLocalZ).applyAxisAngle(new THREE.Vector3(0, 1, 0), config.rotation);\r\n            \r\n            const topX = config.startX + topOffset.x;\r\n            const topZ = config.startZ + topOffset.z;\r\n            const topY = groundY + platformHeight;\r\n            \r\n            stairTop.position.set(topX, topY + 0.5, topZ);\r\n            stairTop.userData = { isWayPoint: true, type: 'stair_top', id: configIndex + 1 };\r\n            this.objects.push(stairTop);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 创建天空盒\r\n     */\r\n    public createSkybox() {\r\n        const skyRadius = MapConfig.size * 1.5;\r\n        const skyGeo = new THREE.SphereGeometry(skyRadius, 32, 32);\r\n        const skyMaterial = LevelMaterials.createSkyMaterial();\r\n        \r\n        const sky = new THREE.Mesh(skyGeo, skyMaterial);\r\n        sky.userData = { isSkybox: true };\r\n        this.scene.add(sky);\r\n    }\r\n\r\n    /**\r\n     * 创建大气效果\r\n     */\r\n    public createAtmosphere() {\r\n        this.createDustParticles();\r\n    }\r\n\r\n    /**\r\n     * 创建环境灰尘粒子\r\n     */\r\n    public createDustParticles() {\r\n        const particleCount = 500;\r\n        const mapSize = MapConfig.size;\r\n        const positions = new Float32Array(particleCount * 3);\r\n        const sizes = new Float32Array(particleCount);\r\n        \r\n        for (let i = 0; i < particleCount; i++) {\r\n            positions[i * 3] = (Math.random() - 0.5) * mapSize;\r\n            positions[i * 3 + 1] = Math.random() * 15;\r\n            positions[i * 3 + 2] = (Math.random() - 0.5) * mapSize;\r\n            sizes[i] = Math.random() * 0.15 + 0.03;\r\n        }\r\n        \r\n        const geometry = new THREE.BufferGeometry();\r\n        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\r\n        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));\r\n        \r\n        const material = new THREE.PointsMaterial({\r\n            color: 0xffffff,\r\n            size: 0.08,\r\n            transparent: true,\r\n            opacity: 0.25,\r\n            depthWrite: false\r\n        });\r\n        \r\n        const particles = new THREE.Points(geometry, material);\r\n        particles.userData = { isDust: true };\r\n        this.scene.add(particles);\r\n    }\r\n}","usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\level\\GrassSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'halfSize' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":227,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":227,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from 'three';\r\nimport { createGrassMaterial } from '../shaders/GrassTSL';\r\nimport { EnvironmentConfig, MapConfig } from '../core/GameConfig';\r\n\r\n/**\r\n * 草丛系统 - 管理多种地被植物\r\n * 使用 Chunk (分块) + InstancedMesh 进行性能优化\r\n */\r\nexport class GrassSystem {\r\n    private scene: THREE.Scene;\r\n    // 存储所有分块产生的 Mesh，用于清理\r\n    private chunkMeshes: THREE.InstancedMesh[] = []; \r\n    private dummy = new THREE.Object3D();\r\n    \r\n    // 草的类型定义 (几何体、材质、配置)\r\n    private grassTypes: Array<{\r\n        id: string;\r\n        geometry: THREE.BufferGeometry;\r\n        material: any;\r\n        baseCount: number; // 原始配置的数量 (基于小地图)\r\n        scaleRange: { min: number, max: number };\r\n        colorBase: THREE.Color;\r\n        colorTip: THREE.Color;\r\n    }> = [];\r\n\r\n    constructor(scene: THREE.Scene) {\r\n        this.scene = scene;\r\n        this.initGrassTypes();\r\n    }\r\n    \r\n    private initGrassTypes() {\r\n        // 1. 高草 (Tall Grass)\r\n        const tall = EnvironmentConfig.grass.tall;\r\n        const tallGeo = this.createMultipleBladeGeometry(tall.height, tall.width, tall.bladeCount);\r\n        const tallMat = createGrassMaterial(new THREE.Color(tall.colorBase), new THREE.Color(tall.colorTip));\r\n        \r\n        this.grassTypes.push({\r\n            id: 'tall',\r\n            geometry: tallGeo,\r\n            material: tallMat,\r\n            baseCount: tall.count,\r\n            scaleRange: tall.scale,\r\n            colorBase: new THREE.Color(tall.colorBase),\r\n            colorTip: new THREE.Color(tall.colorTip)\r\n        });\r\n        \r\n        // 2. 灌木丛 (Shrub)\r\n        const shrub = EnvironmentConfig.grass.shrub;\r\n        const shrubGeo = this.createBushGeometry();\r\n        const shrubMat = createGrassMaterial(new THREE.Color(shrub.colorBase), new THREE.Color(shrub.colorTip));\r\n        \r\n        this.grassTypes.push({\r\n            id: 'shrub',\r\n            geometry: shrubGeo,\r\n            material: shrubMat,\r\n            baseCount: shrub.count,\r\n            scaleRange: shrub.scale,\r\n            colorBase: new THREE.Color(shrub.colorBase),\r\n            colorTip: new THREE.Color(shrub.colorTip)\r\n        });\r\n        \r\n        // 3. 枯草 (Dry Grass)\r\n        const dry = EnvironmentConfig.grass.dry;\r\n        const dryGeo = this.createMultipleBladeGeometry(dry.height, dry.width, dry.bladeCount);\r\n        const dryMat = createGrassMaterial(new THREE.Color(dry.colorBase), new THREE.Color(dry.colorTip));\r\n        \r\n        this.grassTypes.push({\r\n            id: 'dry',\r\n            geometry: dryGeo,\r\n            material: dryMat,\r\n            baseCount: dry.count,\r\n            scaleRange: dry.scale,\r\n            colorBase: new THREE.Color(dry.colorBase),\r\n            colorTip: new THREE.Color(dry.colorTip)\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 放置草丛 (Chunked)\r\n     */\r\n    public placeGrass(\r\n        mapSize: number, \r\n        getHeightAt: (x: number, z: number) => number,\r\n        excludeAreas: Array<{x: number, z: number, radius: number}> = []\r\n    ) {\r\n        this.dispose();\r\n\r\n        const chunkSize = MapConfig.chunkSize;\r\n        const chunksPerRow = Math.ceil(mapSize / chunkSize);\r\n        const halfSize = mapSize / 2;\r\n        \r\n        // 配置中的 count 代表“全图总量”（小地图时代的经验值）。\r\n        // 在大地图 + Chunk 方案下，如果仍按“每 chunk”生成会导致实例数爆炸。\r\n        // 这里将总量按有效 chunk 数均摊，保证视觉密度合理且性能可控。\r\n        const countMultiplier = 1.0;\r\n\r\n        // 性能优化：严格限制生成范围，仅在岛屿上生成\r\n        const maxGrassDist = MapConfig.boundaryRadius + 50;\r\n        const maxGrassDistSq = (maxGrassDist + chunkSize / 2) * (maxGrassDist + chunkSize / 2);\r\n\r\n        // Low-frequency macro noise (0..1) to create natural \"patches\": dense areas + sparse clearings.\r\n        const hash2 = (x: number, z: number) => {\r\n            const s = Math.sin(x * 12.9898 + z * 78.233) * 43758.5453;\r\n            return s - Math.floor(s);\r\n        };\r\n        const macroNoise = (x: number, z: number) => {\r\n            const s1 = 0.0012;\r\n            const s2 = 0.0027;\r\n            const s3 = 0.006;\r\n            let n = 0;\r\n            n += (Math.sin(x * s1) * Math.sin(z * s1) + 1) * 0.5;\r\n            n += (Math.sin(x * s2 + 1.7) * Math.sin(z * s2 + 2.1) + 1) * 0.5 * 0.6;\r\n            n += (Math.sin(x * s3 + 3.9) * Math.sin(z * s3 + 4.2) + 1) * 0.5 * 0.25;\r\n            // jitter to break symmetry\r\n            n = n * 0.85 + hash2(x * 0.2, z * 0.2) * 0.15;\r\n            return Math.min(1, Math.max(0, n / (1 + 0.6 + 0.25)));\r\n        };\r\n\r\n        // 预先计算有效 chunks（中心点在岛屿范围内）+ 权重（用于非均匀分布）\r\n        const activeChunks: Array<{ cx: number; cz: number; weight: number }> = [];\r\n        let weightSum = 0;\r\n\r\n        const distCfg = EnvironmentConfig.grass.distribution;\r\n        const wCfg = distCfg.macroWeight;\r\n        const shoreCfg = distCfg.shoreFade;\r\n        for (let x = 0; x < chunksPerRow; x++) {\r\n            for (let z = 0; z < chunksPerRow; z++) {\r\n                const chunkCX = (x * chunkSize) - halfSize + chunkSize / 2;\r\n                const chunkCZ = (z * chunkSize) - halfSize + chunkSize / 2;\r\n                if (chunkCX * chunkCX + chunkCZ * chunkCZ <= maxGrassDistSq) {\r\n                    const d = Math.sqrt(chunkCX * chunkCX + chunkCZ * chunkCZ);\r\n                    // slightly reduce density near shoreline to create more believable gradients\r\n                    const shoreFade = Math.min(1, Math.max(0, 1 - (d - shoreCfg.startDistance) / Math.max(1, (MapConfig.boundaryRadius - shoreCfg.startDistance))));\r\n                    const m = macroNoise(chunkCX, chunkCZ);\r\n                    // Strong contrast: push most instances into dense patches (forest-floor look).\r\n                    // This does NOT increase total counts; it reallocates the budget across chunks.\r\n                    const w = (wCfg.base + Math.pow(m, wCfg.exponent) * wCfg.amplitude) * (shoreCfg.min + shoreCfg.max * shoreFade);\r\n                    activeChunks.push({ cx: chunkCX, cz: chunkCZ, weight: w });\r\n                    weightSum += w;\r\n                }\r\n            }\r\n        }\r\n\r\n        const activeChunkCount = Math.max(1, activeChunks.length);\r\n        console.log(\r\n            `Generating Grass: Map=${mapSize}, Chunk=${chunkSize}, ActiveChunks=${activeChunkCount}, Multiplier=${countMultiplier}`\r\n        );\r\n\r\n        // 计算每个 chunk 的目标数量：按 macro 权重分配（非均匀），同时尽量保持总量不变。\r\n        // perChunkCountsByChunk[i] = Map<typeId, count>\r\n        const perChunkCountsByChunk: Array<Map<string, number>> = [];\r\n        const totalsByType = new Map<string, number>();\r\n        for (const type of this.grassTypes) {\r\n            totalsByType.set(type.id, Math.max(0, Math.floor(type.baseCount * countMultiplier)));\r\n        }\r\n\r\n        for (let i = 0; i < activeChunks.length; i++) {\r\n            perChunkCountsByChunk.push(new Map());\r\n        }\r\n\r\n        for (const type of this.grassTypes) {\r\n            const total = totalsByType.get(type.id) ?? 0;\r\n            if (total <= 0) continue;\r\n\r\n            // First pass: floor allocation\r\n            let allocated = 0;\r\n            const remainders: Array<{ i: number; frac: number }> = [];\r\n            for (let i = 0; i < activeChunks.length; i++) {\r\n                const exact = (total * (activeChunks[i].weight / Math.max(1e-6, weightSum)));\r\n                const flo = Math.max(0, Math.floor(exact));\r\n                perChunkCountsByChunk[i].set(type.id, flo);\r\n                allocated += flo;\r\n                remainders.push({ i, frac: exact - flo });\r\n            }\r\n\r\n            // Second pass: distribute remainder to highest fractional weights\r\n            let remaining = total - allocated;\r\n            remainders.sort((a, b) => b.frac - a.frac);\r\n            for (let k = 0; k < remainders.length && remaining > 0; k++) {\r\n                const idx = remainders[k].i;\r\n                perChunkCountsByChunk[idx].set(type.id, (perChunkCountsByChunk[idx].get(type.id) ?? 0) + 1);\r\n                remaining--;\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < activeChunks.length; i++) {\r\n            const c = activeChunks[i];\r\n            const m = macroNoise(c.cx, c.cz);\r\n            // 0..1 with extra emphasis on the top end.\r\n            const dfCfg = distCfg.denseFactor;\r\n            const denseFactor = Math.pow(\r\n                Math.min(1, Math.max(0, (m - dfCfg.start) / Math.max(1e-6, dfCfg.range))),\r\n                dfCfg.power\r\n            );\r\n            this.generateChunk(c.cx, c.cz, chunkSize, perChunkCountsByChunk[i], getHeightAt, excludeAreas, denseFactor);\r\n        }\r\n    }\r\n    \r\n    private generateChunk(\r\n        cx: number, cz: number, size: number, \r\n        perChunkCounts: Map<string, number>,\r\n        getHeightAt: (x: number, z: number) => number,\r\n        excludeAreas: any[],\r\n        denseFactor: number = 0\r\n    ) {\r\n        // 对每种草类型生成一个 Mesh\r\n        this.grassTypes.forEach(type => {\r\n            const targetCount = perChunkCounts.get(type.id) ?? 0;\r\n            if (targetCount <= 0) return;\r\n\r\n            // 由于噪声/排除区/水位会剔除大量候选点，如果仅尝试 targetCount 次会导致实际生成很稀疏。\r\n            // 这里对候选点做 oversample，并在达到目标数量后提前停止。\r\n            const oversample = 3.0;\r\n            const attemptCount = Math.max(targetCount, Math.floor(targetCount * oversample));\r\n\r\n            const mesh = new THREE.InstancedMesh(type.geometry, type.material, attemptCount);\r\n            // 草投射阴影代价很大（尤其在 WebGPU 阴影 pass），且视觉收益有限。\r\n            // 保留 receiveShadow 让草与环境融合，但禁用 castShadow。\r\n            mesh.castShadow = false;\r\n            mesh.receiveShadow = true;\r\n            // 标记 + 位置缓存（用于近战/镰刀快速割草，避免昂贵的 InstancedMesh raycast）\r\n            // grassPositions: [x,y,z] * instanceCount (world space)\r\n            const grassPositions = new Float32Array(attemptCount * 3);\r\n            mesh.userData = { isGrass: true, grassPositions, chunkCenterX: cx, chunkCenterZ: cz };\r\n            \r\n            let validCount = 0;\r\n            const halfSize = size / 2;\r\n            \r\n            // 预先缓存噪声参数以减少对象访问开销\r\n            const noiseScale = EnvironmentConfig.grass.noise.scale;\r\n            const noiseThreshold = EnvironmentConfig.grass.noise.threshold;\r\n            // Dense chunks accept more candidates; sparse chunks accept fewer.\r\n            // Keeps total budget stable (counts are allocated above), but increases visual contrast.\r\n            const tCfg = EnvironmentConfig.grass.distribution.microThresholdShift;\r\n            const thresholdShift = (1 - denseFactor) * tCfg.sparseBoost - denseFactor * tCfg.denseReduce;\r\n            const effectiveThreshold = Math.min(0.98, Math.max(0.02, noiseThreshold + thresholdShift));\r\n            \r\n            for (let i = 0; i < attemptCount; i++) {\r\n                const rx = (Math.random() - 0.5) * size;\r\n                const rz = (Math.random() - 0.5) * size;\r\n                const wx = cx + rx;\r\n                const wz = cz + rz;\r\n\r\n                // --- 1. 密度噪声剔除 (Clustering) ---\r\n                // 使用简单的正弦波叠加模拟噪声 (必须快速)\r\n                // 不同类型的草可以使用稍微不同的偏移，避免所有草长在完全一样的位置\r\n                const typeOffset = type.id === 'dry' ? 100 : 0;\r\n                let n = Math.sin((wx + typeOffset) * noiseScale) * Math.sin((wz + typeOffset) * noiseScale);\r\n                n += Math.sin(wx * noiseScale * 2.3) * Math.sin(wz * noiseScale * 2.3) * 0.5;\r\n                // 归一化后剔除\r\n                if (((n/1.5 + 1) * 0.5) < effectiveThreshold + (Math.random() * 0.15 - 0.075)) {\r\n                    continue;\r\n                }\r\n                \r\n                // 排除检查\r\n                 // 检查排除区域 (稍微宽松一点，草可以靠近一点路)\r\n                 let valid = true;\r\n                 for (const area of excludeAreas) {\r\n                     const dx = wx - area.x;\r\n                     const dz = wz - area.z;\r\n                     if (dx * dx + dz * dz < (area.radius * 0.8) ** 2) {\r\n                         valid = false;\r\n                         break;\r\n                     }\r\n                 }\r\n                 if (!valid) continue;\r\n                 \r\n                 const y = getHeightAt(wx, wz);\r\n                 // 水位检查\r\n                 if (y < EnvironmentConfig.water.level + 0.5) continue;\r\n\r\n                 // cache world-space position for fast queries\r\n                 const pi = validCount * 3;\r\n                 grassPositions[pi] = wx;\r\n                 grassPositions[pi + 1] = y;\r\n                 grassPositions[pi + 2] = wz;\r\n                 \r\n                 this.dummy.position.set(wx, y, wz);\r\n                 this.dummy.rotation.set(0, Math.random() * Math.PI * 2, 0);\r\n                 \r\n                 const s = type.scaleRange.min + Math.random() * (type.scaleRange.max - type.scaleRange.min);\r\n                 this.dummy.scale.set(s, s, s);\r\n                 this.dummy.updateMatrix();\r\n                 \r\n                 mesh.setMatrixAt(validCount, this.dummy.matrix);\r\n                 validCount++;\r\n\r\n                 // 达到目标密度就停止，避免无意义的额外采样\r\n                 if (validCount >= targetCount) break;\r\n            }\r\n            \r\n            if (validCount > 0) {\r\n                mesh.count = validCount;\r\n                mesh.instanceMatrix.needsUpdate = true;\r\n\r\n                // shrink cached positions to valid range\r\n                mesh.userData.grassPositions = (mesh.userData.grassPositions as Float32Array).subarray(0, validCount * 3);\r\n                \r\n                // Culling\r\n                mesh.computeBoundingSphere();\r\n                \r\n                this.scene.add(mesh);\r\n                this.chunkMeshes.push(mesh);\r\n            } else {\r\n                mesh.dispose();\r\n            }\r\n        });\r\n    }\r\n    \r\n    public dispose() {\r\n        this.chunkMeshes.forEach(m => {\r\n            this.scene.remove(m);\r\n            m.dispose();\r\n        });\r\n        this.chunkMeshes = [];\r\n    }\r\n\r\n    /**\r\n     * 生成复杂的单株草丛几何体 (由多根草叶组成)\r\n     */\r\n    private createMultipleBladeGeometry(height: number, width: number, bladeCount: number): THREE.BufferGeometry {\r\n        const geometries: THREE.BufferGeometry[] = [];\r\n        \r\n        for (let i = 0; i < bladeCount; i++) {\r\n            // 每根草叶高度稍微随机\r\n            const h = height * (0.8 + Math.random() * 0.4);\r\n            \r\n            // 使用细分平面作为草叶，方便风吹弯曲\r\n            // widthSegments=1, heightSegments=4\r\n            // 修正：确保顶部在 +y\r\n            const geometry = new THREE.PlaneGeometry(width, h, 1, 4);\r\n            \r\n            // 底部对齐 (PlaneGeometry 默认中心在 0,0,0)\r\n            geometry.translate(0, h / 2, 0); \r\n            \r\n            // 顶点操作：顶部变窄 + 弯曲\r\n            const pos = geometry.attributes.position;\r\n            for(let j=0; j<pos.count; j++) {\r\n                const y = pos.getY(j);\r\n                const t = y / h; // 0 (bottom) to 1 (top)\r\n                \r\n                // 宽度收缩\r\n                const x = pos.getX(j);\r\n                const scale = 1.0 - Math.pow(t, 2) * 0.9;\r\n                pos.setX(j, x * scale);\r\n                \r\n                // 向后弯曲\r\n                const curve = Math.pow(t, 2) * 0.2; \r\n                pos.setZ(j, pos.getZ(j) - curve);\r\n            }\r\n            geometry.computeVertexNormals();\r\n            \r\n            // 随机向外倾斜\r\n            const tilt = Math.random() * 0.3 + 0.1; \r\n            geometry.rotateX(tilt); \r\n            \r\n            // 随机偏移中心\r\n            const offset = 0.1;\r\n            geometry.translate(\r\n                (Math.random() - 0.5) * offset,\r\n                0,\r\n                (Math.random() - 0.5) * offset\r\n            );\r\n            \r\n            // 旋转分布\r\n            const angle = (i / bladeCount) * Math.PI * 2 + (Math.random() - 0.5);\r\n            geometry.rotateY(angle);\r\n            \r\n            geometries.push(geometry);\r\n        }\r\n        \r\n        return this.mergeGeometries(geometries);\r\n    }\r\n    \r\n    /**\r\n     * 生成灌木几何体 (多个小平面球状分布)\r\n     */\r\n    private createBushGeometry(): THREE.BufferGeometry {\r\n        const geometries: THREE.BufferGeometry[] = [];\r\n        const config = EnvironmentConfig.grass.shrub;\r\n        const count = config.segments ?? 8; \r\n        \r\n        for(let i=0; i<count; i++) {\r\n            const w = config.width ?? 0.8;\r\n            const h = config.height ?? 0.7;\r\n            const geo = new THREE.PlaneGeometry(w, h, 1, 2);\r\n            geo.translate(0, h/2, 0);\r\n            \r\n            // 随机旋转\r\n            geo.rotateY((Math.PI * 2 * i) / count + Math.random() * 0.5);\r\n            geo.rotateX((Math.random() - 0.5) * 0.5); \r\n            \r\n            // 随机中心偏移\r\n            geo.translate(\r\n                 (Math.random() - 0.5) * 0.3,\r\n                 (Math.random() - 0.5) * 0.1,\r\n                 (Math.random() - 0.5) * 0.3\r\n            );\r\n            \r\n            geometries.push(geo);\r\n        }\r\n        return this.mergeGeometries(geometries);\r\n    }\r\n    \r\n    private mergeGeometries(geos: THREE.BufferGeometry[]): THREE.BufferGeometry {\r\n        const positions: number[] = [];\r\n        const normals: number[] = [];\r\n        const uvs: number[] = [];\r\n        const indices: number[] = [];\r\n        let offset = 0;\r\n        \r\n        geos.forEach(g => {\r\n            const pos = g.attributes.position;\r\n            const norm = g.attributes.normal;\r\n            const uv = g.attributes.uv;\r\n            const idx = g.index;\r\n            \r\n            for(let i=0; i<pos.count; i++) {\r\n                positions.push(pos.getX(i), pos.getY(i), pos.getZ(i));\r\n                normals.push(norm.getX(i), norm.getY(i), norm.getZ(i));\r\n                uvs.push(uv.getX(i), uv.getY(i));\r\n            }\r\n            \r\n            if(idx) {\r\n                for(let i=0; i<idx.count; i++) {\r\n                    indices.push(idx.getX(i) + offset);\r\n                }\r\n            } else {\r\n                for(let i=0; i<pos.count; i++) indices.push(i + offset);\r\n            }\r\n            offset += pos.count;\r\n        });\r\n        \r\n        const res = new THREE.BufferGeometry();\r\n        res.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\r\n        res.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));\r\n        res.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));\r\n        res.setIndex(indices);\r\n        return res;\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\level\\Level.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'deltaTime' is defined but never used. Allowed unused args must match /^_/u.","line":68,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":68,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'playerPos' is defined but never used. Allowed unused args must match /^_/u.","line":68,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":68,"endColumn":47}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Level - 使用 TSL 材质增强的关卡系统\r\n * 所有地形材质使用程序化生成的 shader 纹理\r\n * 支持大地图和性能优化\r\n */\r\nimport * as THREE from 'three';\r\nimport { MeshStandardNodeMaterial } from 'three/webgpu';\r\nimport { uniform } from 'three/tsl';\r\nimport { MapConfig, EnvironmentConfig, LevelConfig } from '../core/GameConfig';\r\nimport { TreeSystem } from './TreeSystem';\r\nimport { GrassSystem } from './GrassSystem';\r\nimport { PhysicsSystem } from '../core/PhysicsSystem';\r\nimport { WaterSystem } from './WaterSystem';\r\nimport { EnvironmentSystem } from './EnvironmentSystem';\r\nimport { LevelMaterials } from './LevelMaterials';\r\n\r\nexport class Level {\r\n    private scene: THREE.Scene;\r\n    private objects: THREE.Object3D[];\r\n    private physicsSystem: PhysicsSystem;\r\n    \r\n    // 子系统\r\n    private treeSystem: TreeSystem | null = null;\r\n    private grassSystem: GrassSystem | null = null;\r\n    private waterSystem: WaterSystem | null = null;\r\n    private environmentSystem: EnvironmentSystem | null = null;\r\n    \r\n    // 材质\r\n    private floorMaterial!: MeshStandardNodeMaterial;\r\n    \r\n    // 地形高度图数据\r\n    private terrainHeights: Float32Array | null = null;\r\n    private terrainSegmentSize: number = MapConfig.size / MapConfig.terrainSegments;\r\n    \r\n    // 全局环境 Uniforms\r\n    public rainIntensity = uniform(0); // 0 = 晴天, 1 = 暴雨\r\n\r\n    constructor(scene: THREE.Scene, objects: THREE.Object3D[], physicsSystem: PhysicsSystem) {\r\n        this.scene = scene;\r\n        this.objects = objects;\r\n        this.physicsSystem = physicsSystem;\r\n        \r\n        // 预创建共享材质\r\n        this.floorMaterial = LevelMaterials.createFloorMaterial();\r\n        \r\n        // 1. 创建地板 (地形)\r\n        this.createFloor();\r\n        \r\n        // 2. 初始化环境系统\r\n        this.environmentSystem = new EnvironmentSystem(\r\n            this.scene, \r\n            this.objects, \r\n            (x, z) => this.getTerrainHeight(x, z),\r\n            this.physicsSystem\r\n        );\r\n        \r\n        // 3. 创建环境物体\r\n        this.createEnvironment();\r\n        \r\n        // 4. 创建植被\r\n        this.createVegetation();\r\n        \r\n        // 5. 创建水体\r\n        this.waterSystem = new WaterSystem(this.scene);\r\n        this.waterSystem.createWater(this.rainIntensity);\r\n    }\r\n    \r\n    public update(deltaTime: number, playerPos: THREE.Vector3) {\r\n        // TSL shaders handle animation via global timers.\r\n        // Level systems are currently static at runtime.\r\n    }\r\n\r\n    /**\r\n     * 创建环境物体\r\n     */\r\n    private createEnvironment() {\r\n        if (!this.environmentSystem) return;\r\n\r\n        // 记录环境中新增物体的起始索引\r\n        const startIndex = this.objects.length;\r\n\r\n        // 天空和大气\r\n        this.environmentSystem.createSkybox();\r\n        this.environmentSystem.createAtmosphere();\r\n        \r\n        // 边界墙\r\n        this.environmentSystem.createWalls();\r\n        \r\n        // 障碍物和装饰\r\n        this.environmentSystem.createObstacles();\r\n        \r\n        // 复杂地形特征\r\n        const mapRadius = MapConfig.size / 2;\r\n        this.environmentSystem.createRockFormations(mapRadius);\r\n        this.environmentSystem.createRuins(mapRadius);\r\n        this.environmentSystem.createSandbagCovers(mapRadius);\r\n        this.environmentSystem.createCoverObjects();\r\n        this.environmentSystem.createStairs();\r\n\r\n        // 将新增的环境物体注册到物理系统\r\n        if (this.physicsSystem) {\r\n            for (let i = startIndex; i < this.objects.length; i++) {\r\n                const obj = this.objects[i];\r\n                // 排除不需要物理碰撞的物体 (如路径点)\r\n                if (obj.userData?.isWayPoint) continue;\r\n                // 某些批处理渲染对象会自己注册 per-instance 碰撞体\r\n                if (obj.userData?.noPhysics) continue;\r\n                \r\n                this.physicsSystem.addStaticObject(obj);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * 创建植被\r\n     */\r\n    private createVegetation() {\r\n        this.createTrees();\r\n        this.createGrass();\r\n    }\r\n\r\n    /**\r\n     * 生成树木\r\n     */\r\n    private createTrees() {\r\n        this.treeSystem = new TreeSystem(this.scene);\r\n        \r\n        // 排除区域\r\n        const excludeAreas = [\r\n            { x: 0, z: 0, radius: LevelConfig.safeZoneRadius },\r\n            // 排除其他重要建筑区域...\r\n        ];\r\n        \r\n        this.treeSystem.placeTrees(\r\n            MapConfig.size,\r\n            (x, z) => this.computeNoiseHeight(x, z),\r\n            excludeAreas\r\n        );\r\n    }\r\n\r\n    /**\r\n     * 生成草丛\r\n     */\r\n    private createGrass() {\r\n        this.grassSystem = new GrassSystem(this.scene);\r\n        \r\n        const excludeAreas = [\r\n            { x: 0, z: 0, radius: LevelConfig.safeZoneRadius },\r\n            { x: 30, z: 30, radius: EnvironmentConfig.grass.placement.excludeRadius.default }, \r\n            { x: -30, z: -30, radius: EnvironmentConfig.grass.placement.excludeRadius.default }\r\n        ];\r\n        \r\n        this.grassSystem.placeGrass(\r\n            MapConfig.size,\r\n            (x, z) => this.computeNoiseHeight(x, z),\r\n            excludeAreas\r\n        );\r\n    }\r\n\r\n    /**\r\n     * 创建地板 - 带起伏的地形\r\n     * 使用分块生成 (Chunk System)\r\n     */\r\n    private createFloor() {\r\n        // 全局计算高度图数据 (Truth Data)\r\n        this.initTerrainData();\r\n        \r\n        // 创建分块 (Chunks)\r\n        const chunkSize = MapConfig.chunkSize;\r\n        const totalSize = MapConfig.size;\r\n        const chunksPerRow = Math.ceil(totalSize / chunkSize);\r\n        const segmentPerChunk = Math.floor(MapConfig.terrainSegments / chunksPerRow);\r\n        \r\n        const halfSize = totalSize / 2;\r\n        \r\n        for (let x = 0; x < chunksPerRow; x++) {\r\n            for (let z = 0; z < chunksPerRow; z++) {\r\n                // 当前块的中心位置\r\n                const centerX = (x * chunkSize) - halfSize + (chunkSize / 2);\r\n                const centerZ = (z * chunkSize) - halfSize + (chunkSize / 2);\r\n                \r\n                // 创建该块的几何体\r\n                const geometry = new THREE.PlaneGeometry(\r\n                    chunkSize, \r\n                    chunkSize, \r\n                    segmentPerChunk, \r\n                    segmentPerChunk\r\n                );\r\n                \r\n                // 调整顶点高度 (基于预计算的数据)\r\n                const posAttribute = geometry.attributes.position;\r\n                for (let i = 0; i < posAttribute.count; i++) {\r\n                    // Local position\r\n                    const lx = posAttribute.getX(i);\r\n                    const lz = -posAttribute.getY(i); // PlaneGeometry 是 XY 平面，旋转后 Y 变 -Z\r\n                    \r\n                    // World position (Original unrotated Z = -Y)\r\n                    const wx = centerX + lx;\r\n                    const wz = centerZ + lz;\r\n                    \r\n                    // 获取高度\r\n                    const h = this.getTerrainHeight(wx, wz);\r\n                    \r\n                    // 设置 Z (旋转前的 Z 是高度)\r\n                    posAttribute.setZ(i, h);\r\n                }\r\n                \r\n                geometry.computeVertexNormals();\r\n                \r\n                // 使用 LevelMaterials 提供的地板材质\r\n                const mesh = new THREE.Mesh(geometry, this.floorMaterial);\r\n                mesh.rotation.x = -Math.PI / 2;\r\n                mesh.position.set(centerX, 0, centerZ);\r\n                mesh.receiveShadow = true;\r\n                \r\n                // 标记为地面\r\n                mesh.userData = { isGround: true };\r\n                \r\n                this.scene.add(mesh);\r\n                \r\n                // 注册到物理系统 (如果有)\r\n                // 地形物理碰撞需要特殊处理，因为是变形后的 Plane\r\n                // 简单起见，这里假设 PhysicsSystem 使用射线检测高度，或者 PhysicsSystem 内部自己处理了\r\n                // 如果 PhysicsSystem 需要 Mesh，这里调用\r\n                if (this.physicsSystem) {\r\n                    // PhysicsSystem 应该能够处理这种 Mesh，或者我们不在这里 addGround，\r\n                    // 而是 PhysicsSystem 自己查询 getTerrainHeight\r\n                    // 在目前架构下，PhysicsSystem 可能依赖 objects 列表做简单的检测\r\n                    // 或者 PhysicsSystem 有专门的 terrain 处理\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * 初始化地形高度数据\r\n     */\r\n    private initTerrainData() {\r\n        // 初始化高度图数组 (Rows x Cols)\r\n        const gridSize = MapConfig.terrainSegments + 1;\r\n        this.terrainHeights = new Float32Array(gridSize * gridSize);\r\n        const halfSize = MapConfig.size / 2;\r\n\r\n        for (let iz = 0; iz < gridSize; iz++) {\r\n            for (let ix = 0; ix < gridSize; ix++) {\r\n                const worldX = ix * this.terrainSegmentSize - halfSize;\r\n                const worldZ = iz * this.terrainSegmentSize - halfSize;\r\n                const height = this.computeNoiseHeight(worldX, worldZ);\r\n                this.terrainHeights[iz * gridSize + ix] = height;\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * 计算地形高度 - 多层噪声 (内部计算用)\r\n     */\r\n    private computeNoiseHeight(x: number, z: number): number {\r\n        // 使用更平滑的噪声参数，减少高频抖动\r\n        const scale1 = 0.015;  // 大尺度起伏\r\n        const scale2 = 0.04;  // 中尺度变化\r\n        \r\n        // 中心区域较平坦（玩家出生点附近）\r\n        const distFromCenter = Math.sqrt(x * x + z * z);\r\n        const centerFlatten = Math.max(0.2, Math.min(1, (distFromCenter - 10) / 40));\r\n        \r\n        // 多层正弦噪声模拟 Perlin 噪声\r\n        const noise1 = Math.sin(x * scale1 * 1.1 + 0.5) * Math.cos(z * scale1 * 0.9 + 0.3);\r\n        const noise2 = Math.sin(x * scale2 * 1.3 + 1.2) * Math.cos(z * scale2 * 1.1 + 0.7) * 0.5;\r\n        // 去掉高频噪声 scale3，使地形更平滑，利于物体贴合\r\n        \r\n        const combinedNoise = (noise1 + noise2);\r\n        \r\n        // 应用高度并在中心区域减弱\r\n        let height = combinedNoise * MapConfig.terrainHeight * centerFlatten;\r\n        \r\n        // === 无尽之海边缘处理 (Island Mask) ===\r\n        // 强制离岛屿中心一定距离外的地形下沉到海平面以下\r\n        const islandRadius = MapConfig.boundaryRadius; \r\n        \r\n        // 定义海岸线过渡区域\r\n        // 在达到边界墙 (boundaryRadius) 之前就开始逐渐变为沙滩/浅滩\r\n        // 并在边界墙之后迅速变为深海\r\n        const coastStart = islandRadius - 100; // 离边界还有100米时开始下降\r\n        const coastEnd = islandRadius + 50;    // 边界外50米完全变成深海\r\n        \r\n        if (distFromCenter > coastStart) {\r\n            // 计算过渡因子 (0 = 陆地, 1 = 深海)\r\n            let t = (distFromCenter - coastStart) / (coastEnd - coastStart);\r\n            t = Math.max(0, Math.min(1, t));\r\n            \r\n            // 平滑过渡 (Smoothstep)\r\n            const falloff = t * t * (3 - 2 * t);\r\n            \r\n            // 混合目标: 深海海床\r\n            const seaFloorDepth = MapConfig.waterLevel - 15.0;\r\n            \r\n            // 线性插值当前高度到海床深度\r\n            height = THREE.MathUtils.lerp(height, seaFloorDepth, falloff);\r\n        }\r\n        \r\n        return height;\r\n    }\r\n\r\n    /**\r\n     * 获取地形高度 (外部查询用，基于实际网格插值)\r\n     */\r\n    public getTerrainHeight(x: number, z: number): number {\r\n        // 如果高度图未初始化，回退到原始噪声计算\r\n        if (!this.terrainHeights) {\r\n            return this.computeNoiseHeight(x, z);\r\n        }\r\n\r\n        const halfSize = MapConfig.size / 2;\r\n        const gridSize = MapConfig.terrainSegments + 1;\r\n        \r\n        // 转换到网格坐标 (Float)\r\n        const gx = (x + halfSize) / this.terrainSegmentSize;\r\n        const gz = (z + halfSize) / this.terrainSegmentSize;\r\n        \r\n        // 整数索引\r\n        const ix = Math.floor(gx);\r\n        const iz = Math.floor(gz);\r\n        \r\n        // 边界检查\r\n        if (ix < 0 || ix >= gridSize - 1 || iz < 0 || iz >= gridSize - 1) {\r\n            return this.computeNoiseHeight(x, z); // 超出范围回退\r\n        }\r\n        \r\n        // 小数部分\r\n        const fx = gx - ix;\r\n        const fz = gz - iz;\r\n        \r\n        // 获取四个顶点的高度\r\n        // Row = iz, Col = ix\r\n        const h00 = this.terrainHeights[iz * gridSize + ix];         // Top-Left\r\n        const h10 = this.terrainHeights[iz * gridSize + (ix + 1)];   // Top-Right\r\n        const h01 = this.terrainHeights[(iz + 1) * gridSize + ix];   // Bottom-Left\r\n        const h11 = this.terrainHeights[(iz + 1) * gridSize + (ix + 1)]; // Bottom-Right\r\n        \r\n        // 双线性插值\r\n        // high performance approximate\r\n        const hBottom = (1 - fx) * h00 + fx * h10;\r\n        const hTop = (1 - fx) * h01 + fx * h11;\r\n        \r\n        return (1 - fz) * hBottom + fz * hTop;\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\level\\LevelMaterials.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'min' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from 'three';\r\nimport { MeshStandardNodeMaterial, MeshBasicNodeMaterial } from 'three/webgpu';\r\nimport { \r\n    sin, vec3, mix, float, \r\n    smoothstep, fract, floor, uv,\r\n    sub, max, min, mod, normalLocal, normalize, step, positionWorld, abs, time\r\n} from 'three/tsl';\r\nimport { MapConfig, EnvironmentConfig } from '../core/GameConfig';\r\n\r\nexport class LevelMaterials {\r\n    /**\r\n     * 地板材质 - 自然泥土/草地混合纹理 (增强版)\r\n     */\r\n    public static createFloorMaterial(): MeshStandardNodeMaterial {\r\n        const material = new MeshStandardNodeMaterial({\r\n            side: THREE.DoubleSide,\r\n            roughness: 0.92,\r\n            metalness: 0.0\r\n        });\r\n\r\n        const uvCoord = uv().mul(50); // 更大的纹理缩放\r\n        const worldPos = positionWorld;\r\n        \r\n        // ========== 多层噪声基础 (更复杂的变化) ==========\r\n        // 超大尺度地形变化\r\n        const hugeNoise = sin(uvCoord.x.mul(0.05)).mul(sin(uvCoord.y.mul(0.04))).mul(0.5).add(0.5);\r\n        // 大尺度地形变化\r\n        const largeNoise = sin(uvCoord.x.mul(0.15).add(hugeNoise)).mul(sin(uvCoord.y.mul(0.12))).mul(0.5).add(0.5);\r\n        // 中尺度变化\r\n        const medNoise = sin(uvCoord.x.mul(0.8).add(largeNoise.mul(0.5))).mul(sin(uvCoord.y.mul(0.7))).mul(0.5).add(0.5);\r\n        // 细节噪声\r\n        const fineNoise = sin(uvCoord.x.mul(3.5)).mul(sin(uvCoord.y.mul(4.2))).mul(0.5).add(0.5);\r\n        const microNoise = sin(uvCoord.x.mul(12)).mul(sin(uvCoord.y.mul(11))).mul(0.5).add(0.5);\r\n        // 超细节噪声\r\n        const ultraFineNoise = sin(uvCoord.x.mul(25)).mul(sin(uvCoord.y.mul(28))).mul(0.5).add(0.5);\r\n        \r\n        // ========== 泥土基础色 (更丰富的变化) ==========\r\n        const dirtBase = vec3(0.32, 0.25, 0.18);      // 深棕土\r\n        const dirtLight = vec3(0.52, 0.42, 0.32);     // 浅棕土\r\n        const dirtDark = vec3(0.18, 0.14, 0.1);       // 暗泥\r\n        const dirtRed = vec3(0.4, 0.28, 0.2);         // 红褐土\r\n        const sandColor = vec3(0.65, 0.55, 0.42);     // 沙色\r\n        const clayColor = vec3(0.5, 0.38, 0.28);      // 黏土色\r\n        \r\n        // ========== 草地颜色 (更多层次) ==========\r\n        const grassDark = vec3(0.18, 0.3, 0.12);      // 深草绿\r\n        const grassMid = vec3(0.28, 0.4, 0.18);       // 中草绿\r\n        const grassLight = vec3(0.38, 0.5, 0.25);     // 浅草绿\r\n        const grassDry = vec3(0.5, 0.45, 0.28);       // 枯黄草\r\n        const grassDead = vec3(0.42, 0.38, 0.3);      // 枯死草\r\n        \r\n        // ========== 混合泥土变化 (更自然) ==========\r\n        const dirtVariation = mix(dirtBase, dirtLight, medNoise);\r\n        const dirtWithDark = mix(dirtVariation, dirtDark, fineNoise.mul(0.5));\r\n        const dirtWithRed = mix(dirtWithDark, dirtRed, largeNoise.mul(0.3));\r\n        const dirtWithClay = mix(dirtWithRed, clayColor, hugeNoise.mul(0.25));\r\n        const dirtWithSand = mix(dirtWithClay, sandColor, largeNoise.mul(medNoise).mul(0.35));\r\n        \r\n        // ========== 草地覆盖 (更自然的分布) ==========\r\n        const grassMix1 = mix(grassDark, grassMid, fineNoise);\r\n        const grassMix2 = mix(grassMix1, grassLight, microNoise.mul(0.6));\r\n        const grassWithDry = mix(grassMix2, grassDry, medNoise.mul(0.4));\r\n        const grassWithDead = mix(grassWithDry, grassDead, largeNoise.mul(hugeNoise).mul(0.3));\r\n        \r\n        // 草地分布 - 更自然的斑块状\r\n        const grassPattern1 = sin(uvCoord.x.mul(0.4).add(largeNoise.mul(3)))\r\n            .mul(sin(uvCoord.y.mul(0.5).add(medNoise.mul(2)))).mul(0.5).add(0.5);\r\n        const grassPattern2 = sin(uvCoord.x.mul(0.7).sub(hugeNoise.mul(2)))\r\n            .mul(sin(uvCoord.y.mul(0.6).add(fineNoise))).mul(0.5).add(0.5);\r\n        const grassCombined = grassPattern1.mul(0.6).add(grassPattern2.mul(0.4));\r\n        const grassMask = smoothstep(float(0.3), float(0.7), grassCombined);\r\n        \r\n        // 混合泥土和草地\r\n        const groundColor = mix(dirtWithSand, grassWithDead, grassMask);\r\n        \r\n        // ========== 小石子和碎屑 (更多变化) ==========\r\n        const pebbleNoise1 = sin(uvCoord.x.mul(30)).mul(sin(uvCoord.y.mul(32))).mul(0.5).add(0.5);\r\n        const pebbleNoise2 = sin(uvCoord.x.mul(45).add(1.5)).mul(sin(uvCoord.y.mul(42))).mul(0.5).add(0.5);\r\n        const pebbleMask = step(float(0.9), pebbleNoise1).add(step(float(0.92), pebbleNoise2));\r\n        const pebbleColorDark = vec3(0.35, 0.33, 0.3);\r\n        const pebbleColorLight = vec3(0.55, 0.52, 0.48);\r\n        const pebbleColor = mix(pebbleColorDark, pebbleColorLight, ultraFineNoise);\r\n        const withPebbles = mix(groundColor, pebbleColor, pebbleMask.mul(0.7));\r\n        \r\n        // ========== 裂缝和纹路 ==========\r\n        const crackPattern = sin(uvCoord.x.mul(2.5).add(largeNoise.mul(5)))\r\n            .mul(sin(uvCoord.y.mul(2.8).add(medNoise.mul(4))));\r\n        const crackMask = smoothstep(float(0.85), float(0.95), abs(crackPattern));\r\n        const crackColor = vec3(0.15, 0.12, 0.1);\r\n        const withCracks = mix(withPebbles, crackColor, crackMask.mul(0.4).mul(float(1).sub(grassMask)));\r\n        \r\n        // ========== 路径/踩踏痕迹 (更自然) ==========\r\n        const pathNoise = sin(uvCoord.x.mul(0.06).add(hugeNoise)).mul(0.5).add(0.5);\r\n        const pathWidth = smoothstep(float(0.42), float(0.5), pathNoise).mul(smoothstep(float(0.58), float(0.5), pathNoise));\r\n        const pathColor = vec3(0.4, 0.34, 0.26);\r\n        const withPath = mix(withCracks, pathColor, pathWidth.mul(0.5));\r\n        \r\n        // ========== 微表面变化和污渍 ==========\r\n        const surfaceDetail = microNoise.mul(0.05).sub(0.025);\r\n        const stainNoise = sin(uvCoord.x.mul(1.2)).mul(sin(uvCoord.y.mul(1.5))).mul(0.5).add(0.5);\r\n        const stainMask = smoothstep(float(0.7), float(0.9), stainNoise);\r\n        const stainColor = vec3(0.25, 0.2, 0.15);\r\n        const withStains = mix(withPath, stainColor, stainMask.mul(0.15));\r\n        \r\n        const finalColor = withStains.add(surfaceDetail);\r\n        \r\n        // ========== 水边湿润效果 ==========\r\n        const waterHeight = float(EnvironmentConfig.water.level);\r\n        // 水面以上 1.5 米范围内逐渐变干\r\n        const wetZone = smoothstep(waterHeight.add(1.5), waterHeight.sub(0.2), worldPos.y); \r\n        // 湿润的地面变暗\r\n        const wetColor = finalColor.mul(0.5);\r\n        \r\n        material.colorNode = mix(finalColor, wetColor, wetZone);\r\n        \r\n        // 湿润的地面更光滑\r\n        material.roughnessNode = mix(float(0.92), float(0.3), wetZone);\r\n        \r\n        // ========== 法线变化模拟凹凸 (更强的凹凸) ==========\r\n        // 降低 bump 强度，因为物理地形已经足够丰富\r\n        const bumpScale = float(0.05); \r\n        const bumpX = sin(uvCoord.x.mul(6)).mul(fineNoise).mul(bumpScale)\r\n            .add(sin(uvCoord.x.mul(15)).mul(microNoise).mul(bumpScale.mul(0.5)));\r\n        const bumpZ = sin(uvCoord.y.mul(6)).mul(fineNoise).mul(bumpScale)\r\n            .add(sin(uvCoord.y.mul(15)).mul(microNoise).mul(bumpScale.mul(0.5)));\r\n        // 石子产生更强的凹凸\r\n        const pebbleBump = pebbleMask.mul(0.2);\r\n        const bumpNormal = normalize(normalLocal.add(vec3(bumpX.add(pebbleBump), 0, bumpZ.add(pebbleBump))));\r\n        material.normalNode = bumpNormal;\r\n        \r\n        // ========== 动态粗糙度 (更多变化) ==========\r\n        // 草地更粗糙，路径更光滑，石子最粗糙\r\n        const roughnessBase = mix(float(0.95), float(0.82), grassMask);\r\n        const roughnessWithPath = mix(roughnessBase, float(0.7), pathWidth);\r\n        const roughnessWithPebbles = mix(roughnessWithPath, float(0.98), pebbleMask.mul(0.5));\r\n        material.roughnessNode = roughnessWithPebbles.add(microNoise.mul(0.08));\r\n        \r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * 墙壁材质 - 风化混凝土/砖墙\r\n     */\r\n    public static createWallMaterial(): MeshStandardNodeMaterial {\r\n        const material = new MeshStandardNodeMaterial({\r\n            roughness: 0.9,\r\n            metalness: 0.0\r\n        });\r\n\r\n        const uvCoord = uv();\r\n        \r\n        // ========== 大砖块图案 ==========\r\n        const brickScaleX = float(8);\r\n        const brickScaleY = float(4);\r\n        \r\n        const row = floor(uvCoord.y.mul(brickScaleY));\r\n        const offset = mod(row, float(2)).mul(0.5);\r\n        const adjustedX = uvCoord.x.mul(brickScaleX).add(offset);\r\n        \r\n        const brickX = fract(adjustedX);\r\n        const brickY = fract(uvCoord.y.mul(brickScaleY));\r\n        \r\n        // 砖缝\r\n        const gap = float(0.03);\r\n        const brickMaskX = smoothstep(float(0), gap, brickX)\r\n            .mul(smoothstep(float(1), sub(float(1), gap), brickX));\r\n        const brickMaskY = smoothstep(float(0), gap, brickY)\r\n            .mul(smoothstep(float(1), sub(float(1), gap), brickY));\r\n        const brickMask = brickMaskX.mul(brickMaskY);\r\n        \r\n        // ========== 混凝土/砖块变化纹理 ==========\r\n        const noiseFreq1 = float(20);\r\n        const noiseFreq2 = float(50);\r\n        const noiseFreq3 = float(100);\r\n        \r\n        const noise1 = sin(uvCoord.x.mul(noiseFreq1)).mul(sin(uvCoord.y.mul(noiseFreq1))).mul(0.5).add(0.5);\r\n        const noise2 = sin(uvCoord.x.mul(noiseFreq2)).mul(sin(uvCoord.y.mul(noiseFreq2))).mul(0.5).add(0.5);\r\n        const noise3 = sin(uvCoord.x.mul(noiseFreq3)).mul(sin(uvCoord.y.mul(noiseFreq3))).mul(0.5).add(0.5);\r\n        \r\n        // 砖块颜色变化 (每块砖不同)\r\n        const brickIndex = floor(adjustedX).add(row.mul(50));\r\n        const colorVar1 = sin(brickIndex.mul(43.758)).mul(0.5).add(0.5);\r\n        const colorVar2 = sin(brickIndex.mul(27.619)).mul(0.5).add(0.5);\r\n        \r\n        // ========== 砖块颜色 ==========\r\n        const brickRed = vec3(0.52, 0.35, 0.3);      // 红砖色\r\n        const brickBrown = vec3(0.45, 0.38, 0.32);   // 棕砖色\r\n        const brickGray = vec3(0.42, 0.4, 0.38);     // 灰砖色\r\n        const brickDark = vec3(0.32, 0.28, 0.25);    // 深色砖\r\n        \r\n        // 混合不同砖色\r\n        const brickBase = mix(brickRed, brickBrown, colorVar1);\r\n        const brickMixed = mix(brickBase, brickGray, colorVar2.mul(0.4));\r\n        const brickWithVar = mix(brickMixed, brickDark, noise1.mul(0.25));\r\n        \r\n        // 砖块表面纹理\r\n        const surfaceDetail = noise2.mul(0.06).sub(0.03);\r\n        const microDetail = noise3.mul(0.03).sub(0.015);\r\n        const brickSurface = brickWithVar.add(surfaceDetail).add(microDetail);\r\n        \r\n        // 砖缝颜色\r\n        const mortarColor = vec3(0.55, 0.52, 0.48); // 浅灰色灰浆\r\n        \r\n        // ========== 风化效果 ==========\r\n        // 顶部雨水痕迹\r\n        const rainStreak = sin(uvCoord.x.mul(80)).mul(0.5).add(0.5);\r\n        const rainMask = smoothstep(float(0.85), float(1.0), uvCoord.y).mul(rainStreak);\r\n        const rainDark = vec3(0.25, 0.23, 0.22);\r\n        \r\n        // 底部湿气/污渍\r\n        const bottomDirt = smoothstep(float(0.15), float(0.0), uvCoord.y);\r\n        const dirtColor = vec3(0.28, 0.25, 0.2);\r\n        \r\n        // 随机污渍斑块\r\n        const stainNoise = sin(uvCoord.x.mul(8)).mul(sin(uvCoord.y.mul(6))).mul(0.5).add(0.5);\r\n        const stainMask = smoothstep(float(0.7), float(0.85), stainNoise);\r\n        const stainColor = vec3(0.3, 0.28, 0.25);\r\n        \r\n        // 应用风化\r\n        const brickWeathered = mix(brickSurface, rainDark, rainMask.mul(0.4));\r\n        const brickWithDirt = mix(brickWeathered, dirtColor, bottomDirt.mul(0.35));\r\n        const brickWithStains = mix(brickWithDirt, stainColor, stainMask.mul(0.2));\r\n        \r\n        // ========== 裂缝效果 ==========\r\n        const crackNoise = sin(uvCoord.x.mul(3).add(uvCoord.y.mul(2)))\r\n            .mul(sin(uvCoord.x.mul(7).sub(uvCoord.y.mul(5)))).mul(0.5).add(0.5);\r\n        const crackMask = step(float(0.95), crackNoise);\r\n        const crackColor = vec3(0.15, 0.13, 0.12);\r\n        const withCracks = mix(brickWithStains, crackColor, crackMask.mul(0.8));\r\n        \r\n        // 最终颜色 - 混合砖块和砖缝\r\n        const finalColor = mix(mortarColor, withCracks, brickMask);\r\n        \r\n        material.colorNode = finalColor;\r\n        \r\n        // ========== 法线贴图 - 砖块凹凸 ==========\r\n        const bumpStrength = sub(float(1), brickMask).mul(0.12);\r\n        const crackBump = crackMask.mul(0.1);\r\n        const bumpNormal = normalize(normalLocal.add(vec3(0, bumpStrength.add(crackBump), 0)));\r\n        material.normalNode = bumpNormal;\r\n        \r\n        // 粗糙度变化 - 风化处更粗糙\r\n        const roughnessBase = mix(float(0.92), float(0.82), brickMask);\r\n        const roughnessWeathered = mix(roughnessBase, float(0.98), rainMask.add(bottomDirt).mul(0.5));\r\n        material.roughnessNode = roughnessWeathered;\r\n        \r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * 金属箱子材质 - 工业集装箱/军用储物箱\r\n     */\r\n    public static createMetalCrateMaterial(): MeshStandardNodeMaterial {\r\n        const material = new MeshStandardNodeMaterial({\r\n            roughness: 0.45,\r\n            metalness: 0.85\r\n        });\r\n\r\n        const uvCoord = uv();\r\n        \r\n        // ========== 金属板图案 ==========\r\n        const panelCountX = float(2);\r\n        const panelCountY = float(3);\r\n        const panelX = fract(uvCoord.x.mul(panelCountX));\r\n        const panelY = fract(uvCoord.y.mul(panelCountY));\r\n        \r\n        // 面板边框/加强筋\r\n        const borderWidth = float(0.06);\r\n        const ribWidth = float(0.03);\r\n        \r\n        const borderMaskX = smoothstep(float(0), borderWidth, panelX)\r\n            .mul(smoothstep(float(1), sub(float(1), borderWidth), panelX));\r\n        const borderMaskY = smoothstep(float(0), borderWidth, panelY)\r\n            .mul(smoothstep(float(1), sub(float(1), borderWidth), panelY));\r\n        const panelMask = borderMaskX.mul(borderMaskY);\r\n        \r\n        // 垂直加强筋\r\n        const ribPattern = fract(uvCoord.x.mul(8));\r\n        const ribMask = smoothstep(float(0), ribWidth, ribPattern)\r\n            .mul(smoothstep(ribWidth.mul(2), ribWidth, ribPattern));\r\n        \r\n        // ========== 表面纹理 ==========\r\n        // 细密划痕\r\n        const scratchFreq = float(80);\r\n        const scratch1 = sin(uvCoord.x.mul(scratchFreq).add(uvCoord.y.mul(3)));\r\n        const scratch2 = sin(uvCoord.y.mul(scratchFreq.mul(0.7)).add(uvCoord.x.mul(5)));\r\n        const scratchPattern = max(scratch1, scratch2).mul(0.5).add(0.5);\r\n        const scratchMask = smoothstep(float(0.85), float(0.95), scratchPattern);\r\n        \r\n        // 刷纹\r\n        const brushFreq = float(150);\r\n        const brushPattern = sin(uvCoord.y.mul(brushFreq)).mul(0.5).add(0.5);\r\n        \r\n        // ========== 锈迹和腐蚀 ==========\r\n        const rustNoise1 = sin(uvCoord.x.mul(12)).mul(sin(uvCoord.y.mul(15))).mul(0.5).add(0.5);\r\n        const rustNoise2 = sin(uvCoord.x.mul(25)).mul(sin(uvCoord.y.mul(22))).mul(0.5).add(0.5);\r\n        const rustPattern = rustNoise1.mul(rustNoise2);\r\n        \r\n        // 锈迹集中在边角和底部\r\n        const edgeRust = sub(float(1), panelMask).mul(0.6);\r\n        const bottomRust = smoothstep(float(0.3), float(0.0), uvCoord.y).mul(0.4);\r\n        const rustMask = smoothstep(float(0.25), float(0.5), rustPattern.add(edgeRust).add(bottomRust));\r\n        \r\n        // ========== 油漆剥落 ==========\r\n        const paintChipNoise = sin(uvCoord.x.mul(18)).mul(sin(uvCoord.y.mul(20))).mul(0.5).add(0.5);\r\n        const paintChipMask = step(float(0.88), paintChipNoise);\r\n        \r\n        // ========== 颜色 ==========\r\n        // 军绿色油漆 (主色)\r\n        const paintGreen = vec3(0.28, 0.32, 0.25);\r\n        // 备选: 工业灰蓝\r\n        const paintBlue = vec3(0.3, 0.35, 0.4);\r\n        // 金属原色\r\n        const metalBase = vec3(0.55, 0.53, 0.5);\r\n        // 锈迹颜色\r\n        const rustLight = vec3(0.5, 0.3, 0.18);\r\n        const rustDark = vec3(0.35, 0.2, 0.12);\r\n        // 加强筋/边框\r\n        const borderColor = vec3(0.25, 0.28, 0.22);\r\n        \r\n        // 根据面板位置变化颜色\r\n        const panelIndex = floor(uvCoord.y.mul(panelCountY));\r\n        const colorChoice = sin(panelIndex.mul(12.5)).mul(0.5).add(0.5);\r\n        const paintColor = mix(paintGreen, paintBlue, step(float(0.7), colorChoice));\r\n        \r\n        // 表面带刷纹的油漆\r\n        const paintWithBrush = paintColor.mul(mix(float(0.95), float(1.02), brushPattern));\r\n        \r\n        // 划痕露出底层金属\r\n        const paintWithScratch = mix(paintWithBrush, metalBase, scratchMask.mul(0.5));\r\n        \r\n        // 油漆剥落\r\n        const paintChipped = mix(paintWithScratch, metalBase, paintChipMask.mul(0.8));\r\n        \r\n        // 锈迹\r\n        const rustColor = mix(rustLight, rustDark, rustNoise2);\r\n        const withRust = mix(paintChipped, rustColor, rustMask);\r\n        \r\n        // 边框/加强筋\r\n        const withBorder = mix(withRust, borderColor, sub(float(1), panelMask).mul(0.7));\r\n        const withRibs = mix(withBorder, borderColor.mul(0.9), ribMask.mul(panelMask).mul(0.4));\r\n        \r\n        // ========== 污渍 ==========\r\n        const grime = sin(uvCoord.x.mul(5)).mul(sin(uvCoord.y.mul(4))).mul(0.5).add(0.5);\r\n        const grimeColor = vec3(0.2, 0.18, 0.15);\r\n        const finalColor = mix(withRibs, grimeColor, grime.mul(0.12));\r\n        \r\n        material.colorNode = finalColor;\r\n        \r\n        // ========== 动态粗糙度 ==========\r\n        const roughnessBase = float(0.4);\r\n        const roughnessScratched = mix(roughnessBase, float(0.6), scratchMask);\r\n        const roughnessRusted = mix(roughnessScratched, float(0.9), rustMask);\r\n        material.roughnessNode = roughnessRusted;\r\n        \r\n        // ========== 金属度 ==========\r\n        // 锈迹处金属度降低，油漆处也降低\r\n        const metalnessBase = float(0.85);\r\n        const metalnessPainted = mix(metalnessBase, float(0.1), sub(float(1), scratchMask.add(paintChipMask)));\r\n        const metalnessRusted = mix(metalnessPainted, float(0.15), rustMask);\r\n        material.metalnessNode = metalnessRusted;\r\n        \r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * 混凝土材质 - 风化混凝土块\r\n     */\r\n    public static createConcreteMaterial(): MeshStandardNodeMaterial {\r\n        const material = new MeshStandardNodeMaterial({\r\n            roughness: 0.95,\r\n            metalness: 0.0\r\n        });\r\n\r\n        const uvCoord = uv();\r\n        \r\n        // ========== 多层混凝土噪声 ==========\r\n        const noise1 = sin(uvCoord.x.mul(15)).mul(sin(uvCoord.y.mul(15))).mul(0.5).add(0.5);\r\n        const noise2 = sin(uvCoord.x.mul(35)).mul(sin(uvCoord.y.mul(40))).mul(0.5).add(0.5);\r\n        const noise3 = sin(uvCoord.x.mul(80)).mul(sin(uvCoord.y.mul(75))).mul(0.5).add(0.5);\r\n        const microNoise = sin(uvCoord.x.mul(150)).mul(sin(uvCoord.y.mul(160))).mul(0.5).add(0.5);\r\n        \r\n        // ========== 骨料/石子 ==========\r\n        const aggregateNoise = sin(uvCoord.x.mul(25)).mul(sin(uvCoord.y.mul(28))).mul(0.5).add(0.5);\r\n        const aggregateMask = smoothstep(float(0.65), float(0.75), aggregateNoise);\r\n        const aggregateColor = vec3(0.5, 0.48, 0.45);  // 浅色石子\r\n        const aggregateDark = vec3(0.35, 0.33, 0.3);   // 深色石子\r\n        \r\n        // ========== 基础混凝土颜色 ==========\r\n        const concreteLight = vec3(0.6, 0.58, 0.55);\r\n        const concreteMid = vec3(0.5, 0.48, 0.45);\r\n        const concreteDark = vec3(0.4, 0.38, 0.36);\r\n        \r\n        // 混合基础色\r\n        const baseColor = mix(concreteMid, concreteLight, noise1.mul(0.5));\r\n        const withVariation = mix(baseColor, concreteDark, noise2.mul(0.35));\r\n        \r\n        // 表面纹理\r\n        const surfaceDetail = noise3.mul(0.08).sub(0.04);\r\n        const microDetail = microNoise.mul(0.03).sub(0.015);\r\n        const texturedConcrete = withVariation.add(surfaceDetail).add(microDetail);\r\n        \r\n        // 添加骨料\r\n        const aggregateMixed = mix(aggregateColor, aggregateDark, noise2);\r\n        const withAggregate = mix(texturedConcrete, aggregateMixed, aggregateMask.mul(0.6));\r\n        \r\n        // ========== 风化效果 ==========\r\n        // 水渍/污渍\r\n        const stainNoise = sin(uvCoord.x.mul(6)).mul(sin(uvCoord.y.mul(5))).mul(0.5).add(0.5);\r\n        const stainMask = smoothstep(float(0.6), float(0.8), stainNoise);\r\n        const stainColor = vec3(0.35, 0.32, 0.3);\r\n        const withStains = mix(withAggregate, stainColor, stainMask.mul(0.25));\r\n        \r\n        // 边角磨损 (用 UV 模拟)\r\n        const edgeWear = smoothstep(float(0.05), float(0.0), uvCoord.x)\r\n            .add(smoothstep(float(0.95), float(1.0), uvCoord.x))\r\n            .add(smoothstep(float(0.05), float(0.0), uvCoord.y))\r\n            .add(smoothstep(float(0.95), float(1.0), uvCoord.y));\r\n        const wornColor = vec3(0.55, 0.52, 0.5);\r\n        const withWear = mix(withStains, wornColor, edgeWear.mul(0.3));\r\n        \r\n        // ========== 裂缝 ==========\r\n        const crackNoise = sin(uvCoord.x.mul(2.5).add(uvCoord.y.mul(1.5)))\r\n            .mul(sin(uvCoord.x.mul(5).sub(uvCoord.y.mul(3)))).mul(0.5).add(0.5);\r\n        const crackMask = step(float(0.93), crackNoise);\r\n        const crackColor = vec3(0.2, 0.18, 0.17);\r\n        const finalColor = mix(withWear, crackColor, crackMask.mul(0.7));\r\n        \r\n        material.colorNode = finalColor;\r\n        \r\n        // ========== 法线变化 ==========\r\n        const bumpX = noise2.mul(0.1).sub(0.05);\r\n        const bumpZ = noise3.mul(0.08).sub(0.04);\r\n        const crackBump = crackMask.mul(0.15);\r\n        const bumpNormal = normalize(normalLocal.add(vec3(bumpX, crackBump, bumpZ)));\r\n        material.normalNode = bumpNormal;\r\n        \r\n        // 粗糙度\r\n        const roughnessBase = float(0.9);\r\n        const roughnessWithAggregate = mix(roughnessBase, float(0.7), aggregateMask);\r\n        material.roughnessNode = roughnessWithAggregate;\r\n        \r\n        return material;\r\n    }\r\n    \r\n    /**\r\n     * 岩石材质 - 自然岩石纹理\r\n     */\r\n    public static createRockMaterial(): MeshStandardNodeMaterial {\r\n        const material = new MeshStandardNodeMaterial({\r\n            roughness: 0.95,\r\n            metalness: 0.05\r\n        });\r\n        \r\n        const uvCoord = uv();\r\n        \r\n        // ========== 多层噪声 ==========\r\n        const largeNoise = sin(uvCoord.x.mul(8)).mul(sin(uvCoord.y.mul(7))).mul(0.5).add(0.5);\r\n        const medNoise = sin(uvCoord.x.mul(20)).mul(sin(uvCoord.y.mul(22))).mul(0.5).add(0.5);\r\n        const fineNoise = sin(uvCoord.x.mul(50)).mul(sin(uvCoord.y.mul(55))).mul(0.5).add(0.5);\r\n        const microNoise = sin(uvCoord.x.mul(100)).mul(sin(uvCoord.y.mul(95))).mul(0.5).add(0.5);\r\n        \r\n        // ========== 岩石分层 ==========\r\n        const layerPattern = sin(uvCoord.y.mul(12).add(uvCoord.x.mul(2))).mul(0.5).add(0.5);\r\n        const layerMask = smoothstep(float(0.4), float(0.6), layerPattern);\r\n        \r\n        // ========== 岩石颜色 ==========\r\n        const rockGray = vec3(0.45, 0.43, 0.4);\r\n        const rockBrown = vec3(0.42, 0.38, 0.32);\r\n        const rockDark = vec3(0.3, 0.28, 0.25);\r\n        const rockLight = vec3(0.55, 0.52, 0.48);\r\n        \r\n        // 基础混合\r\n        const baseRock = mix(rockGray, rockBrown, largeNoise);\r\n        const layeredRock = mix(baseRock, rockDark, layerMask.mul(0.4));\r\n        const variedRock = mix(layeredRock, rockLight, medNoise.mul(0.3));\r\n        \r\n        // 表面细节\r\n        const surfaceDetail = fineNoise.mul(0.1).sub(0.05);\r\n        const microDetail = microNoise.mul(0.04).sub(0.02);\r\n        const texturedRock = variedRock.add(surfaceDetail).add(microDetail);\r\n        \r\n        // ========== 苔藓/地衣 ==========\r\n        const mossNoise = sin(uvCoord.x.mul(6)).mul(sin(uvCoord.y.mul(5))).mul(0.5).add(0.5);\r\n        const mossMask = smoothstep(float(0.65), float(0.85), mossNoise.mul(largeNoise));\r\n        const mossColor = vec3(0.25, 0.35, 0.2);\r\n        const withMoss = mix(texturedRock, mossColor, mossMask.mul(0.5));\r\n        \r\n        // ========== 裂隙 ==========\r\n        const crackPattern = sin(uvCoord.x.mul(4).add(uvCoord.y.mul(2)))\r\n            .mul(sin(uvCoord.x.mul(8).sub(uvCoord.y.mul(6)))).mul(0.5).add(0.5);\r\n        const crackMask = step(float(0.92), crackPattern);\r\n        const crackColor = vec3(0.15, 0.13, 0.12);\r\n        const finalColor = mix(withMoss, crackColor, crackMask.mul(0.6));\r\n        \r\n        material.colorNode = finalColor;\r\n        \r\n        // ========== 法线 ==========\r\n        const bumpX = medNoise.mul(0.15).sub(0.075);\r\n        const bumpZ = fineNoise.mul(0.12).sub(0.06);\r\n        const layerBump = layerMask.mul(0.1);\r\n        const bumpNormal = normalize(normalLocal.add(vec3(bumpX, layerBump, bumpZ)));\r\n        material.normalNode = bumpNormal;\r\n        \r\n        // 粗糙度\r\n        const roughnessBase = float(0.92);\r\n        const roughnessWithMoss = mix(roughnessBase, float(0.98), mossMask);\r\n        material.roughnessNode = roughnessWithMoss;\r\n        \r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * 沙袋材质\r\n     */\r\n    public static createSandbagMaterial(): MeshStandardNodeMaterial {\r\n        const material = new MeshStandardNodeMaterial({\r\n            roughness: 0.95,\r\n            metalness: 0.0\r\n        });\r\n        \r\n        const uvCoord = uv();\r\n        \r\n        // 粗麻布纹理\r\n        const weaveFreq = float(40);\r\n        const weave1 = sin(uvCoord.x.mul(weaveFreq)).mul(0.5).add(0.5);\r\n        const weave2 = sin(uvCoord.y.mul(weaveFreq)).mul(0.5).add(0.5);\r\n        const weavePattern = weave1.mul(weave2).mul(0.1);\r\n        \r\n        // 沙袋堆叠纹理\r\n        const bagHeight = float(0.25);\r\n        const bagRow = floor(uvCoord.y.div(bagHeight));\r\n        const bagOffset = mod(bagRow, float(2)).mul(0.3);\r\n        const bagX = fract(uvCoord.x.add(bagOffset).mul(2));\r\n        const bagY = fract(uvCoord.y.div(bagHeight));\r\n        \r\n        // 沙袋边缘\r\n        const bagEdgeX = smoothstep(float(0), float(0.05), bagX)\r\n            .mul(smoothstep(float(1), float(0.95), bagX));\r\n        const bagEdgeY = smoothstep(float(0), float(0.1), bagY)\r\n            .mul(smoothstep(float(1), float(0.9), bagY));\r\n        const bagShape = bagEdgeX.mul(bagEdgeY);\r\n        \r\n        // 沙袋颜色\r\n        const bagColor = vec3(0.65, 0.55, 0.4);\r\n        const seamColor = vec3(0.4, 0.35, 0.25);\r\n        \r\n        const finalColor = mix(seamColor, bagColor.add(weavePattern), bagShape);\r\n        material.colorNode = finalColor;\r\n        \r\n        return material;\r\n    }\r\n    \r\n    /**\r\n     * 油桶材质\r\n     */\r\n    public static createBarrelMaterial(): MeshStandardNodeMaterial {\r\n        const material = new MeshStandardNodeMaterial({\r\n            roughness: 0.5,\r\n            metalness: 0.7\r\n        });\r\n        \r\n        const uvCoord = uv();\r\n        \r\n        // 桶身条纹\r\n        const stripeFreq = float(30);\r\n        const stripes = sin(uvCoord.y.mul(stripeFreq)).mul(0.5).add(0.5);\r\n        const stripeMask = smoothstep(float(0.4), float(0.6), stripes);\r\n        \r\n        // 锈迹\r\n        const rustNoise = sin(uvCoord.x.mul(20).add(uvCoord.y.mul(15)));\r\n        const rustMask = smoothstep(float(0.3), float(0.6), rustNoise).mul(0.4);\r\n        \r\n        // 油桶颜色 (绿色/黄色)\r\n        const barrelColor = vec3(0.2, 0.35, 0.15);\r\n        const stripeColor = vec3(0.6, 0.5, 0.1);\r\n        const rustColor = vec3(0.5, 0.3, 0.15);\r\n        \r\n        let finalColor = mix(barrelColor, stripeColor, stripeMask.mul(0.3));\r\n        finalColor = mix(finalColor, rustColor, rustMask);\r\n        \r\n        material.colorNode = finalColor;\r\n        material.roughnessNode = float(0.4).add(rustMask.mul(0.5));\r\n        material.metalnessNode = float(0.8).sub(rustMask.mul(0.4));\r\n        \r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * 楼梯材质 - 带防滑纹理\r\n     */\r\n    public static createStairMaterial(): MeshStandardNodeMaterial {\r\n        const material = new MeshStandardNodeMaterial({\r\n            roughness: 0.7,\r\n            metalness: 0.2\r\n        });\r\n\r\n        const uvCoord = uv();\r\n        \r\n        // 防滑条纹\r\n        const stripeFreq = float(20);\r\n        const stripes = sin(uvCoord.x.mul(stripeFreq)).mul(0.5).add(0.5);\r\n        const stripeMask = step(float(0.7), stripes);\r\n        \r\n        // 混凝土基础\r\n        const noiseFreq = float(30);\r\n        const noise = sin(uvCoord.x.mul(noiseFreq)).mul(sin(uvCoord.y.mul(noiseFreq))).mul(0.03);\r\n        \r\n        // 颜色\r\n        const baseColor = vec3(0.5, 0.48, 0.45);\r\n        const stripeColor = vec3(0.3, 0.28, 0.25);\r\n        \r\n        const finalColor = mix(baseColor.add(noise), stripeColor, stripeMask.mul(0.3));\r\n        \r\n        material.colorNode = finalColor;\r\n        \r\n        // 条纹处更粗糙\r\n        material.roughnessNode = mix(float(0.6), float(0.9), stripeMask);\r\n        \r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * 天空材质 - 动态渐变\r\n     */\r\n    public static createSkyMaterial(): MeshBasicNodeMaterial {\r\n        const material = new MeshBasicNodeMaterial({\r\n            side: THREE.BackSide\r\n        });\r\n\r\n        const t = time;\r\n        \r\n        // 使用世界位置计算高度\r\n        const worldPos = positionWorld;\r\n        const skyRadius = float(MapConfig.size * 1.5);\r\n        const height = worldPos.y.div(skyRadius).add(0.5); // 归一化到 0-1\r\n        \r\n        // 天空渐变\r\n        const horizonColor = vec3(0.75, 0.88, 0.98);\r\n        const zenithColor = vec3(0.4, 0.6, 0.95);\r\n        const sunsetTint = vec3(0.95, 0.85, 0.7);\r\n        \r\n        // 基础渐变\r\n        const skyGradient = smoothstep(float(0.3), float(0.8), height);\r\n        let skyColor = mix(horizonColor, zenithColor, skyGradient);\r\n        \r\n        // 添加日落色调 (可选，基于时间)\r\n        const sunsetAmount = sin(t.mul(0.1)).mul(0.5).add(0.5).mul(0.2);\r\n        skyColor = mix(skyColor, sunsetTint, sunsetAmount.mul(sub(float(1), skyGradient)));\r\n        \r\n        material.colorNode = skyColor;\r\n        \r\n        return material;\r\n    }\r\n}","usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\level\\TreeSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\level\\WaterSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\level\\WeatherParticles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\level\\WeatherSceneApplier.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\level\\WeatherStateMachine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\level\\WeatherSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\level\\WindController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\player\\PlayerController.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'delta' is defined but never used. Allowed unused args must match /^_/u.","line":610,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":610,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from 'three';\r\nimport type { ParticleSimulation } from '../core/gpu/GpuSimulationFacade';\r\nimport { PlayerConfig } from '../core/GameConfig';\r\nimport { PlayerWeaponSystem } from '../weapon/PlayerWeaponSystem';\r\nimport type { RuntimeSettingsSource } from '../core/settings/RuntimeSettings';\r\nimport { PlayerInputController } from './PlayerInputController';\r\nimport type { GameServices } from '../core/services/GameServices';\r\nimport type { GameEventBus } from '../core/events/GameEventBus';\r\n\r\nimport { PhysicsSystem } from '../core/PhysicsSystem';\r\nimport { Enemy } from '../enemy/Enemy';\r\n\r\nexport class PlayerController {\r\n    private readonly settings: RuntimeSettingsSource;\r\n    private readonly services: GameServices;\r\n    private readonly events: GameEventBus;\r\n    private domElement: HTMLElement;\r\n    private camera: THREE.Camera;\r\n    private weaponSystem: PlayerWeaponSystem;\r\n    private scene: THREE.Scene;\r\n    private physicsSystem: PhysicsSystem;\r\n\r\n    private input: PlayerInputController;\r\n    \r\n    private canJump: boolean = false;\r\n    \r\n    // 姿态状态: 'stand' | 'crouch' | 'prone'\r\n    private stance: 'stand' | 'crouch' | 'prone' = 'stand';\r\n    private targetCameraHeight: number = PlayerConfig.stance.stand.height;\r\n\r\n    private velocity: THREE.Vector3 = new THREE.Vector3();\r\n    private direction: THREE.Vector3 = new THREE.Vector3();\r\n\r\n    // Look state\r\n    private pitch: number = 0;\r\n    private yaw: number = 0;\r\n    private targetPitch: number = 0;\r\n    private targetYaw: number = 0;\r\n    \r\n    private defaultY: number = PlayerConfig.stance.stand.height;\r\n    \r\n    // Smoothing\r\n    private visualYOffset: number = 0;\r\n    \r\n    // 拾取回调\r\n    private onPickupAttempt: (() => void) | null = null;\r\n    \r\n    // 投掷手榴弹回调\r\n    private onGrenadeThrow: ((position: THREE.Vector3, direction: THREE.Vector3) => void) | null = null;\r\n    \r\n    // 天气切换回调\r\n    private onWeatherCycle: (() => void) | null = null;\r\n    \r\n    // 地形高度回调\r\n    private onGetGroundHeight: ((x: number, z: number) => number) | null = null;\r\n\r\n    \r\n    private objects: THREE.Object3D[] = [];\r\n\r\n    private nearbyCollisionEntries: Array<{ box: THREE.Box3; object: THREE.Object3D }> = [];\r\n\r\n    // Hot-path temporaries (avoid per-frame allocations)\r\n    private tmpForward: THREE.Vector3 = new THREE.Vector3();\r\n    private tmpRight: THREE.Vector3 = new THREE.Vector3();\r\n    private tmpPlayerBox: THREE.Box3 = new THREE.Box3();\r\n\r\n    private readonly debugLogs: boolean = false;\r\n\r\n    constructor(\r\n        settings: RuntimeSettingsSource,\r\n        services: GameServices,\r\n        events: GameEventBus,\r\n        camera: THREE.Camera, \r\n        domElement: HTMLElement, \r\n        scene: THREE.Scene, \r\n        objects: THREE.Object3D[],\r\n        physicsSystem: PhysicsSystem\r\n    ) {\r\n        this.settings = settings;\r\n        this.services = services;\r\n        this.events = events;\r\n        this.domElement = domElement;\r\n        this.camera = camera;\r\n        this.scene = scene;\r\n        this.objects = objects; // 保留引用但不用于碰撞\r\n        this.physicsSystem = physicsSystem;\r\n        \r\n        // Initialize angles from current camera rotation\r\n        const euler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');\r\n        this.pitch = euler.x;\r\n        this.yaw = euler.y;\r\n        this.targetPitch = this.pitch;\r\n        this.targetYaw = this.yaw;\r\n\r\n        this.weaponSystem = new PlayerWeaponSystem(camera, scene, this.physicsSystem, this.services, this.events);\r\n\r\n        this.input = new PlayerInputController({\r\n            domElement: this.domElement,\r\n            settings: this.settings,\r\n            getAimProgress: () => this.weaponSystem.getAimProgress(),\r\n            resumeAudio: () => {\r\n                void this.services.sound.resume();\r\n            },\r\n\r\n            onTriggerDown: (isAiming) => this.weaponSystem.onTriggerDown(isAiming),\r\n            onTriggerUp: () => this.weaponSystem.onTriggerUp(),\r\n            onStartAiming: () => this.weaponSystem.startAiming(),\r\n            onStopAiming: () => this.weaponSystem.stopAiming(),\r\n\r\n            onSwitchNextWeapon: () => this.weaponSystem.switchToNextWeapon(),\r\n            onSwitchPrevWeapon: () => this.weaponSystem.switchToPrevWeapon(),\r\n            onSwitchToWeapon: (id) => this.weaponSystem.switchToWeapon(id),\r\n\r\n            onQuickThrowGrenade: () => this.quickThrowGrenade(),\r\n\r\n            onPickup: () => {\r\n                this.onPickupAttempt?.();\r\n            },\r\n            onWeatherCycle: () => {\r\n                this.onWeatherCycle?.();\r\n            },\r\n\r\n            onJumpPressed: () => this.handleJumpPressed(),\r\n            onToggleCrouch: () => this.toggleCrouch(),\r\n            onToggleProne: () => this.toggleProne(),\r\n\r\n            onLookDelta: (yawDelta, pitchDelta) => {\r\n                this.targetYaw += yawDelta;\r\n                this.targetPitch += pitchDelta;\r\n                // Clamp pitch\r\n                this.targetPitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, this.targetPitch));\r\n            },\r\n        });\r\n    }\r\n\r\n    private handleJumpPressed(): void {\r\n        // If crouching/prone, Space stands up first.\r\n        if (this.stance !== 'stand') {\r\n            this.setStance('stand');\r\n            return;\r\n        }\r\n\r\n        if (this.canJump !== true) return;\r\n        this.velocity.y += this.settings.getRuntimeSettings().jumpHeight;\r\n        this.canJump = false;\r\n        this.services.sound.playJump();\r\n    }\r\n\r\n    private toggleCrouch(): void {\r\n        if (this.stance === 'crouch') this.setStance('stand');\r\n        else this.setStance('crouch');\r\n    }\r\n\r\n    private toggleProne(): void {\r\n        if (this.stance === 'prone') this.setStance('stand');\r\n        else this.setStance('prone');\r\n    }\r\n\r\n    private quickThrowGrenade(): void {\r\n        // Quick-throw by temporarily switching to grenade weapon.\r\n        const prevWeapon = this.weaponSystem.getCurrentWeaponId();\r\n        this.weaponSystem.switchToWeapon('grenade');\r\n        this.weaponSystem.onTriggerDown(false);\r\n        setTimeout(() => {\r\n            this.weaponSystem.switchToWeapon(prevWeapon);\r\n        }, 1000);\r\n    }\r\n    \r\n    /**\r\n     * 设置敌人列表 (用于射击检测优化)\r\n     */\r\n    public setEnemies(enemies: Enemy[]) {\r\n        this.weaponSystem.setEnemies(enemies);\r\n    }\r\n\r\n    /**\r\n     * 设置粒子系统到武器\r\n     */\r\n    public setParticleSystem(particleSystem: ParticleSimulation) {\r\n        this.weaponSystem.setParticleSystem(particleSystem);\r\n    }\r\n    \r\n    /**\r\n     * 设置拾取回调\r\n     */\r\n    public setPickupCallback(callback: () => void) {\r\n        this.onPickupAttempt = callback;\r\n    }\r\n    \r\n    /**\r\n     * 设置手榴弹投掷回调\r\n     */\r\n    public setGrenadeThrowCallback(callback: (position: THREE.Vector3, direction: THREE.Vector3) => void) {\r\n        this.onGrenadeThrow = callback;\r\n        this.weaponSystem.setGrenadeThrowCallback(callback);\r\n    }\r\n\r\n    /**\r\n     * Warmup: temporarily show all weapon viewmodels so WebGPU can compile their pipelines.\r\n     */\r\n    public beginWeaponWarmupVisible() {\r\n        this.weaponSystem.beginWarmupVisible();\r\n    }\r\n\r\n    /** Restore normal weapon visibility after warmup. */\r\n    public endWeaponWarmupVisible() {\r\n        this.weaponSystem.endWarmupVisible();\r\n    }\r\n    \r\n    /**\r\n     * 设置天气切换回调\r\n     */\r\n    public setWeatherCycleCallback(callback: () => void) {\r\n        this.onWeatherCycle = callback;\r\n    }\r\n    \r\n    /**\r\n     * 设置地形高度回调\r\n     */\r\n    public setGroundHeightCallback(callback: (x: number, z: number) => number) {\r\n        this.onGetGroundHeight = callback;\r\n    }\r\n    \r\n    /**\r\n     * 设置武器的地形高度回调\r\n     */\r\n    public setWeaponGroundHeightCallback(callback: (x: number, z: number) => number) {\r\n        this.weaponSystem.setGroundHeightCallback(callback);\r\n    }\r\n\r\n    private frameCount: number = 0;\r\n\r\n    public resetPhysics() {\r\n        this.velocity.set(0, 0, 0);\r\n        this.canJump = true;\r\n        this.visualYOffset = 0;\r\n    }\r\n\r\n    public update(delta: number) {\r\n        // Debug Log every 60 frames\r\n        this.frameCount++;\r\n        if (this.debugLogs && this.frameCount % 60 === 0) {\r\n            console.log(`[PlayerController] Delta: ${delta.toFixed(4)}, Pos: (${this.camera.position.x.toFixed(2)}, ${this.camera.position.y.toFixed(2)}, ${this.camera.position.z.toFixed(2)}), Vel: (${this.velocity.x.toFixed(2)}, ${this.velocity.y.toFixed(2)}, ${this.velocity.z.toFixed(2)}), CanJump: ${this.canJump}, GroundHeight: ${this.onGetGroundHeight ? this.onGetGroundHeight(this.camera.position.x, this.camera.position.z).toFixed(2) : 'N/A'}`);\r\n            if (this.input.isLocked()) {\r\n                console.log(\r\n                    `[PlayerController] Movement Inputs: F:${this.input.getMoveForward()} B:${this.input.getMoveBackward()} L:${this.input.getMoveLeft()} R:${this.input.getMoveRight()}`\r\n                );\r\n            }\r\n        }\r\n\r\n        // 更新武器系统\r\n        this.weaponSystem.update(delta);\r\n        \r\n        // 更新 FOV (由武器瞄准进度驱动)\r\n        this.updateFOV(delta);\r\n        \r\n        if (this.input.isLocked() === true) {\r\n            // Restore physics position (remove visual offset from previous frame)\r\n            this.camera.position.y -= this.visualYOffset;\r\n\r\n            // 1. Smooth Look\r\n            // Interpolate current angles towards target angles\r\n            // Using a simple lerp factor adjusted by delta for frame-rate independence\r\n            const t = 1.0 - Math.pow(1.0 - this.settings.getRuntimeSettings().cameraSmoothFactor, delta * 60); \r\n            \r\n            this.yaw += (this.targetYaw - this.yaw) * t;\r\n            this.pitch += (this.targetPitch - this.pitch) * t;\r\n\r\n            this.camera.rotation.set(this.pitch, this.yaw, 0, 'YXZ');\r\n\r\n            // 2. Movement Physics\r\n            // Friction / Damping (Exponential decay for frame-rate independence)\r\n            // Fix: Using simple subtraction causes instability at low FPS or high friction\r\n            const damping = Math.exp(-this.settings.getRuntimeSettings().friction * delta);\r\n            this.velocity.x *= damping;\r\n            this.velocity.z *= damping;\r\n\r\n            const moveForward = this.input.getMoveForward();\r\n            const moveBackward = this.input.getMoveBackward();\r\n            const moveLeft = this.input.getMoveLeft();\r\n            const moveRight = this.input.getMoveRight();\r\n            const wantsMove = moveForward || moveBackward || moveLeft || moveRight;\r\n            // If we are grounded and not trying to move, don't apply gravity every frame.\r\n            // This avoids doing a vertical collision broadphase just to cancel gravity.\r\n            const idleGrounded = this.canJump === true && !wantsMove && Math.abs(this.velocity.y) < 0.01;\r\n            if (!idleGrounded) {\r\n                this.velocity.y -= this.settings.getRuntimeSettings().gravity * delta; // Gravity\r\n            } else {\r\n                this.velocity.y = 0;\r\n            }\r\n\r\n            this.direction.z = Number(moveForward) - Number(moveBackward);\r\n            this.direction.x = Number(moveRight) - Number(moveLeft);\r\n            this.direction.normalize();\r\n\r\n            // 根据姿态调整速度\r\n            let stanceMultiplier = 1.0;\r\n            if (this.stance === 'crouch') {\r\n                stanceMultiplier = PlayerConfig.stance.crouch.speedMultiplier;\r\n            } else if (this.stance === 'prone') {\r\n                stanceMultiplier = PlayerConfig.stance.prone.speedMultiplier;\r\n            }\r\n            \r\n            // 趴下和蹲下时不能跑步\r\n            const canRun = this.stance === 'stand' && this.input.isRunning();\r\n            const s = this.settings.getRuntimeSettings();\r\n            const currentSpeed = (canRun ? s.runSpeed : s.walkSpeed) * stanceMultiplier;\r\n\r\n            if (moveForward || moveBackward) this.velocity.z -= this.direction.z * currentSpeed * delta;\r\n            if (moveLeft || moveRight) this.velocity.x -= this.direction.x * currentSpeed * delta;\r\n\r\n            // Calculate world space velocity vector\r\n            // We want movement to be strictly horizontal (XZ plane), independent of camera pitch\r\n            // Get forward vector (projected to XZ plane)\r\n            const forward = this.tmpForward;\r\n            this.camera.getWorldDirection(forward);\r\n            forward.y = 0;\r\n            forward.normalize();\r\n\r\n            // Get right vector\r\n            const right = this.tmpRight;\r\n            right.crossVectors(forward, this.camera.up);\r\n            right.normalize();\r\n\r\n            const forwardSpeed = -this.velocity.z * delta;\r\n            const rightSpeed = -this.velocity.x * delta;\r\n\r\n            // Micro-optimization: when standing still, dx/dz are effectively zero.\r\n            // Skipping horizontal collision checks avoids 2x broadphase queries per frame at idle.\r\n            const moveEps = 1e-4;\r\n\r\n            // X axis movement (World Space)\r\n            const dx = (forward.x * forwardSpeed) + (right.x * rightSpeed);\r\n            let collisionBox: THREE.Box3 | null = null;\r\n            if (Math.abs(dx) > moveEps) {\r\n                this.camera.position.x += dx;\r\n                collisionBox = this.checkCollisions(true); // Use skinWidth for horizontal\r\n                if (collisionBox) {\r\n                    if (this.debugLogs && this.frameCount % 60 === 0) console.log(\"[PlayerController] Hit Object X:\", collisionBox);\r\n                    // 保存碰撞点的障碍物信息\r\n                    const obstacleTop = collisionBox.max.y;\r\n                    this.camera.position.x -= dx;\r\n                    this.handleObstacle(obstacleTop, dx, 0);\r\n                }\r\n            }\r\n\r\n            // Z axis movement (World Space)\r\n            const dz = (forward.z * forwardSpeed) + (right.z * rightSpeed);\r\n            if (Math.abs(dz) > moveEps) {\r\n                this.camera.position.z += dz;\r\n                collisionBox = this.checkCollisions(true); // Use skinWidth for horizontal\r\n                if (collisionBox) {\r\n                    if (this.debugLogs && this.frameCount % 60 === 0) console.log(\"[PlayerController] Hit Object Z:\", collisionBox);\r\n                    // 保存碰撞点的障碍物信息\r\n                    const obstacleTop = collisionBox.max.y;\r\n                    this.camera.position.z -= dz;\r\n                    this.handleObstacle(obstacleTop, 0, dz);\r\n                }\r\n            }\r\n\r\n            // Y axis movement (Gravity / Jump)\r\n            // If idle + grounded, skip vertical broadphase checks to avoid spikes.\r\n            const previousY = this.camera.position.y;\r\n            // 当前相机高度偏移\r\n            const currentCameraOffset = this.targetCameraHeight;\r\n\r\n            if (!idleGrounded) {\r\n                this.camera.position.y += (this.velocity.y * delta);\r\n\r\n                const collisionBoxY = this.checkCollisions(false); // Strict check for vertical\r\n                if (collisionBoxY) {\r\n                    if (this.velocity.y < 0) {\r\n                        // Falling down\r\n                        // Check if we were above the object (landing)\r\n                        const previousFeetY = previousY - currentCameraOffset;\r\n                        // Tolerance of 0.1m to handle fast falling or slight penetration\r\n                        if (previousFeetY >= collisionBoxY.max.y - 0.2) { // 增加容错到0.2\r\n                            this.canJump = true;\r\n                            this.velocity.y = 0;\r\n                            // Snap to top\r\n                            this.camera.position.y = collisionBoxY.max.y + currentCameraOffset;\r\n                        } else {\r\n                            // Hit side or bottom while falling? Revert.\r\n                            this.camera.position.y = previousY;\r\n                            this.velocity.y = 0;\r\n                            // FIXME: 防止卡在空中，如果没有水平速度\r\n                            if (Math.abs(this.velocity.x) < 0.1 && Math.abs(this.velocity.z) < 0.1) {\r\n                                // 如果卡在物体内部，尝试向上弹一点\r\n                                this.camera.position.y += 0.1;\r\n                            }\r\n                        }\r\n                    } else if (this.velocity.y > 0) {\r\n                        // Jumping up and hit ceiling\r\n                        this.velocity.y = 0;\r\n                        this.camera.position.y = previousY;\r\n                    }\r\n                }\r\n            } else {\r\n                // Keep stable at rest.\r\n                this.velocity.y = 0;\r\n            }\r\n\r\n            // Simple ground floor check (fallback)\r\n            let groundHeight = 0;\r\n            if (this.onGetGroundHeight) {\r\n                groundHeight = this.onGetGroundHeight(this.camera.position.x, this.camera.position.z);\r\n            }\r\n\r\n            const minHeight = groundHeight + this.defaultY;\r\n\r\n            if (this.camera.position.y < minHeight) {\r\n                this.velocity.y = 0;\r\n                this.camera.position.y = minHeight;\r\n                this.canJump = true;\r\n            }\r\n            \r\n            // 平滑更新相机高度 (姿态变化) - 在物理计算之后\r\n            this.updateStanceHeight(delta);\r\n\r\n            // Smooth camera Y\r\n            // Decay the offset\r\n            this.visualYOffset = THREE.MathUtils.lerp(this.visualYOffset, 0, delta * 15);\r\n            if (Math.abs(this.visualYOffset) < 0.001) this.visualYOffset = 0;\r\n            \r\n            // Apply offset for rendering\r\n            this.camera.position.y += this.visualYOffset;\r\n        }\r\n    }\r\n\r\n    private handleObstacle(obstacleTopY: number, dx: number, dz: number) {\r\n        // Only attempt to step up if we are moving\r\n        if (Math.abs(dx) < 0.001 && Math.abs(dz) < 0.001) return;\r\n        \r\n        // 当前相机高度偏移 (脚到眼睛的距离)\r\n        const currentCameraOffset = this.targetCameraHeight;\r\n\r\n        const playerFeetY = this.camera.position.y - currentCameraOffset;\r\n        const stepHeight = obstacleTopY - playerFeetY;\r\n\r\n        // Allow stepping up if obstacle is not too high\r\n        // stepHeight > 0 means obstacle is above our feet\r\n        // stepHeight <= maxStepHeight means it's climbable\r\n        if (stepHeight > 0.01 && stepHeight <= PlayerConfig.collision.maxStepHeight) {\r\n            // Check if there is space at the new position (on top of obstacle)\r\n            const originalY = this.camera.position.y;\r\n            const originalX = this.camera.position.x;\r\n            const originalZ = this.camera.position.z;\r\n\r\n            // Try to move up and forward\r\n            this.camera.position.y = obstacleTopY + currentCameraOffset + 0.05; // Slightly above\r\n            this.camera.position.x += dx;\r\n            this.camera.position.z += dz;\r\n\r\n            // Check for collision at new position using skinWidth to avoid detecting floor\r\n            if (!this.checkCollisions(true)) {\r\n                // Success! We can step up.\r\n                // Smooth the transition\r\n                this.visualYOffset -= (this.camera.position.y - originalY);\r\n                this.velocity.y = 0;\r\n                this.canJump = true;\r\n            } else {\r\n                // Failed, revert\r\n                this.camera.position.y = originalY;\r\n                this.camera.position.x = originalX;\r\n                this.camera.position.z = originalZ;\r\n            }\r\n        }\r\n    }\r\n\r\n    private checkCollisions(useSkinWidth: boolean = false): THREE.Box3 | null {\r\n        const playerBox = this.tmpPlayerBox;\r\n        const position = this.camera.position;\r\n\r\n        // 如果物理系统未就绪，允许移动\r\n        if (!this.physicsSystem) return null;\r\n        \r\n        // 使用当前目标相机高度作为偏移 (这是脚到眼睛的距离)\r\n        const cameraOffset = this.targetCameraHeight;\r\n        \r\n        // 根据姿态调整碰撞盒高度\r\n        const radius = PlayerConfig.collision.radius;\r\n        let height: number;\r\n        \r\n        switch (this.stance) {\r\n            case 'stand':\r\n                height = PlayerConfig.stance.stand.collisionHeight;\r\n                break;\r\n            case 'crouch':\r\n                height = PlayerConfig.stance.crouch.collisionHeight;\r\n                break;\r\n            case 'prone':\r\n                height = PlayerConfig.stance.prone.collisionHeight;\r\n                break;\r\n            default:\r\n                height = PlayerConfig.stance.stand.collisionHeight;\r\n        }\r\n        \r\n        // IMPORTANT: When moving horizontally (useSkinWidth = true), we reduce the box height slightly \r\n        // from the bottom to allow \"sliding\" on top of surfaces without detecting the surface we are standing on as a collision.\r\n        const skinWidth = useSkinWidth ? PlayerConfig.collision.skinWidth : 0.0;\r\n\r\n        // 计算脚部位置\r\n        const feetY = position.y - cameraOffset;\r\n        \r\n        playerBox.min.set(position.x - radius, feetY + skinWidth, position.z - radius);\r\n        playerBox.max.set(position.x + radius, feetY + height, position.z + radius);\r\n\r\n        // 使用物理系统获取附近的碰撞体 (空间划分优化)\r\n        // 查询半径稍微大一点以覆盖周边\r\n        const nearbyEntries = this.physicsSystem.getNearbyObjectsInto(position, 5.0, this.nearbyCollisionEntries);\r\n        \r\n        for (const entry of nearbyEntries) {\r\n            // entry.box 已经是世界坐标的 AABB，直接检测\r\n            if (playerBox.intersectsBox(entry.box)) {\r\n                // 如果是地面物体，忽略水平碰撞 (由 checkCollisions(true) 调用时)\r\n                // 只有当物体明确标记为 'isGround' 且我们是在做水平碰撞检测时才忽略\r\n                // 这样可以防止卡在楼梯平台或地砖接缝处\r\n                if (useSkinWidth && entry.object.userData.isGround) {\r\n                    continue;\r\n                }\r\n                return entry.box;\r\n            }\r\n        }\r\n        \r\n        return null;\r\n    }\r\n\r\n    public unlock() {\r\n        this.input.unlock();\r\n    }\r\n\r\n    /**\r\n     * Request pointer lock (best-effort). In browsers this may require a user gesture;\r\n     * in Tauri it may succeed immediately.\r\n     */\r\n    public lock() {\r\n        this.input.requestLock();\r\n    }\r\n    \r\n    /**\r\n     * 更新 FOV - 瞄准时平滑缩小视野\r\n     */\r\n    private updateFOV(delta: number) {\r\n        const perspectiveCamera = this.camera as THREE.PerspectiveCamera;\r\n        if (!perspectiveCamera.fov) return;\r\n\r\n        // 用武器瞄准进度插值 FOV（支持平滑过渡）\r\n        const aimProgress = this.weaponSystem.getAimProgress();\r\n        const s = this.settings.getRuntimeSettings();\r\n        const targetFov = THREE.MathUtils.lerp(s.defaultFov, s.aimFov, aimProgress);\r\n\r\n        perspectiveCamera.fov = THREE.MathUtils.lerp(perspectiveCamera.fov, targetFov, delta * s.fovLerpSpeed);\r\n        \r\n        perspectiveCamera.updateProjectionMatrix();\r\n    }\r\n    \r\n    /**\r\n     * 获取是否正在瞄准\r\n     */\r\n    public getIsAiming(): boolean {\r\n        return this.input.isAiming();\r\n    }\r\n    \r\n    /**\r\n     * 获取瞄准进度 (0-1)\r\n     * 用于后处理瞄准镜效果\r\n     */\r\n    public getAimProgress(): number {\r\n        return this.weaponSystem.getAimProgress();\r\n    }\r\n    \r\n    /**\r\n     * 设置姿态\r\n     */\r\n    private setStance(newStance: 'stand' | 'crouch' | 'prone'): void {\r\n        if (this.stance === newStance) return;\r\n        \r\n        const oldCameraHeight = this.targetCameraHeight;\r\n        this.stance = newStance;\r\n        \r\n        // 更新GameState中的姿态\r\n        this.services.state.setStance(newStance);\r\n        \r\n        // 设置目标相机高度\r\n        switch (newStance) {\r\n            case 'stand':\r\n                this.targetCameraHeight = PlayerConfig.stance.stand.height;\r\n                this.defaultY = PlayerConfig.stance.stand.height;\r\n                break;\r\n            case 'crouch':\r\n                this.targetCameraHeight = PlayerConfig.stance.crouch.height;\r\n                this.defaultY = PlayerConfig.stance.crouch.height;\r\n                break;\r\n            case 'prone':\r\n                this.targetCameraHeight = PlayerConfig.stance.prone.height;\r\n                this.defaultY = PlayerConfig.stance.prone.height;\r\n                break;\r\n        }\r\n        \r\n        // 计算高度差，用于平滑过渡\r\n        const heightDiff = this.targetCameraHeight - oldCameraHeight;\r\n        // 添加到 visualYOffset，会逐渐衰减到0\r\n        this.visualYOffset -= heightDiff;\r\n    }\r\n    \r\n    /**\r\n     * 平滑更新相机高度 (姿态变化)\r\n     * 只调整相对高度，不干扰物理系统\r\n     */\r\n    private updateStanceHeight(delta: number): void {\r\n        // 姿态变化时，通过调整 visualYOffset 实现平滑过渡\r\n        // 而不是直接修改 camera.position.y\r\n        // 这样不会干扰物理碰撞系统\r\n    }\r\n    \r\n    /**\r\n     * 获取当前姿态\r\n     */\r\n    public getStance(): 'stand' | 'crouch' | 'prone' {\r\n        return this.stance;\r\n    }\r\n\r\n    public dispose() {\r\n        this.weaponSystem.dispose();\r\n        this.input.dispose();\r\n        this.input.unlock();\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\player\\PlayerInputController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\shaders\\GPUCompute.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\shaders\\GPUParticles.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'positionLocal' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'modelViewMatrix' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'varying' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'atan' is defined but never used. Allowed unused vars must match /^_/u.","line":18,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sizeData' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":234,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":234,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'circleShape' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":363,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":363,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cloudShape' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":368,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":368,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'hardShape' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":371,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":371,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * GPU 粒子系统 - 使用 TSL Compute Shader 实现高性能粒子\r\n * 支持数万粒子的实时模拟\r\n */\r\nimport * as THREE from 'three';\r\n// @ts-ignore - WebGPU types not fully available\r\nimport { WebGPURenderer, SpriteNodeMaterial } from 'three/webgpu';\r\nimport {\r\n    Fn, uniform, storage, instanceIndex,\r\n    float, vec2, vec3, vec4,\r\n    If,\r\n    sub, abs, pow,\r\n    select,\r\n    mix,\r\n    positionLocal,\r\n    modelViewMatrix,\r\n    varying,\r\n    uv, length, smoothstep, sin, atan\r\n} from 'three/tsl';\r\n\r\nimport { createStorageBufferAttribute } from './StorageBufferAttributeCompat';\r\n\r\n// 粒子类型\r\nexport type ParticleType = 'spark' | 'smoke' | 'blood' | 'debris' | 'muzzle' | 'explosion';\r\n\r\n// 粒子发射器配置\r\nexport interface EmitterConfig {\r\n    type: ParticleType;\r\n    position: THREE.Vector3;\r\n    direction: THREE.Vector3;\r\n    spread: number;         // 扩散角度 (弧度)\r\n    speed: { min: number; max: number };\r\n    lifetime: { min: number; max: number };\r\n    size: { start: number; end: number };\r\n    color: { start: THREE.Color; end: THREE.Color };\r\n    gravity: number;\r\n    drag: number;\r\n    count: number;\r\n}\r\n\r\n/**\r\n * GPU 粒子系统\r\n */\r\nexport class GPUParticleSystem {\r\n    private renderer: WebGPURenderer;\r\n    private maxParticles: number;\r\n    private scene: THREE.Scene;\r\n    \r\n    // GPU 缓冲区 (使用 any 类型绕过 WebGPU 类型问题)\r\n    private positionBuffer!: any;\r\n    private velocityBuffer!: any;\r\n    private colorBuffer!: any;\r\n    private sizeBuffer!: any;\r\n    private lifeBuffer!: any;      // vec2: currentLife, maxLife\r\n    private typeBuffer!: any;      // int: particle type\r\n    \r\n    // Compute Shader Uniforms\r\n    private deltaTime = uniform(0);\r\n    private globalTime = uniform(0);\r\n    private gravity = uniform(new THREE.Vector3(0, -9.8, 0));\r\n    \r\n    // Compute 函数\r\n    private updateCompute: any;\r\n    \r\n    // 渲染\r\n    private particleMesh!: THREE.InstancedMesh;\r\n    private particleIndex: number = 0;\r\n\r\n    // Perf: compute dispatch is expensive even when no particles are alive.\r\n    // Track an approximate \"active window\" so we can skip compute work at idle.\r\n    private hasActiveParticles = false;\r\n    private activeUntilTime = 0;\r\n    private didInitialCompute = false;\r\n    private readonly activeTimeMargin = 0.15; // safety margin to avoid freezing particles near end-of-life\r\n\r\n    // Reuse vectors in emit() to avoid heavy GC on shooting\r\n    private readonly emitAxisX = new THREE.Vector3(1, 0, 0);\r\n    private readonly emitAxisY = new THREE.Vector3(0, 1, 0);\r\n    private readonly tmpEmitDir = new THREE.Vector3();\r\n    private readonly tmpSpreadDir = new THREE.Vector3();\r\n\r\n    private readonly tmpPresetPosition = new THREE.Vector3();\r\n    private readonly tmpPresetDirection = new THREE.Vector3();\r\n    private readonly tmpBloodDripDirection = new THREE.Vector3();\r\n    private readonly presetConfig: EmitterConfig = {\r\n        type: 'spark',\r\n        position: this.tmpPresetPosition,\r\n        direction: this.tmpPresetDirection,\r\n        spread: 0,\r\n        speed: { min: 0, max: 0 },\r\n        lifetime: { min: 0, max: 0 },\r\n        size: { start: 0, end: 0 },\r\n        color: GPUParticleSystem.COLORS.spark,\r\n        gravity: 0,\r\n        drag: 1,\r\n        count: 0,\r\n    };\r\n\r\n    private static readonly BLOOD_BRIGHT = {\r\n        start: new THREE.Color(1.0, 0.05, 0.02),\r\n        end: new THREE.Color(0.6, 0.02, 0.01),\r\n    };\r\n    private static readonly BLOOD_FOG = {\r\n        start: new THREE.Color(0.8, 0.03, 0.02),\r\n        end: new THREE.Color(0.4, 0.02, 0.01),\r\n    };\r\n    private static readonly BLOOD_DARK = {\r\n        start: new THREE.Color(0.7, 0.02, 0.01),\r\n        end: new THREE.Color(0.35, 0.01, 0.005),\r\n    };\r\n\r\n    private emitPreset(\r\n        type: ParticleType,\r\n        position: THREE.Vector3,\r\n        direction: THREE.Vector3,\r\n        spread: number,\r\n        speedMin: number,\r\n        speedMax: number,\r\n        lifeMin: number,\r\n        lifeMax: number,\r\n        sizeStart: number,\r\n        sizeEnd: number,\r\n        gravity: number,\r\n        drag: number,\r\n        count: number,\r\n        colorOverride?: { start: THREE.Color; end: THREE.Color }\r\n    ) {\r\n        const cfg = this.presetConfig;\r\n        cfg.type = type;\r\n        cfg.position.copy(position);\r\n        cfg.direction.copy(direction);\r\n        cfg.spread = spread;\r\n        cfg.speed.min = speedMin;\r\n        cfg.speed.max = speedMax;\r\n        cfg.lifetime.min = lifeMin;\r\n        cfg.lifetime.max = lifeMax;\r\n        cfg.size.start = sizeStart;\r\n        cfg.size.end = sizeEnd;\r\n        cfg.gravity = gravity;\r\n        cfg.drag = drag;\r\n        cfg.count = count;\r\n        cfg.color = colorOverride ?? (GPUParticleSystem.COLORS[type] || GPUParticleSystem.COLORS.spark);\r\n\r\n        this.emit(cfg);\r\n    }\r\n    \r\n    // 预设颜色\r\n    private static readonly COLORS = {\r\n        spark: { start: new THREE.Color(1, 0.9, 0.5), end: new THREE.Color(1, 0.3, 0) },\r\n        smoke: { start: new THREE.Color(0.5, 0.5, 0.5), end: new THREE.Color(0.2, 0.2, 0.2) },\r\n        blood: { start: new THREE.Color(0.9, 0.02, 0.01), end: new THREE.Color(0.5, 0.01, 0.005) },\r\n        debris: { start: new THREE.Color(0.6, 0.5, 0.4), end: new THREE.Color(0.3, 0.25, 0.2) },\r\n        muzzle: { start: new THREE.Color(1, 1, 0.9), end: new THREE.Color(1, 0.5, 0.1) },\r\n        explosion: { start: new THREE.Color(1, 0.8, 0.3), end: new THREE.Color(0.8, 0.2, 0) }\r\n    };\r\n\r\n    constructor(renderer: WebGPURenderer, scene: THREE.Scene, maxParticles: number = 50000) {\r\n        this.renderer = renderer;\r\n        this.scene = scene;\r\n        this.maxParticles = maxParticles;\r\n        \r\n        this.initBuffers();\r\n        this.createComputeShader();\r\n        this.createParticleMesh();\r\n    }\r\n\r\n    /**\r\n     * 初始化 GPU 缓冲区\r\n     */\r\n    private initBuffers() {\r\n        // 位置 (vec3)\r\n        const positions = new Float32Array(this.maxParticles * 3);\r\n        // @ts-ignore - WebGPU API\r\n        this.positionBuffer = createStorageBufferAttribute(positions, 3);\r\n        \r\n        // 速度 (vec3)\r\n        const velocities = new Float32Array(this.maxParticles * 3);\r\n        // @ts-ignore - WebGPU API\r\n        this.velocityBuffer = createStorageBufferAttribute(velocities, 3);\r\n        \r\n        // 颜色 (vec4: startR, startG, startB, endR) + (vec4: endG, endB, alpha, unused)\r\n        // 简化为 RGBA\r\n        const colors = new Float32Array(this.maxParticles * 4);\r\n        // @ts-ignore - WebGPU API\r\n        this.colorBuffer = createStorageBufferAttribute(colors, 4);\r\n        \r\n        // 大小 (vec2: startSize, endSize)\r\n        const sizes = new Float32Array(this.maxParticles * 2);\r\n        // @ts-ignore - WebGPU API\r\n        this.sizeBuffer = createStorageBufferAttribute(sizes, 2);\r\n        \r\n        // 生命周期 (vec3: currentLife, maxLife, drag)\r\n        const lives = new Float32Array(this.maxParticles * 3);\r\n        // 初始化为已死亡状态\r\n        for (let i = 0; i < this.maxParticles; i++) {\r\n            lives[i * 3] = 999;     // currentLife > maxLife = dead\r\n            lives[i * 3 + 1] = 1;   // maxLife\r\n            lives[i * 3 + 2] = 0.98; // drag\r\n        }\r\n        // @ts-ignore - WebGPU API\r\n        this.lifeBuffer = createStorageBufferAttribute(lives, 3);\r\n        \r\n        // 类型 (float: 用于颜色插值等)\r\n        const types = new Float32Array(this.maxParticles);\r\n        // @ts-ignore - WebGPU API\r\n        this.typeBuffer = createStorageBufferAttribute(types, 1);\r\n    }\r\n\r\n    /**\r\n     * 创建 Compute Shader\r\n     */\r\n    private createComputeShader() {\r\n        const positionStorage = storage(this.positionBuffer, 'vec3', this.maxParticles);\r\n        const velocityStorage = storage(this.velocityBuffer, 'vec3', this.maxParticles);\r\n        const colorStorage = storage(this.colorBuffer, 'vec4', this.maxParticles);\r\n        const sizeStorage = storage(this.sizeBuffer, 'vec2', this.maxParticles);\r\n        const lifeStorage = storage(this.lifeBuffer, 'vec3', this.maxParticles);\r\n\r\n        this.updateCompute = Fn(() => {\r\n            const index = instanceIndex;\r\n            \r\n            // 读取生命周期数据\r\n            const lifeData = lifeStorage.element(index);\r\n            const currentLife = lifeData.x;\r\n            const maxLife = lifeData.y;\r\n            const drag = lifeData.z;\r\n            \r\n            // 只处理存活的粒子 (currentLife < maxLife)\r\n            If(currentLife.lessThan(maxLife), () => {\r\n                // 读取数据\r\n                const position = positionStorage.element(index);\r\n                const velocity = velocityStorage.element(index);\r\n                const color = colorStorage.element(index);\r\n                const sizeData = sizeStorage.element(index);\r\n                \r\n                // 更新生命周期\r\n                const newLife = currentLife.add(this.deltaTime);\r\n                const lifeRatio = newLife.div(maxLife);\r\n                \r\n                // 应用重力\r\n                const newVelY = velocity.y.add(this.gravity.y.mul(this.deltaTime));\r\n                \r\n                // 应用阻力\r\n                const newVelX = velocity.x.mul(drag);\r\n                const newVelZ = velocity.z.mul(drag);\r\n                \r\n                // 更新位置\r\n                const newPosX = position.x.add(velocity.x.mul(this.deltaTime));\r\n                const newPosY = position.y.add(velocity.y.mul(this.deltaTime));\r\n                const newPosZ = position.z.add(velocity.z.mul(this.deltaTime));\r\n                \r\n                // 地面碰撞 (简单反弹)\r\n                const groundY = float(0.05);\r\n                const finalPosY = select(\r\n                    newPosY.lessThan(groundY),\r\n                    groundY,\r\n                    newPosY\r\n                );\r\n                const finalVelY = select(\r\n                    newPosY.lessThan(groundY),\r\n                    abs(newVelY).mul(0.3).mul(drag),  // 反弹并衰减\r\n                    newVelY\r\n                );\r\n                \r\n                // 淡出\r\n                const fadeAlpha = sub(float(1), pow(lifeRatio, float(2)));\r\n                const newAlpha = fadeAlpha;\r\n                \r\n                // 写回缓冲区\r\n                positionStorage.element(index).assign(vec3(newPosX, finalPosY, newPosZ));\r\n                velocityStorage.element(index).assign(vec3(newVelX, finalVelY, newVelZ));\r\n                colorStorage.element(index).assign(vec4(color.x, color.y, color.z, newAlpha));\r\n                lifeStorage.element(index).assign(vec3(newLife, maxLife, drag));\r\n            });\r\n        })().compute(this.maxParticles);\r\n    }\r\n\r\n    /**\r\n     * 创建粒子渲染网格 - 纯 GPU TSL 驱动\r\n     */\r\n    private createParticleMesh() {\r\n        // 使用 PlaneGeometry (Billboard)\r\n        const geometry = new THREE.PlaneGeometry(1, 1);\r\n        \r\n        // 粒子材质\r\n        const material = this.createParticleMaterial();\r\n        \r\n        // 实例化网格\r\n        this.particleMesh = new THREE.InstancedMesh(geometry, material, this.maxParticles);\r\n        this.particleMesh.frustumCulled = false;\r\n        // 不再需要 instanceMatrix\r\n        // this.particleMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); \r\n        \r\n        this.scene.add(this.particleMesh);\r\n    }\r\n\r\n    /**\r\n     * 创建粒子材质 - TSL 驱动\r\n     */\r\n    private createParticleMaterial(): THREE.Material {\r\n        // 注意：这里需要重新获取 storage 引用，因为它们是 Shader 节点\r\n        const positionStorage = storage(this.positionBuffer, 'vec3', this.maxParticles);\r\n        const colorStorage = storage(this.colorBuffer, 'vec4', this.maxParticles);\r\n        const sizeStorage = storage(this.sizeBuffer, 'vec2', this.maxParticles);\r\n        const lifeStorage = storage(this.lifeBuffer, 'vec3', this.maxParticles);\r\n\r\n        const material = new SpriteNodeMaterial();\r\n        material.transparent = true;\r\n        material.depthWrite = false;\r\n        material.blending = THREE.AdditiveBlending;\r\n        \r\n        // TSL 顶点逻辑\r\n        const index = instanceIndex;\r\n        \r\n        // 获取粒子数据\r\n        const pPos = positionStorage.element(index);\r\n        const pColor = colorStorage.element(index);\r\n        const pSize = sizeStorage.element(index);\r\n        const pLife = lifeStorage.element(index);\r\n        \r\n        const currentLife = pLife.x;\r\n        const maxLife = pLife.y;\r\n        \r\n        // 计算大小插值\r\n        const lifeRatio = currentLife.div(maxLife);\r\n        const size = mix(pSize.x, pSize.y, lifeRatio);\r\n        \r\n        // 设置位置 (SpriteNodeMaterial 默认处理 Billboard，我们只需要给 positionNode 设置世界坐标)\r\n        // 但我们要让它变大变小，所以使用 scaleNode (如果没有直接提供，可以通过 positionNode 实现)\r\n        // SpriteNodeMaterial 的 positionNode = \"position of the sprite center in world space\"\r\n        \r\n        // 修正：SpriteNodeMaterial 将整个 Mesh 视为一个 Sprite，如果是 InstancedMesh，我们需要重写 positionNode\r\n        // 来包含 instance 位置 + local vertex position * size\r\n        \r\n        // 覆盖 vertex shader 的 position\r\n        // 注意：SpriteNodeMaterial 可能会有不同的处理方式，\r\n        // 这里为了保险，我们使用 vertexNode 来覆盖最终位置或者 positionNode\r\n        \r\n        // 在新版 Three.js TSL 中，我们可以直接设置 material.positionNode\r\n        // 这决定了 \"模型的位置\"。对于 InstancedMesh，这就是 Instance 的位置。\r\n        // 但我们需要 Billboard 效果。\r\n        \r\n        material.positionNode = pPos;\r\n        material.scaleNode = vec2(size);\r\n        material.rotationNode = float(0); // 可选：如果有旋转\r\n        \r\n        // --------------------------------------------------------\r\n        //   改进的粒子形状 (不再是方块)\r\n        // --------------------------------------------------------\r\n        const uvNode = uv(); // 获取 Sprite UV (0..1)\r\n        const centeredUV = uvNode.sub(vec2(0.5)); // -0.5 .. 0.5\r\n        const distSq = centeredUV.x.mul(centeredUV.x).add(centeredUV.y.mul(centeredUV.y)); // r^2\r\n        const dist = length(centeredUV); // r\r\n\r\n        // 根据 typeBuffer 的值 (int) 来决定形状\r\n        // 0:spark, 1:smoke, 2:blood, 3:debris, 4:muzzle, 5:explosion\r\n        // 注意：WebGPU 中 int 比较通常用 equal\r\n        // 此处为了性能和 TSL 兼容性，我们用 float 比较或者简单的通用圆形衰减\r\n\r\n        // 通用的软圆形发光点 (模拟火花、光点)\r\n        // 边缘软化：从中心 0 到边缘 0.5，强度从 1 降到 0\r\n        // smoothstep(0.5, 0.0, dist) -> 边缘是 0 (硬切)，我们需要让它自然消散\r\n        const circleShape = smoothstep(float(0.5), float(0.2), dist);\r\n\r\n        // 如果是烟雾或爆炸，我们要更柔和、更像云团的形状\r\n        // 简单的云雾噪声模拟 (基于 UV)\r\n        const cloudNoise = sin(uvNode.x.mul(10.0)).mul(sin(uvNode.y.mul(10.0))).mul(0.2); \r\n        const cloudShape = smoothstep(float(0.5), float(0.0), dist.add(cloudNoise));\r\n\r\n        // 如果是碎片 (debris/blood)，可能稍微锐利一点\r\n        const hardShape = smoothstep(float(0.5), float(0.4), dist);\r\n\r\n        // 由于这是所有粒子的统一 Shader (Instanced)，我们需要做出取舍或者根据额外属性分支\r\n        // 这里我们先使用一个通用的漂亮的 \"光晕点\" 形状，它比方块好得多\r\n        // 并在中心极亮。\r\n        \r\n        // 核心两倍亮度，边缘快速衰减\r\n        const glow = float(0.05).div(distSq.add(0.01)); // 物理反平方衰减模拟\r\n        const softCircle = smoothstep(float(0.5), float(0.0), dist);\r\n        \r\n        // 最终透明度形状：结合辉光和软圆，防止无限大\r\n        const shapePre = glow.mul(softCircle).min(1.0);\r\n\r\n        // 颜色和透明度\r\n        // 如果死了 (currentLife >= maxLife)，透明度设为 0\r\n        const isDead = currentLife.greaterThanEqual(maxLife);\r\n        const alphaBase = select(isDead, float(0), pColor.w);\r\n        \r\n        // 最终 Alpha = 粒子自身 Alpha * 形状 Alpha\r\n        const finalAlpha = alphaBase.mul(shapePre);\r\n        \r\n        // 丢弃过暗的像素 (Clip)\r\n        // 避免不可见的片元写入深度或消耗混合带宽\r\n        // if (finalAlpha < 0.01) discard; \r\n        // TSL 中用 discard(expr) 或直接通过 alpha 混合\r\n\r\n        material.colorNode = vec4(pColor.xyz, finalAlpha);\r\n        \r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * 发射粒子\r\n     */\r\n    public emit(config: EmitterConfig) {\r\n        const posArray = this.positionBuffer.array as Float32Array;\r\n        const velArray = this.velocityBuffer.array as Float32Array;\r\n        const colorArray = this.colorBuffer.array as Float32Array;\r\n        const sizeArray = this.sizeBuffer.array as Float32Array;\r\n        const lifeArray = this.lifeBuffer.array as Float32Array;\r\n        \r\n        const colors = GPUParticleSystem.COLORS[config.type] || GPUParticleSystem.COLORS.spark;\r\n\r\n        // Avoid per-particle allocations in hot loops (clone/new)\r\n        const baseDir = this.tmpEmitDir.copy(config.direction);\r\n        if (baseDir.lengthSq() > 1e-10) baseDir.normalize();\r\n        else baseDir.set(0, 1, 0);\r\n        const axisX = this.emitAxisX;\r\n        const axisY = this.emitAxisY;\r\n        const spreadDir = this.tmpSpreadDir;\r\n        \r\n        for (let i = 0; i < config.count; i++) {\r\n            const idx = (this.particleIndex + i) % this.maxParticles;\r\n            \r\n            // 位置 (带小随机偏移)\r\n            posArray[idx * 3] = config.position.x + (Math.random() - 0.5) * 0.1;\r\n            posArray[idx * 3 + 1] = config.position.y + (Math.random() - 0.5) * 0.1;\r\n            posArray[idx * 3 + 2] = config.position.z + (Math.random() - 0.5) * 0.1;\r\n            \r\n            // 计算速度 (基于方向和扩散)\r\n            const spreadAngle = (Math.random() - 0.5) * config.spread;\r\n            const spreadAngle2 = (Math.random() - 0.5) * config.spread;\r\n            \r\n            const speed = THREE.MathUtils.lerp(config.speed.min, config.speed.max, Math.random());\r\n\r\n            // 简单扩散\r\n            spreadDir\r\n                .copy(baseDir)\r\n                .applyAxisAngle(axisX, spreadAngle)\r\n                .applyAxisAngle(axisY, spreadAngle2);\r\n            \r\n            velArray[idx * 3] = spreadDir.x * speed;\r\n            velArray[idx * 3 + 1] = spreadDir.y * speed;\r\n            velArray[idx * 3 + 2] = spreadDir.z * speed;\r\n            \r\n            // 颜色 (使用起始颜色，结束颜色在 shader 中插值)\r\n            const colorVariation = 1 - Math.random() * 0.2;\r\n            colorArray[idx * 4] = colors.start.r * colorVariation;\r\n            colorArray[idx * 4 + 1] = colors.start.g * colorVariation;\r\n            colorArray[idx * 4 + 2] = colors.start.b * colorVariation;\r\n            colorArray[idx * 4 + 3] = 1.0;\r\n            \r\n            // 大小\r\n            sizeArray[idx * 2] = config.size.start * (0.8 + Math.random() * 0.4);\r\n            sizeArray[idx * 2 + 1] = config.size.end;\r\n            \r\n            // 生命周期\r\n            const lifetime = THREE.MathUtils.lerp(config.lifetime.min, config.lifetime.max, Math.random());\r\n            lifeArray[idx * 3] = 0;                // currentLife\r\n            lifeArray[idx * 3 + 1] = lifetime;     // maxLife\r\n            lifeArray[idx * 3 + 2] = config.drag;  // drag\r\n        }\r\n        \r\n        this.particleIndex = (this.particleIndex + config.count) % this.maxParticles;\r\n\r\n        // Mark system as active for at least the maximum possible lifetime.\r\n        // This allows update() to skip compute dispatch when everything should be dead.\r\n        if (config.count > 0) {\r\n            this.hasActiveParticles = true;\r\n            const until = this.globalTime.value + (config.lifetime?.max ?? 0) + this.activeTimeMargin;\r\n            if (until > this.activeUntilTime) this.activeUntilTime = until;\r\n        }\r\n        \r\n        // 标记缓冲区需要更新\r\n        this.positionBuffer.needsUpdate = true;\r\n        this.velocityBuffer.needsUpdate = true;\r\n        this.colorBuffer.needsUpdate = true;\r\n        this.sizeBuffer.needsUpdate = true;\r\n        this.lifeBuffer.needsUpdate = true;\r\n    }\r\n\r\n    /**\r\n     * 预设发射器 - 火花\r\n     */\r\n    public emitSparks(position: THREE.Vector3, direction: THREE.Vector3, count: number = 15) {\r\n        this.emitPreset(\r\n            'spark',\r\n            position,\r\n            direction,\r\n            Math.PI * 0.5,\r\n            3,\r\n            8,\r\n            0.2,\r\n            0.5,\r\n            0.03,\r\n            0.01,\r\n            -15,\r\n            0.95,\r\n            count\r\n        );\r\n    }\r\n\r\n    /**\r\n     * 预设发射器 - 血液 (增强版)\r\n     * 产生多层血液效果：主飞溅、细小飞沫、滴落、血雾\r\n     */\r\n    public emitBlood(position: THREE.Vector3, direction: THREE.Vector3, count: number = 10) {\r\n        // 主血液飞溅 - 较大、较快、更亮的红色\r\n        this.emitPreset(\r\n            'blood',\r\n            position,\r\n            direction,\r\n            Math.PI * 0.5,\r\n            5,\r\n            12,\r\n            0.5,\r\n            1.0,\r\n            0.1,\r\n            0.03,\r\n            -12,\r\n            0.88,\r\n            Math.floor(count * 0.4),\r\n            GPUParticleSystem.BLOOD_BRIGHT\r\n        );\r\n        \r\n        // 细小飞沫 - 更分散、更小\r\n        this.emitPreset(\r\n            'blood',\r\n            position,\r\n            direction,\r\n            Math.PI * 0.7,\r\n            3,\r\n            9,\r\n            0.4,\r\n            0.7,\r\n            0.05,\r\n            0.015,\r\n            -18,\r\n            0.82,\r\n            Math.floor(count * 0.35)\r\n        );\r\n        \r\n        // 血雾效果 - 悬浮的细小颗粒\r\n        this.emitPreset(\r\n            'blood',\r\n            position,\r\n            direction,\r\n            Math.PI * 0.8,\r\n            1,\r\n            4,\r\n            0.6,\r\n            1.2,\r\n            0.08,\r\n            0.04,\r\n            -5,\r\n            0.96,\r\n            Math.floor(count * 0.15),\r\n            GPUParticleSystem.BLOOD_FOG\r\n        );\r\n        \r\n        // 慢速滴落 - 重力主导\r\n        this.tmpBloodDripDirection.set(direction.x * 0.2, 0.8, direction.z * 0.2);\r\n        this.emitPreset(\r\n            'blood',\r\n            position,\r\n            this.tmpBloodDripDirection,\r\n            Math.PI * 0.25,\r\n            2,\r\n            5,\r\n            0.7,\r\n            1.3,\r\n            0.07,\r\n            0.025,\r\n            -22,\r\n            0.94,\r\n            Math.floor(count * 0.1),\r\n            GPUParticleSystem.BLOOD_DARK\r\n        );\r\n    }\r\n\r\n    /**\r\n     * 预设发射器 - 烟雾\r\n     */\r\n    public emitSmoke(position: THREE.Vector3, count: number = 20) {\r\n        this.tmpPresetDirection.set(0, 1, 0);\r\n        this.emitPreset(\r\n            'smoke',\r\n            position,\r\n            this.tmpPresetDirection,\r\n            Math.PI * 0.3,\r\n            0.5,\r\n            2,\r\n            0.5,\r\n            1.5,\r\n            0.1,\r\n            0.3,\r\n            2,\r\n            0.98,\r\n            count\r\n        );\r\n    }\r\n\r\n    /**\r\n     * 预设发射器 - 枪口火焰\r\n     */\r\n    public emitMuzzleFlash(position: THREE.Vector3, direction: THREE.Vector3) {\r\n        this.emitPreset(\r\n            'muzzle',\r\n            position,\r\n            direction,\r\n            Math.PI * 0.2,\r\n            5,\r\n            10,\r\n            0.05,\r\n            0.1,\r\n            0.05,\r\n            0.02,\r\n            0,\r\n            0.9,\r\n            8\r\n        );\r\n    }\r\n\r\n    /**\r\n     * 预设发射器 - 爆炸\r\n     */\r\n    public emitExplosion(position: THREE.Vector3, count: number = 50) {\r\n        // 火焰\r\n        this.tmpPresetDirection.set(0, 1, 0);\r\n        this.emitPreset(\r\n            'explosion',\r\n            position,\r\n            this.tmpPresetDirection,\r\n            Math.PI,\r\n            3,\r\n            8,\r\n            0.3,\r\n            0.8,\r\n            0.15,\r\n            0.05,\r\n            -5,\r\n            0.95,\r\n            count\r\n        );\r\n        \r\n        // 烟雾\r\n        this.emitSmoke(position, count / 2);\r\n    }\r\n\r\n    /**\r\n     * 更新粒子系统\r\n     */\r\n    public update(delta: number) {\r\n        this.deltaTime.value = delta;\r\n        this.globalTime.value += delta;\r\n\r\n        // Ensure we dispatch at least once early so WebGPU pipelines/resources get compiled during warmup.\r\n        if (!this.didInitialCompute) {\r\n            this.didInitialCompute = true;\r\n            this.renderer.computeAsync(this.updateCompute);\r\n            return;\r\n        }\r\n\r\n        // Idle fast-path: skip compute work when no particles are expected to be alive.\r\n        if (!this.hasActiveParticles) return;\r\n        if (this.globalTime.value > this.activeUntilTime) {\r\n            this.hasActiveParticles = false;\r\n            return;\r\n        }\r\n\r\n        // 执行 Compute Shader\r\n        this.renderer.computeAsync(this.updateCompute);\r\n        \r\n        // 不需要 CPU 端循环更新实例矩阵\r\n        // TSL 材质会自动读取 Storage Buffer\r\n    }\r\n\r\n    /**\r\n     * 更新实例矩阵 (CPU 端，用于实际渲染)\r\n     * @deprecated 使用 TSL Material 不需要此方法\r\n     */\r\n    private updateInstanceMatrices() {\r\n        // 已弃用，直接移除逻辑\r\n    }\r\n\r\n    /**\r\n     * 销毁\r\n     */\r\n    public dispose() {\r\n        this.scene.remove(this.particleMesh);\r\n        this.particleMesh.geometry.dispose();\r\n        (this.particleMesh.material as THREE.Material).dispose();\r\n        \r\n        // 清理缓冲区\r\n        this.positionBuffer.array = new Float32Array(0);\r\n        this.velocityBuffer.array = new Float32Array(0);\r\n        this.colorBuffer.array = new Float32Array(0);\r\n        this.sizeBuffer.array = new Float32Array(0);\r\n        this.lifeBuffer.array = new Float32Array(0);\r\n        this.typeBuffer.array = new Float32Array(0);\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\shaders\\GPUWeatherParticles.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\shaders\\GrassTSL.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'uniform' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cos' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'modelWorldMatrix' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'randomColor' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":35,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":35,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'midColor' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":42,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":42,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from 'three';\r\nimport { MeshStandardNodeMaterial } from 'three/webgpu';\r\nimport { \r\n    uniform, time, sin, cos, vec3, float, \r\n    mix, positionLocal, uv, \r\n    positionWorld, hash, modelWorldMatrix\r\n} from 'three/tsl';\r\n\r\nimport { WindUniforms as Wind } from './WindUniforms';\r\n\r\n/**\r\n * 创建草丛材质 (TSL)\r\n * @param colorBase 基础颜色 (底部)\r\n * @param colorTip 顶部颜色\r\n */\r\nexport function createGrassMaterial(colorBase: THREE.Color, colorTip: THREE.Color): MeshStandardNodeMaterial {\r\n    const material = new MeshStandardNodeMaterial();\r\n    material.side = THREE.DoubleSide;\r\n    material.transparent = true;\r\n    // material.alphaTest = 0.5; // 如果有纹理需要开启，纯几何体可以不需要\r\n    \r\n    // 颜色渐变 (基于 UV.y)\r\n    const uvCoord = uv();\r\n    const cBase = vec3(colorBase.r, colorBase.g, colorBase.b);\r\n    const cTip = vec3(colorTip.r, colorTip.g, colorTip.b);\r\n    \r\n    // 随机色调偏移\r\n    // TSL: positionWorld 在 InstancedMesh 中是顶点世界坐标\r\n    const randomVal = hash(positionWorld.xz.mul(0.1));\r\n    \r\n    // 基于高度的颜色变化: 顶部亮，底部暗 (模拟 AO)\r\n    const ao = uvCoord.y.pow(0.5); // 根部变黑\r\n    \r\n    // 基础颜色混合\r\n    const randomColor = mix(cBase, cTip, randomVal.mul(0.5).add(0.2)); \r\n    // 增加一点高光色 (阳光穿透)\r\n    const sunColor = vec3(1.0, 1.0, 0.8);\r\n    \r\n    // 垂直渐变: \r\n    const mixFactor = uvCoord.y;\r\n    // 增加中间色调\r\n    const midColor = mix(cBase, cTip, 0.5);\r\n    \r\n    // 使用 any 绕过 TSL 类型推断问题 (colorNode 最终接受 Node)\r\n    let finalColor: any = mix(cBase, cTip, mixFactor);\r\n    \r\n    // 添加一点条纹噪声 (程序化草叶纹理)\r\n    const bladeNoise = sin(uvCoord.x.mul(10.0)).mul(0.1);\r\n    finalColor = finalColor.add(bladeNoise);\r\n    \r\n    // 应用 AO\r\n    finalColor = finalColor.mul(ao.add(0.2));\r\n    \r\n    // 假 SSS (Subsurface Scattering): 背光时更亮? 这里简单模拟顶部透光\r\n    // 假设顶部受天空光影响更大\r\n    finalColor = finalColor.add(sunColor.mul(uvCoord.y.pow(3.0)).mul(0.2));\r\n\r\n    material.colorNode = finalColor;\r\n    material.roughnessNode = float(1.0); // 粗糙度高，模拟植物表面\r\n    \r\n    // Alpha Test 模拟叶子边缘形状 (如果不用几何体收缩)\r\n    // float shape = 1.0 - abs(uv.x - 0.5) * 2;\r\n    // material.opacityNode = smoothstep(0.0, 0.2, shape);\r\n    \r\n    // === 风动效果 ===\r\n    // 只有上半部分摆动\r\n    const heightFactor = uvCoord.y.pow(1.5); \r\n    \r\n    // 基于世界坐标的风场 - 更自然的噪声风\r\n    const t = time.mul(Wind.speed);\r\n    const worldPos = positionWorld;\r\n\r\n    // Directional phase: keeps wind coherent across all vegetation.\r\n    const phase = worldPos.x.mul(Wind.direction.x).add(worldPos.z.mul(Wind.direction.z));\r\n    \r\n    // 低频波浪 (大风)\r\n    const windWave = sin(t.add(phase.mul(0.35)));\r\n    \r\n    // 高频颤动 (细节)\r\n    const flutter = sin(t.mul(3.0).add(phase.mul(2.0))).mul(0.1);\r\n    \r\n    // 阵风 (间歇性)\r\n    const gust = sin(t.mul(0.5).add(phase.mul(0.08))).add(1.0).mul(0.5);\r\n    gust.mul(gust); // 强化对比度\r\n    \r\n    const combinedWind = windWave.add(flutter).mul(gust).mul(Wind.strength);\r\n    \r\n    const sway = combinedWind.mul(heightFactor);\r\n    const swayX = sway.mul(Wind.direction.x);\r\n    const swayZ = sway.mul(Wind.direction.z);\r\n    \r\n    material.positionNode = positionLocal.add(vec3(swayX, 0, swayZ));\r\n    \r\n    return material;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\shaders\\StorageBufferAttributeCompat.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\shaders\\TSLMaterials.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'t' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":86,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":86,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'t' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":384,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":384,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'t' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":404,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":404,"endColumn":12}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * TSL Materials System - 统一管理所有游戏材质\r\n * 使用 Three.js Shading Language (TSL) 最大化 GPU 性能\r\n */\r\nimport * as THREE from 'three';\r\nimport { MeshStandardNodeMaterial, MeshBasicNodeMaterial, SpriteNodeMaterial } from 'three/webgpu';\r\nimport {\r\n    uniform, mix, vec3, float, uv, time, sin,\r\n    smoothstep, fract, floor,\r\n    max, min, sub, length,\r\n    normalLocal, checker\r\n} from 'three/tsl';\r\n\r\n// ============= Uniform 管理器 =============\r\nexport class UniformManager {\r\n    private static instance: UniformManager;\r\n    \r\n    // 全局时间\r\n    public readonly globalTime = uniform(0);\r\n    \r\n    // 玩家相关\r\n    public readonly playerPosition = uniform(new THREE.Vector3());\r\n    public readonly playerHealth = uniform(1.0);\r\n    \r\n    // 环境相关\r\n    public readonly fogDensity = uniform(0.02);\r\n    public readonly fogColor = uniform(new THREE.Color(0x87ceeb));\r\n    public readonly ambientIntensity = uniform(0.6);\r\n    \r\n    // 游戏状态\r\n    public readonly gameTime = uniform(0);\r\n    public readonly damageFlash = uniform(0);\r\n\r\n    private constructor() {}\r\n\r\n    public static getInstance(): UniformManager {\r\n        if (!UniformManager.instance) {\r\n            UniformManager.instance = new UniformManager();\r\n        }\r\n        return UniformManager.instance;\r\n    }\r\n\r\n    public update(delta: number, playerPos: THREE.Vector3, health: number) {\r\n        this.globalTime.value += delta;\r\n        this.gameTime.value += delta;\r\n        this.playerPosition.value.copy(playerPos);\r\n        this.playerHealth.value = health / 100;\r\n        \r\n        // 受伤闪烁效果衰减\r\n        this.damageFlash.value = Math.max(0, this.damageFlash.value - delta * 5);\r\n    }\r\n\r\n    public triggerDamageFlash() {\r\n        this.damageFlash.value = 1.0;\r\n    }\r\n}\r\n\r\n// ============= 地面材质 =============\r\nexport function createGroundMaterial(): MeshStandardNodeMaterial {\r\n    const material = new MeshStandardNodeMaterial({\r\n        side: THREE.DoubleSide,\r\n        roughness: 0.9,\r\n        metalness: 0.1\r\n    });\r\n\r\n    // UV 坐标\r\n    const uvCoord = uv().mul(10);\r\n    \r\n    // 程序化地砖纹理\r\n    const tileX = fract(uvCoord.x);\r\n    const tileZ = fract(uvCoord.y);\r\n    \r\n    // 砖缝\r\n    const gapWidth = float(0.05);\r\n    const gapX = smoothstep(float(0), gapWidth, tileX).mul(smoothstep(float(1), sub(float(1), gapWidth), tileX));\r\n    const gapZ = smoothstep(float(0), gapWidth, tileZ).mul(smoothstep(float(1), sub(float(1), gapWidth), tileZ));\r\n    const gap = gapX.mul(gapZ);\r\n    \r\n    // 棋盘格颜色变化\r\n    const checkerVal = checker(uvCoord);\r\n    const baseColor1 = vec3(0.35, 0.32, 0.28);\r\n    const baseColor2 = vec3(0.42, 0.38, 0.32);\r\n    const tileColor = mix(baseColor1, baseColor2, checkerVal);\r\n    \r\n    // 添加噪声变化\r\n    const t = time;\r\n    const noiseVal = sin(uvCoord.x.mul(3.14).add(uvCoord.y.mul(2.71))).mul(0.02);\r\n    \r\n    // 砖缝颜色\r\n    const gapColor = vec3(0.15, 0.12, 0.1);\r\n    \r\n    // 混合\r\n    const finalColor = mix(gapColor, tileColor.add(noiseVal), gap);\r\n    \r\n    material.colorNode = finalColor;\r\n    \r\n    // 砖缝处略微凹陷的法线效果\r\n    const normalStrength = sub(float(1), gap).mul(0.3);\r\n    material.normalNode = normalLocal.add(vec3(0, normalStrength, 0));\r\n    \r\n    return material;\r\n}\r\n\r\n// ============= 墙壁材质 =============\r\nexport function createWallMaterial(): MeshStandardNodeMaterial {\r\n    const material = new MeshStandardNodeMaterial({\r\n        roughness: 0.8,\r\n        metalness: 0.1\r\n    });\r\n\r\n    // 垂直砖纹理\r\n    const uvCoord = uv();\r\n    const brickScaleX = float(4);\r\n    const brickScaleY = float(8);\r\n    \r\n    // 错位砖块\r\n    const row = floor(uvCoord.y.mul(brickScaleY));\r\n    const offset = row.mod(2).mul(0.5);\r\n    const adjustedU = uvCoord.x.mul(brickScaleX).add(offset);\r\n    \r\n    const brickU = fract(adjustedU);\r\n    const brickV = fract(uvCoord.y.mul(brickScaleY));\r\n    \r\n    // 砖缝\r\n    const mortarWidth = float(0.08);\r\n    const brickMaskU = smoothstep(float(0), mortarWidth, brickU)\r\n        .mul(smoothstep(float(1), sub(float(1), mortarWidth), brickU));\r\n    const brickMaskV = smoothstep(float(0), mortarWidth, brickV)\r\n        .mul(smoothstep(float(1), sub(float(1), mortarWidth), brickV));\r\n    const brickMask = brickMaskU.mul(brickMaskV);\r\n    \r\n    // 砖块颜色变化\r\n    const brickIndex = floor(adjustedU).add(row.mul(17));\r\n    const colorVariation = sin(brickIndex.mul(12.9898)).mul(0.05);\r\n    \r\n    const brickColor = vec3(0.28, 0.25, 0.22).add(colorVariation);\r\n    const mortarColor = vec3(0.15, 0.13, 0.11);\r\n    \r\n    const finalColor = mix(mortarColor, brickColor, brickMask);\r\n    material.colorNode = finalColor;\r\n    \r\n    return material;\r\n}\r\n\r\n// ============= 障碍物材质 =============\r\nexport function createObstacleMaterial(): MeshStandardNodeMaterial {\r\n    const material = new MeshStandardNodeMaterial({\r\n        roughness: 0.5,\r\n        metalness: 0.5\r\n    });\r\n\r\n    // 金属质感\r\n    const uvCoord = uv();\r\n    \r\n    // 划痕纹理\r\n    const scratchFreq = float(20);\r\n    const scratch1 = sin(uvCoord.x.mul(scratchFreq).add(uvCoord.y.mul(0.5)));\r\n    const scratch2 = sin(uvCoord.y.mul(scratchFreq).add(uvCoord.x.mul(0.3)));\r\n    const scratches = max(scratch1, scratch2).mul(0.5).add(0.5);\r\n    \r\n    // 基础颜色带变化\r\n    const baseColor = vec3(0.45, 0.42, 0.38);\r\n    const colorWithScratches = baseColor.mul(mix(float(0.9), float(1.1), scratches));\r\n    \r\n    material.colorNode = colorWithScratches;\r\n    \r\n    // 划痕处更粗糙\r\n    material.roughnessNode = mix(float(0.4), float(0.7), scratches);\r\n    \r\n    return material;\r\n}\r\n\r\n// ============= 敌人材质 =============\r\nexport function createEnemyMaterial(hitStrength: ReturnType<typeof uniform>): MeshStandardNodeMaterial {\r\n    const material = new MeshStandardNodeMaterial({\r\n        roughness: 0.5,\r\n        metalness: 0.2\r\n    });\r\n\r\n    const t = time;\r\n    \r\n    // 基础红色\r\n    const baseRed = vec3(0.9, 0.1, 0.05);\r\n    \r\n    // 脉动效果\r\n    const pulse = sin(t.mul(3)).mul(0.1).add(0.9);\r\n    const pulsingRed = baseRed.mul(pulse);\r\n    \r\n    // 受击白色闪烁\r\n    const hitColor = vec3(1, 1, 1);\r\n    const finalColor = mix(pulsingRed, hitColor, hitStrength);\r\n    \r\n    material.colorNode = finalColor;\r\n    \r\n    // 受击时发光\r\n    material.emissiveNode = mix(\r\n        vec3(0.1, 0, 0), // 正常状态微弱红光\r\n        vec3(1, 0.8, 0.6), // 受击时强烈发光\r\n        hitStrength\r\n    );\r\n    \r\n    return material;\r\n}\r\n\r\n// ============= 拾取物材质 =============\r\nexport function createPickupMaterial(type: 'health' | 'ammo', floatOffset: number): MeshStandardNodeMaterial {\r\n    const material = new MeshStandardNodeMaterial({\r\n        roughness: 0.3,\r\n        metalness: 0.7\r\n    });\r\n\r\n    const t = time;\r\n    const offset = float(floatOffset);\r\n    \r\n    // 彩虹边缘效果\r\n    const uvCoord = uv();\r\n    const edgeDist = min(\r\n        min(uvCoord.x, sub(float(1), uvCoord.x)),\r\n        min(uvCoord.y, sub(float(1), uvCoord.y))\r\n    );\r\n    const edgeGlow = smoothstep(float(0), float(0.3), edgeDist);\r\n    \r\n    // 基础颜色\r\n    let baseColor;\r\n    if (type === 'health') {\r\n        // 绿色治疗\r\n        baseColor = vec3(0.1, 0.9, 0.2);\r\n    } else {\r\n        // 金色弹药\r\n        baseColor = vec3(1.0, 0.85, 0.1);\r\n    }\r\n    \r\n    // 脉动\r\n    const pulse = sin(t.mul(5).add(offset)).mul(0.3).add(0.7);\r\n    \r\n    // 旋转彩虹效果\r\n    const angle = t.mul(2).add(offset);\r\n    const rainbow = vec3(\r\n        sin(angle).mul(0.5).add(0.5),\r\n        sin(angle.add(2.094)).mul(0.5).add(0.5),\r\n        sin(angle.add(4.188)).mul(0.5).add(0.5)\r\n    );\r\n    \r\n    // 边缘彩虹\r\n    const colorWithEdge = mix(rainbow.mul(0.5).add(baseColor.mul(0.5)), baseColor, edgeGlow);\r\n    \r\n    material.colorNode = colorWithEdge.mul(pulse);\r\n    \r\n    // 强发光效果\r\n    material.emissiveNode = baseColor.mul(pulse).mul(0.6);\r\n    \r\n    return material;\r\n}\r\n\r\n// ============= 武器材质 =============\r\nexport function createWeaponMaterial(): MeshStandardNodeMaterial {\r\n    const material = new MeshStandardNodeMaterial({\r\n        roughness: 0.3,\r\n        metalness: 0.9\r\n    });\r\n\r\n    const uvCoord = uv();\r\n    \r\n    // 金属刷纹\r\n    const brushFreq = float(100);\r\n    const brushPattern = sin(uvCoord.x.mul(brushFreq)).mul(0.02);\r\n    \r\n    // 深灰金属\r\n    const baseColor = vec3(0.35, 0.32, 0.30);\r\n    const brushedColor = baseColor.add(brushPattern);\r\n    \r\n    material.colorNode = brushedColor;\r\n    \r\n    // 环境反射\r\n    material.envMapIntensity = 0.5;\r\n    \r\n    return material;\r\n}\r\n\r\n// ============= 枪口火焰材质 =============\r\nexport function createMuzzleFlashMaterial(): MeshBasicNodeMaterial {\r\n    const material = new MeshBasicNodeMaterial();\r\n\r\n    const t = time;\r\n    \r\n    // 快速闪烁\r\n    const flash = sin(t.mul(100)).mul(0.5).add(0.5);\r\n    \r\n    // 橙黄色火焰\r\n    const fireColor = mix(\r\n        vec3(1, 0.8, 0.2),\r\n        vec3(1, 0.4, 0.1),\r\n        flash\r\n    );\r\n    \r\n    material.colorNode = fireColor;\r\n    material.transparent = true;\r\n    material.opacity = 0.9;\r\n    \r\n    return material;\r\n}\r\n\r\n// ============= 楼梯材质 =============\r\nexport function createStairMaterial(): MeshStandardNodeMaterial {\r\n    const material = new MeshStandardNodeMaterial({\r\n        roughness: 0.6,\r\n        metalness: 0.3\r\n    });\r\n\r\n    const uvCoord = uv();\r\n    \r\n    // 混凝土纹理\r\n    const noiseScale = float(10);\r\n    const noise1 = sin(uvCoord.x.mul(noiseScale)).mul(sin(uvCoord.y.mul(noiseScale)));\r\n    const noise2 = sin(uvCoord.x.mul(noiseScale.mul(2.3))).mul(sin(uvCoord.y.mul(noiseScale.mul(1.7))));\r\n    const combinedNoise = noise1.mul(0.5).add(noise2.mul(0.3)).mul(0.05);\r\n    \r\n    // 水泥灰\r\n    const baseColor = vec3(0.55, 0.53, 0.50);\r\n    const texturedColor = baseColor.add(combinedNoise);\r\n    \r\n    material.colorNode = texturedColor;\r\n    \r\n    // 边缘磨损\r\n    const edgeWear = smoothstep(float(0.02), float(0.1), uvCoord.x)\r\n        .mul(smoothstep(float(0.98), float(0.9), uvCoord.x));\r\n    material.roughnessNode = mix(float(0.8), float(0.5), edgeWear);\r\n    \r\n    return material;\r\n}\r\n\r\n// ============= 天空盒材质 (用于雾效果) =============\r\nexport function createSkyMaterial(): MeshBasicNodeMaterial {\r\n    const material = new MeshBasicNodeMaterial();\r\n    \r\n    // 渐变天空\r\n    const uvCoord = uv();\r\n    \r\n    const horizonColor = vec3(0.7, 0.85, 0.95);\r\n    const zenithColor = vec3(0.4, 0.6, 0.9);\r\n    \r\n    const gradient = smoothstep(float(0), float(1), uvCoord.y);\r\n    const skyColor = mix(horizonColor, zenithColor, gradient);\r\n    \r\n    material.colorNode = skyColor;\r\n    material.side = THREE.BackSide;\r\n    \r\n    return material;\r\n}\r\n\r\n// ============= 伤害叠加效果 (用于后处理) =============\r\nexport function createDamageOverlayMaterial(): MeshBasicNodeMaterial {\r\n    const material = new MeshBasicNodeMaterial();\r\n    \r\n    const uniforms = UniformManager.getInstance();\r\n    const damageAmount = uniforms.damageFlash;\r\n    \r\n    // 红色边缘晕影\r\n    const coord = uv();\r\n    const center = vec3(0.5, 0.5, 0);\r\n    const distFromCenter = length(coord.sub(center.xy));\r\n    \r\n    // 边缘更红\r\n    const vignette = smoothstep(float(0.3), float(0.8), distFromCenter);\r\n    \r\n    // 脉动\r\n    const pulse = sin(time.mul(20)).mul(0.2).add(0.8);\r\n    \r\n    const damageColor = vec3(0.8, 0.1, 0.05).mul(vignette).mul(damageAmount).mul(pulse);\r\n    \r\n    material.colorNode = damageColor;\r\n    material.transparent = true;\r\n    material.opacityNode = damageAmount.mul(0.6);\r\n    material.depthTest = false;\r\n    material.depthWrite = false;\r\n    \r\n    return material;\r\n}\r\n\r\n// ============= 弹道轨迹材质 =============\r\nexport function createBulletTrailMaterial(): MeshBasicNodeMaterial {\r\n    const material = new MeshBasicNodeMaterial();\r\n    \r\n    const t = time;\r\n    const uvCoord = uv();\r\n    \r\n    // 渐变消失\r\n    const fade = sub(float(1), uvCoord.x);\r\n    \r\n    // 橙黄色轨迹\r\n    const trailColor = vec3(1, 0.7, 0.2).mul(fade);\r\n    \r\n    material.colorNode = trailColor;\r\n    material.transparent = true;\r\n    material.opacity = 0.8;\r\n    \r\n    return material;\r\n}\r\n\r\n// ============= 粒子材质 =============\r\nexport function createParticleMaterial(particleType: 'spark' | 'smoke' | 'blood'): SpriteNodeMaterial {\r\n    const material = new SpriteNodeMaterial();\r\n    \r\n    const t = time;\r\n    \r\n    switch (particleType) {\r\n        case 'spark':\r\n            material.colorNode = vec3(1, 0.8, 0.3);\r\n            break;\r\n        case 'smoke':\r\n            material.colorNode = vec3(0.3, 0.3, 0.35);\r\n            break;\r\n        case 'blood':\r\n            material.colorNode = vec3(0.7, 0.05, 0.02);\r\n            break;\r\n    }\r\n    \r\n    material.transparent = true;\r\n    material.depthWrite = false;\r\n    \r\n    return material;\r\n}\r\n\r\nexport const TSLMaterials = {\r\n    createGroundMaterial,\r\n    createWallMaterial,\r\n    createObstacleMaterial,\r\n    createEnemyMaterial,\r\n    createPickupMaterial,\r\n    createWeaponMaterial,\r\n    createMuzzleFlashMaterial,\r\n    createStairMaterial,\r\n    createSkyMaterial,\r\n    createDamageOverlayMaterial,\r\n    createBulletTrailMaterial,\r\n    createParticleMaterial\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\shaders\\TreeTSL.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'color' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'uniform' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cos' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'normalLocal' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'modelWorldMatrix' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as THREE from 'three';\r\nimport { MeshStandardNodeMaterial } from 'three/webgpu'; // 注意：Vite 环境下可能是 three/webgpu\r\nimport { \r\n    color, uniform, time, sin, cos, vec3, float, \r\n    mix, positionLocal, normalLocal, uv, floor,\r\n    positionWorld, hash, modelWorldMatrix\r\n} from 'three/tsl';\r\n\r\nimport { WindUniforms as Wind } from './WindUniforms';\r\n\r\n/**\r\n * 创建树干材质 (TSL)\r\n * @param colorTint 树干的基础颜色倾向\r\n */\r\nexport function createTrunkMaterial(colorTint: THREE.Color = new THREE.Color(0.35, 0.25, 0.15)): MeshStandardNodeMaterial {\r\n    const material = new MeshStandardNodeMaterial();\r\n    \r\n    // 基础颜色\r\n    const baseColor = vec3(colorTint.r, colorTint.g, colorTint.b);\r\n    const variation = hash(positionWorld.xz).mul(0.1); // 基于位置的颜色微调\r\n    \r\n    // 简单的树皮纹理噪声\r\n    const uvCoord = uv();\r\n    const barkNoise = sin(uvCoord.y.mul(20.0).add(sin(uvCoord.x.mul(10.0)))).mul(0.1);\r\n    \r\n    material.colorNode = baseColor.add(variation).add(barkNoise);\r\n    material.roughnessNode = float(0.9);\r\n    material.metalnessNode = float(0.0);\r\n    \r\n    // 简单的风动 (树干)\r\n    const heightFactor = positionLocal.y.max(0.0);\r\n    const worldPos = positionWorld;\r\n    const t = time.mul(Wind.speed);\r\n    const phase = worldPos.x.mul(Wind.direction.x).add(worldPos.z.mul(Wind.direction.z));\r\n    const sway = sin(t.add(phase.mul(0.5)))\r\n        .mul(Wind.strength)\r\n        .mul(0.1)\r\n        .mul(heightFactor);\r\n\r\n    material.positionNode = positionLocal.add(vec3(sway.mul(Wind.direction.x), 0, sway.mul(Wind.direction.z)));\r\n    \r\n    return material;\r\n}\r\n\r\n/**\r\n * 创建树叶材质 (TSL)\r\n * @param color1Hex 深色 (底部/阴影)\r\n * @param color2Hex 浅色 (顶部/高光)\r\n */\r\nexport function createLeavesMaterial(color1Hex: THREE.Color = new THREE.Color(0.1, 0.4, 0.1), color2Hex: THREE.Color = new THREE.Color(0.3, 0.6, 0.2)): MeshStandardNodeMaterial {\r\n    const material = new MeshStandardNodeMaterial();\r\n    \r\n    const color1 = vec3(color1Hex.r, color1Hex.g, color1Hex.b);\r\n    const color2 = vec3(color2Hex.r, color2Hex.g, color2Hex.b);\r\n    \r\n    // 基于世界坐标的随机颜色，让每棵树颜色不同\r\n    const randomVal = hash(floor(positionWorld.xz.div(2.0))); \r\n    const treeColor = mix(color1, color2, randomVal);\r\n    \r\n    // 增加一点基于 UV 的渐变\r\n    const leafGradient = uv().y.mul(0.2);\r\n    \r\n    material.colorNode = treeColor.add(leafGradient);\r\n    material.roughnessNode = float(0.8);\r\n    \r\n    // === 风动效果 ===\r\n    const heightFactor = positionLocal.y.max(0.0);\r\n    const worldPos = positionWorld;\r\n    \r\n    const t = time.mul(Wind.speed);\r\n    const phase = worldPos.x.mul(Wind.direction.x).add(worldPos.z.mul(Wind.direction.z));\r\n    \r\n    // 主风向摆动 (X轴)\r\n    const sway = sin(t.add(phase.mul(0.35)))\r\n        .mul(Wind.strength)\r\n        .mul(heightFactor.pow(1.5));\r\n    const swayX = sway.mul(Wind.direction.x);\r\n    const swayZ = sway.mul(Wind.direction.z);\r\n        \r\n    // 树叶颤动\r\n    const flutter = sin(t.mul(5.0).add(positionLocal.x).add(positionLocal.z).add(phase.mul(1.5)))\r\n        .mul(0.02)\r\n        .mul(heightFactor);\r\n\r\n    material.positionNode = positionLocal.add(vec3(swayX.add(flutter), 0, swayZ.add(flutter)));\r\n    \r\n    return material;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\shaders\\WindUniforms.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\shaders\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\systems\\AudioSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\systems\\EnemySystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\systems\\EnemyTrailSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\systems\\GPUComputeUpdateSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\systems\\GrenadeSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\systems\\LevelUpdateSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\systems\\ParticleUpdateSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\systems\\PickupSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\systems\\PlayerUpdateSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\systems\\RenderSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\systems\\ShadowSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\systems\\SpawnSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\systems\\UniformUpdateSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\weapon\\PlayerGrenadeWeapon.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\weapon\\PlayerHitscanWeapon.ts","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-explicit-any').","line":31,"column":9,"severity":1,"nodeType":null,"fix":{"range":[1299,1361],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-explicit-any').","line":39,"column":9,"severity":1,"nodeType":null,"fix":{"range":[1573,1635],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-explicit-any').","line":49,"column":13,"severity":1,"nodeType":null,"fix":{"range":[1963,2025],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-explicit-any').","line":65,"column":9,"severity":1,"nodeType":null,"fix":{"range":[2609,2671],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-explicit-any').","line":137,"column":9,"severity":1,"nodeType":null,"fix":{"range":[5212,5274],"text":" "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":5,"source":"import * as THREE from 'three';\r\nimport { uniform } from 'three/tsl';\r\nimport { Enemy } from '../enemy/Enemy';\r\nimport type { GameServices } from '../core/services/GameServices';\r\nimport type { ParticleSimulation } from '../core/gpu/GpuSimulationFacade';\r\nimport { PhysicsSystem } from '../core/PhysicsSystem';\r\nimport { BulletTrail, HitEffect } from './WeaponEffects';\r\nimport { WeaponFactory } from './WeaponFactory';\r\nimport { IPlayerWeapon, RangedWeaponDefinition, WeaponContext } from './WeaponTypes';\r\nimport type { GameEventBus } from '../core/events/GameEventBus';\r\n\r\nexport class PlayerHitscanWeapon implements IPlayerWeapon {\r\n    public readonly id: RangedWeaponDefinition['id'];\r\n    public readonly category = 'ranged' as const;\r\n\r\n    private def: RangedWeaponDefinition;\r\n\r\n    private camera: THREE.Camera;\r\n    private services: GameServices;\r\n    private events: GameEventBus;\r\n    private mesh: THREE.Mesh;\r\n    private raycaster: THREE.Raycaster;\r\n    private v2Zero = new THREE.Vector2(0, 0);\r\n\r\n    private raycastObjects: THREE.Object3D[] = [];\r\n    private intersects: THREE.Intersection[] = [];\r\n    private physicsCandidates: THREE.Object3D[] = [];\r\n\r\n    private appendRaycastTargetsInto(root: THREE.Object3D, out: THREE.Object3D[]) {\r\n        // Fast path: mesh\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        const anyRoot = root as any;\r\n        if (anyRoot.isMesh) {\r\n            out.push(root);\r\n            return;\r\n        }\r\n\r\n        // Cache per object: static world and enemy rigs are stable.\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        const ud = (root.userData ?? {}) as any;\r\n        const cached = ud._hitscanTargets as THREE.Object3D[] | undefined;\r\n        if (cached) {\r\n            for (const t of cached) out.push(t);\r\n            return;\r\n        }\r\n\r\n        const targets: THREE.Object3D[] = [];\r\n        root.traverse((obj) => {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            const anyObj = obj as any;\r\n            if (!anyObj.isMesh) return;\r\n            const userData = obj.userData;\r\n            if (userData?.noRaycast) return;\r\n            if (userData?.isWayPoint) return;\r\n            if (userData?.isDust) return;\r\n            if (userData?.isSkybox) return;\r\n            if (userData?.isWeatherParticle) return;\r\n            if (userData?.isEffect) return;\r\n            if (userData?.isBulletTrail) return;\r\n            if (userData?.isGrenade) return;\r\n            targets.push(obj);\r\n        });\r\n\r\n        // Persist cache\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        (root.userData as any)._hitscanTargets = targets;\r\n        for (const t of targets) out.push(t);\r\n    }\r\n\r\n    private findEnemyFromObject(obj: THREE.Object3D | null): Enemy | null {\r\n        let cur: THREE.Object3D | null = obj;\r\n        while (cur) {\r\n            const ud: any = (cur as any).userData;\r\n            if (ud?.isEnemy && ud?.entity) return ud.entity as Enemy;\r\n            cur = cur.parent;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private tmpCurrentPos = new THREE.Vector3();\r\n    private tmpRayOrigin = new THREE.Vector3();\r\n    private tmpRayDirection = new THREE.Vector3();\r\n    private tmpStep = new THREE.Vector3();\r\n    private tmpMuzzlePos = new THREE.Vector3();\r\n    private tmpTrailEnd = new THREE.Vector3();\r\n    private tmpHitPoint = new THREE.Vector3();\r\n    private tmpGroundHitPoint = new THREE.Vector3();\r\n    private tmpHitNormal = new THREE.Vector3(0, 1, 0);\r\n    private tmpUp = new THREE.Vector3(0, 1, 0);\r\n    private tmpBloodDir = new THREE.Vector3();\r\n\r\n    private flashMesh: THREE.Mesh | null = null;\r\n    private flashIntensity: any;\r\n\r\n    private recoilOffset: THREE.Vector3 = new THREE.Vector3();\r\n    private swayOffset: THREE.Vector3 = new THREE.Vector3();\r\n\r\n    private bulletTrails: BulletTrail[] = [];\r\n    private bulletTrailPool: BulletTrail[] = [];\r\n\r\n    private hitEffects: HitEffect[] = [];\r\n    private hitEffectPool: HitEffect[] = [];\r\n\r\n    private scene: THREE.Scene | null = null;\r\n\r\n    private particleSystem: ParticleSimulation | null = null;\r\n    private enemies: Enemy[] = [];\r\n    private physicsSystem: PhysicsSystem | null = null;\r\n\r\n    private muzzlePoint: THREE.Object3D;\r\n\r\n    private triggerHeld = false;\r\n    private fireCooldown = 0;\r\n\r\n    // muzzle flash fade (avoid setTimeout per shot)\r\n    private flashTimeRemaining = 0;\r\n    private readonly flashDuration = 0.06;\r\n\r\n    // aiming\r\n    private isAiming: boolean = false;\r\n    private aimProgress: number = 0;\r\n\r\n    private onGetGroundHeight: ((x: number, z: number) => number) | null = null;\r\n\r\n    private hipPosition: THREE.Vector3;\r\n    private adsPosition: THREE.Vector3;\r\n\r\n    constructor(camera: THREE.Camera, def: RangedWeaponDefinition, services: GameServices, events: GameEventBus) {\r\n        this.camera = camera;\r\n        this.def = def;\r\n        this.id = def.id;\r\n        this.services = services;\r\n        this.events = events;\r\n\r\n        this.raycaster = new THREE.Raycaster();\r\n        // When three-mesh-bvh is enabled, this stops traversal after the first hit.\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        (this.raycaster as any).firstHitOnly = true;\r\n        this.raycaster.near = 0;\r\n        this.raycaster.far = def.range;\r\n        this.flashIntensity = uniform(0);\r\n\r\n        const assets = WeaponFactory.createPlayerWeaponMesh(def.id);\r\n        this.mesh = assets.mesh;\r\n        this.muzzlePoint = assets.muzzlePoint;\r\n        this.camera.add(this.mesh);\r\n\r\n        if (def.muzzleFlash) {\r\n            this.flashMesh = WeaponFactory.createMuzzleFlash(this.flashIntensity);\r\n            this.mesh.add(this.flashMesh);\r\n        }\r\n\r\n        // Prewarm small effect pools to avoid first-shot hitch.\r\n        for (let i = 0; i < 4; i++) this.bulletTrailPool.push(new BulletTrail());\r\n        for (let i = 0; i < 2; i++) this.hitEffectPool.push(new HitEffect());\r\n\r\n        // 默认位置：沿用旧 WeaponConfig 的感受\r\n        this.hipPosition = assets.hipPosition;\r\n        this.adsPosition = assets.adsPosition;\r\n\r\n        this.hide();\r\n    }\r\n\r\n    public setGroundHeightCallback(callback: (x: number, z: number) => number) {\r\n        this.onGetGroundHeight = callback;\r\n    }\r\n\r\n    public setParticleSystem(system: ParticleSimulation) {\r\n        this.particleSystem = system;\r\n    }\r\n\r\n    public setEnemies(enemies: Enemy[]) {\r\n        this.enemies = enemies;\r\n    }\r\n\r\n    public setPhysicsSystem(sys: PhysicsSystem) {\r\n        this.physicsSystem = sys;\r\n    }\r\n\r\n    public show(): void {\r\n        this.mesh.visible = true;\r\n    }\r\n\r\n    public hide(): void {\r\n        this.mesh.visible = false;\r\n        if (this.flashMesh) this.flashMesh.visible = false;\r\n    }\r\n\r\n    public onTriggerDown(ctx: WeaponContext): void {\r\n        this.scene = ctx.scene;\r\n        this.triggerHeld = true;\r\n        // 立即尝试开火\r\n        this.tryFire();\r\n    }\r\n\r\n    public onTriggerUp(): void {\r\n        this.triggerHeld = false;\r\n    }\r\n\r\n    public startAiming(): void {\r\n        if (!this.def.supportsAiming) return;\r\n        this.isAiming = true;\r\n    }\r\n\r\n    public stopAiming(): void {\r\n        this.isAiming = false;\r\n    }\r\n\r\n    public getAimProgress(): number {\r\n        return this.aimProgress;\r\n    }\r\n\r\n    public update(delta: number): void {\r\n        // fire loop\r\n        if (this.fireCooldown > 0) this.fireCooldown -= delta;\r\n        if (this.triggerHeld && this.def.canAutoFire) {\r\n            this.tryFire();\r\n        }\r\n\r\n        // aim interpolate\r\n        const target = this.isAiming ? 1 : 0;\r\n        this.aimProgress = THREE.MathUtils.lerp(this.aimProgress, target, delta * 8.0);\r\n        if (Math.abs(this.aimProgress - target) < 0.001) this.aimProgress = target;\r\n\r\n        // sway/recoil\r\n        const t = performance.now() * 0.001;\r\n        const swayMultiplier = 1 - this.aimProgress * 0.8;\r\n        this.swayOffset.x = Math.sin(t * 1.5) * 0.003 * swayMultiplier;\r\n        this.swayOffset.y = Math.sin(t * 2) * 0.002 * swayMultiplier;\r\n\r\n        // recoil recover\r\n        this.recoilOffset.z = THREE.MathUtils.lerp(this.recoilOffset.z, 0, delta * 5.0);\r\n        this.recoilOffset.y = THREE.MathUtils.lerp(this.recoilOffset.y, 0, delta * 4.0);\r\n\r\n        this.tmpCurrentPos.lerpVectors(this.hipPosition, this.adsPosition, this.aimProgress);\r\n        this.mesh.position.x = this.tmpCurrentPos.x + this.swayOffset.x;\r\n        this.mesh.position.y = this.tmpCurrentPos.y + this.swayOffset.y + this.recoilOffset.y;\r\n        this.mesh.position.z = this.tmpCurrentPos.z + this.recoilOffset.z;\r\n\r\n        // muzzle flash fade\r\n        if (this.flashMesh && this.flashMesh.visible) {\r\n            this.flashTimeRemaining = Math.max(0, this.flashTimeRemaining - delta);\r\n            const p = this.flashDuration > 0 ? (this.flashTimeRemaining / this.flashDuration) : 0;\r\n            this.flashIntensity.value = p;\r\n            if (this.flashTimeRemaining <= 0.0001) {\r\n                this.flashIntensity.value = 0;\r\n                this.flashMesh.visible = false;\r\n            }\r\n        }\r\n\r\n        // trails\r\n        for (let i = this.bulletTrails.length - 1; i >= 0; i--) {\r\n            const trail = this.bulletTrails[i];\r\n            trail.update(delta);\r\n            if (trail.isDead) {\r\n                if (this.scene) this.scene.remove(trail.mesh);\r\n                this.bulletTrails.splice(i, 1);\r\n                this.bulletTrailPool.push(trail);\r\n            }\r\n        }\r\n\r\n        // hit effects\r\n        for (let i = this.hitEffects.length - 1; i >= 0; i--) {\r\n            const effect = this.hitEffects[i];\r\n            effect.update(delta);\r\n            if (effect.isDead) {\r\n                if (this.scene) this.scene.remove(effect.group);\r\n                this.hitEffects.splice(i, 1);\r\n                this.hitEffectPool.push(effect);\r\n            }\r\n        }\r\n    }\r\n\r\n    private tryFire() {\r\n        if (this.fireCooldown > 0) return;\r\n        if (!this.scene) return;\r\n\r\n        const state = this.services.state.getState();\r\n        if (this.def.usesAmmo && state.ammo < this.def.ammoPerShot) return;\r\n\r\n        this.fireCooldown = 1 / Math.max(0.01, this.def.fireRate);\r\n\r\n        if (this.def.usesAmmo) {\r\n            this.events.emit({ type: 'state:updateAmmo', delta: -this.def.ammoPerShot });\r\n        }\r\n\r\n        // sound\r\n        if (this.def.id === 'sniper' && this.isAiming) this.events.emit({ type: 'sound:play', sound: 'sniperShoot' });\r\n        else this.events.emit({ type: 'sound:play', sound: 'shoot' });\r\n\r\n        // muzzle flash\r\n        if (this.flashMesh) this.showMuzzleFlash();\r\n\r\n        // recoil\r\n        this.applyRecoil();\r\n\r\n        // raycast\r\n        this.raycaster.setFromCamera(this.v2Zero, this.camera);\r\n        // Clamp far so we don't traverse beyond weapon range.\r\n        this.raycaster.far = this.def.range;\r\n\r\n        const raycastObjects = this.raycastObjects;\r\n        raycastObjects.length = 0;\r\n        for (const enemy of this.enemies) {\r\n            if (!enemy.isDead) this.appendRaycastTargetsInto(enemy.mesh, raycastObjects);\r\n        }\r\n\r\n        if (this.physicsSystem) {\r\n            const candidates = this.physicsSystem.getRaycastCandidatesInto(\r\n                this.raycaster.ray.origin,\r\n                this.raycaster.ray.direction,\r\n                this.def.range,\r\n                this.physicsCandidates,\r\n            );\r\n            for (const obj of candidates) this.appendRaycastTargetsInto(obj, raycastObjects);\r\n        } else {\r\n            for (const child of this.scene.children) {\r\n                if (child.userData?.isGround) continue;\r\n                if (child.userData?.isDust) continue;\r\n                if (child.userData?.isSkybox) continue;\r\n                if (child.userData?.isWeatherParticle) continue;\r\n                if (child.userData?.isEffect) continue;\r\n                if (child.userData?.isBulletTrail) continue;\r\n                if (child.userData?.isGrenade) continue;\r\n                this.appendRaycastTargetsInto(child, raycastObjects);\r\n            }\r\n        }\r\n\r\n        const intersects = this.intersects;\r\n        intersects.length = 0;\r\n        // Raycast against a flat mesh list; no recursive traversal.\r\n        this.raycaster.intersectObjects(raycastObjects, false, intersects);\r\n\r\n        const rayOrigin = this.tmpRayOrigin.copy(this.raycaster.ray.origin);\r\n        const rayDirection = this.tmpRayDirection.copy(this.raycaster.ray.direction).normalize();\r\n\r\n        let hitPoint: THREE.Vector3 | null = null;\r\n        let hitNormal: THREE.Vector3 | null = null;\r\n        let hitObject: THREE.Object3D | null = null;\r\n\r\n        for (const intersect of intersects) {\r\n            const obj = intersect.object;\r\n\r\n            if (obj.userData?.isGround) continue;\r\n            if (obj.userData?.isSkybox) continue;\r\n            if (obj.userData?.isEnemyWeapon) continue;\r\n\r\n            // skip self\r\n            let shouldSkip = false;\r\n            let parent: THREE.Object3D | null = obj;\r\n            while (parent) {\r\n                if (parent === this.mesh) {\r\n                    shouldSkip = true;\r\n                    break;\r\n                }\r\n                if (parent.userData?.isBulletTrail || parent.userData?.isGrenade) {\r\n                    shouldSkip = true;\r\n                    break;\r\n                }\r\n                parent = parent.parent;\r\n            }\r\n            if (shouldSkip) continue;\r\n\r\n            hitPoint = this.tmpHitPoint.copy(intersect.point);\r\n            this.tmpHitNormal.copy(intersect.face?.normal ?? this.tmpUp);\r\n            hitNormal = this.tmpHitNormal;\r\n            if ((obj as any).matrixWorld) hitNormal.transformDirection((obj as any).matrixWorld);\r\n            hitObject = obj;\r\n            break;\r\n        }\r\n\r\n        // ground raymarch (optional)\r\n        if (!hitPoint && this.onGetGroundHeight && rayDirection.y < -0.0001) {\r\n            const maxDist = Math.min(120, this.def.range);\r\n            // Fallback only: keep it cheap.\r\n            const stepSize = 2.0;\r\n            const currentPos = this.tmpCurrentPos.copy(rayOrigin);\r\n            this.tmpStep.copy(rayDirection).multiplyScalar(stepSize);\r\n            let dist = 0;\r\n            while (dist < maxDist) {\r\n                currentPos.add(this.tmpStep);\r\n                dist += stepSize;\r\n                const terrainHeight = this.onGetGroundHeight(currentPos.x, currentPos.z);\r\n                if (currentPos.y < terrainHeight) {\r\n                    hitPoint = this.tmpGroundHitPoint.copy(rayOrigin).addScaledVector(rayDirection, dist);\r\n                    hitNormal = this.tmpUp;\r\n                    hitObject = null;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (hitPoint) {\r\n            const enemy = hitObject ? this.findEnemyFromObject(hitObject) : null;\r\n            if (enemy) {\r\n                const damage = this.isAiming && this.def.aimDamage ? this.def.aimDamage : this.def.damage;\r\n                enemy.takeDamage(damage);\r\n                this.events.emit({ type: 'sound:play', sound: 'hit' });\r\n\r\n                const bloodDirection = this.tmpBloodDir.copy(rayDirection).negate().add(hitNormal ?? this.tmpUp).normalize();\r\n                if (this.particleSystem) {\r\n                    this.particleSystem.emitBlood(hitPoint, bloodDirection, 10);\r\n                }\r\n                this.createHitEffect(hitPoint, hitNormal ?? this.tmpUp, 'blood');\r\n            } else {\r\n                if (this.particleSystem) {\r\n                    this.particleSystem.emitSparks(hitPoint, hitNormal ?? this.tmpUp, 8);\r\n                }\r\n                this.createHitEffect(hitPoint, hitNormal ?? this.tmpUp, 'spark');\r\n            }\r\n        }\r\n\r\n        // trail\r\n        if (this.def.bulletTrail) {\r\n            const muzzlePos = this.getMuzzleWorldPosition(this.tmpMuzzlePos);\r\n            const trailEnd = this.tmpTrailEnd;\r\n            if (hitPoint) trailEnd.copy(hitPoint);\r\n            else trailEnd.copy(muzzlePos).addScaledVector(rayDirection, this.def.range);\r\n            this.createBulletTrail(muzzlePos, trailEnd);\r\n        }\r\n\r\n        // muzzle particles\r\n        if (this.particleSystem && this.def.muzzleFlash) {\r\n            const muzzlePos = this.getMuzzleWorldPosition(this.tmpMuzzlePos);\r\n            this.particleSystem.emitMuzzleFlash(muzzlePos, rayDirection);\r\n        }\r\n    }\r\n\r\n    private getMuzzleWorldPosition(out: THREE.Vector3 = new THREE.Vector3()): THREE.Vector3 {\r\n        this.camera.updateMatrixWorld(true);\r\n        this.muzzlePoint.getWorldPosition(out);\r\n        return out;\r\n    }\r\n\r\n    private showMuzzleFlash() {\r\n        if (!this.flashMesh) return;\r\n        this.flashMesh.visible = true;\r\n        this.flashTimeRemaining = this.flashDuration;\r\n        this.flashIntensity.value = 1;\r\n        this.flashMesh.rotation.z = Math.random() * Math.PI * 2;\r\n    }\r\n\r\n    private applyRecoil() {\r\n        // weapon-specific recoil: snipers kick more, pistols less\r\n        let amount = 0.045;\r\n        if (this.def.id === 'sniper') amount = 0.08;\r\n        if (this.def.id === 'pistol') amount = 0.035;\r\n        if (this.def.id === 'smg') amount = 0.03;\r\n\r\n        this.recoilOffset.z += amount;\r\n        this.recoilOffset.y += amount * 0.3;\r\n        this.recoilOffset.z = Math.min(this.recoilOffset.z, 0.18);\r\n        this.recoilOffset.y = Math.min(this.recoilOffset.y, 0.06);\r\n    }\r\n\r\n    private createBulletTrail(start: THREE.Vector3, end: THREE.Vector3) {\r\n        if (!this.scene) return;\r\n        let trail: BulletTrail;\r\n        if (this.bulletTrailPool.length > 0) trail = this.bulletTrailPool.pop()!;\r\n        else trail = new BulletTrail();\r\n\r\n        trail.init(start, end);\r\n        if (!trail.isDead) {\r\n            this.scene.add(trail.mesh);\r\n            this.bulletTrails.push(trail);\r\n        } else {\r\n            this.bulletTrailPool.push(trail);\r\n        }\r\n    }\r\n\r\n    private createHitEffect(position: THREE.Vector3, normal: THREE.Vector3, type: 'spark' | 'blood') {\r\n        if (!this.scene) return;\r\n        let effect: HitEffect;\r\n        if (this.hitEffectPool.length > 0) effect = this.hitEffectPool.pop()!;\r\n        else effect = new HitEffect();\r\n        effect.init(position, normal, type);\r\n        this.scene.add(effect.group);\r\n        this.hitEffects.push(effect);\r\n    }\r\n\r\n    public dispose(): void {\r\n        this.camera.remove(this.mesh);\r\n        this.mesh.geometry.dispose();\r\n        (this.mesh.material as THREE.Material).dispose();\r\n\r\n        if (this.flashMesh) {\r\n            this.flashMesh.geometry.dispose();\r\n            (this.flashMesh.material as THREE.Material).dispose();\r\n        }\r\n\r\n        this.bulletTrails.forEach(t => t.dispose());\r\n        this.hitEffects.forEach(e => e.dispose());\r\n        this.bulletTrailPool.forEach(t => t.dispose());\r\n        this.hitEffectPool.forEach(e => e.dispose());\r\n        this.bulletTrails = [];\r\n        this.hitEffects = [];\r\n        this.bulletTrailPool = [];\r\n        this.hitEffectPool = [];\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\weapon\\PlayerMeleeWeapon.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\weapon\\PlayerWeaponSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\weapon\\Weapon.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\weapon\\WeaponDefinitions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\weapon\\WeaponEffects.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\weapon\\WeaponFactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\game\\weapon\\WeaponTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\i18n.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\ui\\components\\Crosshair.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\ui\\components\\GameOverScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\ui\\components\\LanguageToggle.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\ui\\components\\LoadingScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\ui\\components\\PickupHint.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\ui\\components\\SettingsOverlay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\ui\\hud\\HUD.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\ui\\hud\\PerformanceStats.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\ui\\hud\\ScoreInfo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\ui\\hud\\StatusPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\ui\\hud\\WeaponPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\node\\tauri\\fps-game\\src\\vite-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
